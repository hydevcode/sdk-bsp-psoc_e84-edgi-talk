<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>emusb-device</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">emusb-device</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">SEGGER emUSB-Device for ModusToolbox User Guide </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a href="https://www.segger.com/products/connectivity/emusb-device/"><b>emUSB-Device</b></a> enables easy integration of USB functionality into an embedded system.Multiple standard classes are provided that allow embedded systems to behave as standard USB devices and communicate with any host like Windows, Linux and Mac systems. Infineon has licensed emUSB-Device from SEGGER and offers it for free to its customers. This middleware library provides emUSB-Device in the form of pre-build libraries.</p>
<p ><b>Features:</b></p><ul>
<li>High performance</li>
<li>Can be used with or without an RTOS</li>
<li>Easy to use</li>
<li>Easy to port</li>
<li>No custom USB host driver necessary</li>
</ul>
<p ><b>Supported USB Device Classes:</b></p><ul>
<li>Audio</li>
<li>Legacy Audio V1 device class</li>
<li>Bulk communication</li>
<li>Smart Card Device Class (CCID)</li>
<li>Communication Device Class (CDC)</li>
<li>Human Interface Device Class (HID)</li>
<li>Mass Storage Device Class (MSD)</li>
<li>Media Transfer Protocol Class (MTP)</li>
<li>Printer Class</li>
<li>Virtual Mass Storage Component (VirtualMSD)</li>
<li>Vendor Specific Class (VSC)</li>
</ul>
<p ><b>Device families supported by the Middleware:</b></p><ul>
<li>PSE84</li>
</ul>
<h1><a class="anchor" id="section_emusb_device_general"></a>
General Description</h1>
<p >This manual provides only the basic concepts of emUSB-Device and integration specifics of the emUSB-Device into ModusToolbox flow. For a detail description of the emUSB-Device features, implementation, and APIs, refer to: <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a>.</p>
<p ><a class="el" href="index.html#section_emusb_device_quick_start">Quick Start</a> is available in this API Reference Guide.</p>
<p ><b>emUSB-Device consists of the following layers:</b></p><ul>
<li>The driver for hardware access</li>
<li>The emUSB-Device core</li>
<li>The USB class driver or the bulk communication component</li>
</ul>
<p >emUSB-Device core and the USB class drivers are device-independent, while the driver for hardware access is applicable only for one device family. The driver is selected in the USBD_X_Config() function, the template of implementation of USBD_X_Config() is in the export/Config folder.</p>
<p >The drivers for emUSB-Device can support not all available features and may need to be configured in a special manners, refer to the: <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Device driver specifics chapter.</p>
<p ><b>Supported Drivers by the Device family</b></p>
<table class="doxtable">
<tr>
<th>Device family</th><th>Drivers</th><th>Pointer to the driver API structure </th></tr>
<tr>
<td>PSE84 </td><td>PSOCE84 Driver </td><td><ul>
<li>USB_Driver_Infineon_PSOCE84</li>
<li>USB_Driver_Infineon_PSOCE84_DMA   </li>
</ul>
</td></tr>
</table>
<p >For the PSE84 device, the DMA engine of the USB IP block does not have access to all SRAM regions. For details, see the PSE84 Reference Manual. As a result, the memory pool for the PSE84 driver must be located only to the SRAM region with DMA access. An example of the allocation memory pool is in the usbd_config.c file.</p>
<dl class="section note"><dt>Note</dt><dd>For the USBD_AddDriver() function description, refer to the: <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a>.</dd></dl>
<p>The emUSB-Device is provided in the form of pre-build libraries. The pre-build library is selected automatically based on configuration of Application project.</p>
<p >The emUSB-device has been already implemented the Target OS Interface for both RTOS and non-RTOS aware environments. The Target OS Interface for RTOS environment is implemented by abstraction-rtos, so this Middleware can be used with any RTOSes supported by abstraction-rtos.</p>
<p >The hardware dependency files are present in export/Config directory, which consist of:</p><ul>
<li>One common file responsible for the debug message output</li>
<li>Device-specific files for the hardware configuration of each supported device family</li>
</ul>
<p >Also, the emUSB-Host/Device personality is present in the Device-configurator for simplify routine of configuration clocks and pins for USB IP block operation. The personality is part mtb-dsl-pse8xxgp for PSE84 devices.</p>
<h1><a class="anchor" id="section_emusb_device_quick_start"></a>
Quick Start</h1>
<p >To set up emUSB-Device for mouse and keyboard Human Interface Devices (HID), follow the below-described steps. These code snippets will move the mouse cursor left and right and print the "Hello world" message into the opened text editor. The current snippet is based on SEGGER sample application.</p>
<dl class="section note"><dt>Note</dt><dd>You can kickstart your project by using Code Examples from Project Creator app. Those contain already configured clocks and pins, you can take it as a basis for easy start.</dd></dl>
<h2><a class="anchor" id="subsection_qsg_step1"></a>
STEP 1: Add the emUSB-Device middleware.</h2>
<ol type="1">
<li><p class="startli">Launch the ModusToolbox Library Manager, click Add Library button and select the emUSB-Device. This step is required only if the ModusToolbox IDE is used. Otherwise, ensure that the emUSB-Device middleware is included in your project. </p><div class="image">
<img src="emusb_device_lib_mngr.png" alt=""/>
</div>
<dl class="section note"><dt>Note</dt><dd>To use the terminal output, add <a href="https://infineon.github.io/retarget-io/html/index.html"><b>retarget-io middleware </b></a> from the Library Manager. </dd>
<dd>
Add the FreeRTOS middleware into the Library Manager if you want to use the FreeRTOS.</dd></dl>
</li>
<li>Open Makefile of the project. Add USBD_BASE to the COMPONENTS section of the Makefile. <div class="image">
<img src="emusb_device_makefile.png" alt=""/>
</div>
 <dl class="section note"><dt>Note</dt><dd>Add FREERTOS and RTOS_AWARE to the COMPONENTS section of the Makefile if you want to use FreeRTOS. <div class="image">
<img src="emusb_device_makefile_freertos.png" alt=""/>
</div>
</dd></dl>
</li>
</ol>
<h2><a class="anchor" id="subsection_qsg_step2"></a>
STEP 2: Configure pins and clocks for emUSB-Device.</h2>
<p ><b>PSE84 Devices:</b></p>
<ol type="1">
<li>Launch the ModusToolbox Device Configurator and switch to the Peripherals tab (#1.1).</li>
<li>Enable the USB personality under Communication (#1.2) and select the emUSB-Host/Device personality (#1.3).</li>
<li>Select Device mode (#1.4) and connect available clocks (#1.5).</li>
<li>(Applicable only for non-RTOS environment) To enable the 1ms timer, check "Enable 1ms Timer" for auto setup the timer from personality <div class="image">
<img src="pse84_emusb_device_peripherals_cfg.png" alt=""/>
</div>
 After the enabling the timer need to choose the clock divider for the auto-selected TCPWM resource. <div class="image">
<img src="pse84_emusb_device_peripherals_cfg_2.png" alt=""/>
</div>
</li>
<li><p class="startli">Switch to the System tab (#2.1).</p>
<dl class="section note"><dt>Note</dt><dd>The clocking system can be different between devices.</dd></dl>
</li>
<li>Enable PLL500M0 (#2.2), Set Desired Frequency to 400 MHz (#2.3),</li>
<li>Select CLK_PATH2 as Source Clock for CLK_HF1 (#2.4). Ensure that CLK_HF1 has 400 MHz frequency (#2.5).</li>
<li>Enable PLL250M1 (#2.6), set Desired Frequency to 200 MHz (#2.7) as a clock source. Use a clock with accuracy 0.05 % or better (#2.8).</li>
<li>Select CLK_PATH0 or CLK_PATH1 as Source Clock for CLK_HF8 (#2.9). Ensure that CLK_HF8 frequency is 50 MHz with accuracy 0.05 % or better (#2.10). <div class="image">
<img src="pse84_emusb_device_system_cfg.png" alt=""/>
</div>
</li>
<li>If the Power personality is enabled, the System Idle Power Mode must be Active or CPU sleep and HP profile is selected for System Active Power Profile. <div class="image">
<img src="pse84_emusb_device_power_cfg.png" alt=""/>
</div>
</li>
<li>Under Clocks tab in the Peri1 Memory MappedIO (#3.1).</li>
<li>Ensure APP_MMIO3 Divider is enabled and set to 4 in the Divider field (#3.2). <div class="image">
<img src="pse84_emusb_device_peri_group_cfg.png" alt=""/>
</div>
</li>
<li>Select File-&gt;Save to generate initialization code.</li>
</ol>
<h2><a class="anchor" id="subsection_qsg_step3"></a>
STEP 3: Write the code in main.c.</h2>
<ol type="1">
<li>Include headers to get access to the emUSB-Device functions and retarget-io. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ctype.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cybsp.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cy_retarget_io.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;mtb_hal.h&quot;</span></div>
<div class="line"><span class="comment">/* Include emUSB-Device headers */</span></div>
<div class="line"><span class="preprocessor">#include &quot;USB.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;USB_HID.h&quot;</span></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Include the following headers if you want to use FreeRTOS: <div class="fragment"><div class="line"><span class="comment">/* Include FreeRTOS headers */</span></div>
<div class="line"><span class="preprocessor">#include &quot;FreeRTOS.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;task.h&quot;</span></div>
</div><!-- fragment --></dd></dl>
</li>
<li>Add a structure prototype with the information about emUSB-Device. <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> USB_DEVICE_INFO device_info = {</div>
<div class="line">    0x8765,                       <span class="comment">/* VendorId */</span></div>
<div class="line">    0x1116,                       <span class="comment">/* ProductId. Should be unique for this sample */</span></div>
<div class="line">    <span class="stringliteral">&quot;Vendor&quot;</span>,                     <span class="comment">/* VendorName */</span></div>
<div class="line">    <span class="stringliteral">&quot;HID mouse/keyboard sample&quot;</span>,  <span class="comment">/* ProductName */</span></div>
<div class="line">    <span class="stringliteral">&quot;12345678&quot;</span>                    <span class="comment">/* SerialNumber */</span></div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>Create a structure prototype for the keyboard data. <div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    uint16_t key_code;</div>
<div class="line">    <span class="keywordtype">char</span>     key_char;</div>
<div class="line">} code_to_desc_t;</div>
</div><!-- fragment --></li>
<li>Initialize the table of the keyboard keys code and the keys descriptions. <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span>  code_to_desc_t key_code_to_string_table[] = {</div>
<div class="line">    { 0x04, <span class="charliteral">&#39;a&#39;</span>},</div>
<div class="line">    { 0x05, <span class="charliteral">&#39;b&#39;</span>},</div>
<div class="line">    { 0x06, <span class="charliteral">&#39;c&#39;</span>},</div>
<div class="line">    { 0x07, <span class="charliteral">&#39;d&#39;</span>},</div>
<div class="line">    { 0x08, <span class="charliteral">&#39;e&#39;</span>},</div>
<div class="line">    { 0x09, <span class="charliteral">&#39;f&#39;</span>},</div>
<div class="line">    { 0x0A, <span class="charliteral">&#39;g&#39;</span>},</div>
<div class="line">    { 0x0B, <span class="charliteral">&#39;h&#39;</span>},</div>
<div class="line">    { 0x0C, <span class="charliteral">&#39;i&#39;</span>},</div>
<div class="line">    { 0x0D, <span class="charliteral">&#39;j&#39;</span>},</div>
<div class="line">    { 0x0E, <span class="charliteral">&#39;k&#39;</span>},</div>
<div class="line">    { 0x0F, <span class="charliteral">&#39;l&#39;</span>},</div>
<div class="line">    { 0x10, <span class="charliteral">&#39;m&#39;</span>},</div>
<div class="line">    { 0x11, <span class="charliteral">&#39;n&#39;</span>},</div>
<div class="line">    { 0x12, <span class="charliteral">&#39;o&#39;</span>},</div>
<div class="line">    { 0x13, <span class="charliteral">&#39;p&#39;</span>},</div>
<div class="line">    { 0x14, <span class="charliteral">&#39;q&#39;</span>},</div>
<div class="line">    { 0x15, <span class="charliteral">&#39;r&#39;</span>},</div>
<div class="line">    { 0x16, <span class="charliteral">&#39;s&#39;</span>},</div>
<div class="line">    { 0x17, <span class="charliteral">&#39;t&#39;</span>},</div>
<div class="line">    { 0x18, <span class="charliteral">&#39;u&#39;</span>},</div>
<div class="line">    { 0x19, <span class="charliteral">&#39;v&#39;</span>},</div>
<div class="line">    { 0x1A, <span class="charliteral">&#39;w&#39;</span>},</div>
<div class="line">    { 0x1B, <span class="charliteral">&#39;x&#39;</span>},</div>
<div class="line">    { 0x1C, <span class="charliteral">&#39;y&#39;</span>},</div>
<div class="line">    { 0x1D, <span class="charliteral">&#39;z&#39;</span>},</div>
<div class="line">    { 0x1E, <span class="charliteral">&#39;1&#39;</span>},</div>
<div class="line">    { 0x1F, <span class="charliteral">&#39;2&#39;</span>},</div>
<div class="line">    { 0x20, <span class="charliteral">&#39;3&#39;</span>},</div>
<div class="line">    { 0x21, <span class="charliteral">&#39;4&#39;</span>},</div>
<div class="line">    { 0x22, <span class="charliteral">&#39;5&#39;</span>},</div>
<div class="line">    { 0x23, <span class="charliteral">&#39;6&#39;</span>},</div>
<div class="line">    { 0x24, <span class="charliteral">&#39;7&#39;</span>},</div>
<div class="line">    { 0x25, <span class="charliteral">&#39;8&#39;</span>},</div>
<div class="line">    { 0x26, <span class="charliteral">&#39;9&#39;</span>},</div>
<div class="line">    { 0x27, <span class="charliteral">&#39;0&#39;</span>},</div>
<div class="line">    { 0x2C, <span class="charliteral">&#39; &#39;</span>},</div>
<div class="line">    { 0x37, <span class="charliteral">&#39;.&#39;</span>}</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>Add the keyboard and mouse HID reports. These reports are generated according to HID spec and HID Usage Tables specification. <div class="fragment"><div class="line"><span class="keyword">const</span> uint8_t hid_report_keyboard[] =</div>
<div class="line">{</div>
<div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div>
<div class="line">    USB_HID_USAGE_PAGE_GENERIC_DESKTOP,</div>
<div class="line">    USB_HID_LOCAL_USAGE + 1,</div>
<div class="line">    USB_HID_USAGE_KEYBOARD,</div>
<div class="line">    USB_HID_MAIN_COLLECTION + 1,</div>
<div class="line">    USB_HID_COLLECTION_APPLICATION,</div>
<div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div>
<div class="line">    7,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MINIMUM + 1,</div>
<div class="line">    224,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MAXIMUM + 1,</div>
<div class="line">    231,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div>
<div class="line">    0,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    8,</div>
<div class="line">    USB_HID_MAIN_INPUT + 1,</div>
<div class="line">    USB_HID_VARIABLE,</div>
<div class="line">    USB_HID_MAIN_INPUT + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MINIMUM + 1,</div>
<div class="line">    0,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MAXIMUM + 1,</div>
<div class="line">    101,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div>
<div class="line">    0,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div>
<div class="line">    101,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div>
<div class="line">    8,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    6,</div>
<div class="line">    USB_HID_MAIN_INPUT + 1,</div>
<div class="line">    0,</div>
<div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div>
<div class="line">    USB_HID_USAGE_PAGE_LEDS,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MINIMUM + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MAXIMUM + 1,</div>
<div class="line">    5,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div>
<div class="line">    0,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    5,</div>
<div class="line">    USB_HID_MAIN_OUTPUT + 1,</div>
<div class="line">    2,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    3,</div>
<div class="line">    USB_HID_MAIN_OUTPUT + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_MAIN_ENDCOLLECTION</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">const</span> uint8_t hid_report_mouse[] =</div>
<div class="line">{</div>
<div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div>
<div class="line">    USB_HID_USAGE_PAGE_GENERIC_DESKTOP,</div>
<div class="line">    USB_HID_LOCAL_USAGE + 1,</div>
<div class="line">    USB_HID_USAGE_MOUSE,</div>
<div class="line">    USB_HID_MAIN_COLLECTION + 1,</div>
<div class="line">    USB_HID_COLLECTION_APPLICATION,</div>
<div class="line">    USB_HID_LOCAL_USAGE + 1,</div>
<div class="line">    USB_HID_USAGE_POINTER,</div>
<div class="line">    USB_HID_MAIN_COLLECTION + 1,</div>
<div class="line">    USB_HID_COLLECTION_PHYSICAL,</div>
<div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div>
<div class="line">    USB_HID_USAGE_PAGE_BUTTON,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MINIMUM + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MAXIMUM + 1,</div>
<div class="line">    3,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div>
<div class="line">    0,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    3,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_MAIN_INPUT + 1,</div>
<div class="line">    USB_HID_VARIABLE, <span class="comment">/* 3 button bits */</span></div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div>
<div class="line">    5,</div>
<div class="line">    USB_HID_MAIN_INPUT + 1,</div>
<div class="line">    USB_HID_CONSTANT, <span class="comment">/* 5 bit padding */</span></div>
<div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div>
<div class="line">    USB_HID_USAGE_PAGE_GENERIC_DESKTOP,</div>
<div class="line">    USB_HID_LOCAL_USAGE + 1,</div>
<div class="line">    USB_HID_USAGE_X,</div>
<div class="line">    USB_HID_LOCAL_USAGE + 1,</div>
<div class="line">    USB_HID_USAGE_Y,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div>
<div class="line">    (<span class="keywordtype">unsigned</span> char)-127,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div>
<div class="line">    127,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div>
<div class="line">    8,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    2,</div>
<div class="line">    USB_HID_MAIN_INPUT + 1,</div>
<div class="line">    USB_HID_VARIABLE | USB_HID_RELATIVE,</div>
<div class="line">    USB_HID_MAIN_ENDCOLLECTION,</div>
<div class="line">    USB_HID_MAIN_ENDCOLLECTION</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>Add the functions for adding the keyboard and the mouse to the USB stack. <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div>
<div class="line"><span class="comment">* Function Name: add_keyboard</span></div>
<div class="line"><span class="comment">********************************************************************************</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* Adds the HID keyboard device to the USB stack.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* \return Keyboard handler</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*******************************************************************************/</span></div>
<div class="line"><span class="keyword">static</span> USB_HID_HANDLE add_keyboard(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    USB_HID_INIT_DATA init_data;</div>
<div class="line">    USB_ADD_EP_INFO   ep_int_in;</div>
<div class="line">    USB_HID_HANDLE    keyboard_handler;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets the init_data elements with 0 */</span></div>
<div class="line">    memset(&amp;init_data, 0, <span class="keyword">sizeof</span>(init_data));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets the flags of the not-used state */</span></div>
<div class="line">    ep_int_in.Flags = 0;</div>
<div class="line">    <span class="comment">/* Sets the IN-direction (Device to Host) */</span></div>
<div class="line">    ep_int_in.InDir = USB_DIR_IN;</div>
<div class="line">    <span class="comment">/* Sets the interval of 8 ms (125 us * 64) */</span></div>
<div class="line">    ep_int_in.Interval = 64;</div>
<div class="line">    <span class="comment">/* Sets the maximum packet size (64 for Interrupt) */</span></div>
<div class="line">    ep_int_in.MaxPacketSize = USB_HS_INT_MAX_PACKET_SIZE;</div>
<div class="line">    <span class="comment">/* Sets the endpoint type as Interrupt */</span></div>
<div class="line">    ep_int_in.TransferType = USB_TRANSFER_TYPE_INT;</div>
<div class="line">    <span class="comment">/* Initializes the endpoint handle data */</span></div>
<div class="line">    init_data.EPIn = USBD_AddEPEx(&amp;ep_int_in, NULL, 0);</div>
<div class="line">    <span class="comment">/* Gets the pointer to a report mouse descriptor */</span></div>
<div class="line">    init_data.pReport = hid_report_keyboard;</div>
<div class="line">    <span class="comment">/* Initializes the size of the HID report descriptor */</span></div>
<div class="line">    init_data.NumBytesReport = <span class="keyword">sizeof</span>(hid_report_keyboard);</div>
<div class="line">    <span class="comment">/* Adds an HID keyboard device to the USB interface */</span></div>
<div class="line">    keyboard_handler = USBD_HID_Add(&amp;init_data);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> keyboard_handler;</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div>
<div class="line"><span class="comment">* Function Name: add_mouse</span></div>
<div class="line"><span class="comment">********************************************************************************</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* Adds the HID mouse device to the USB stack.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* \return Mouse handler</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*******************************************************************************/</span></div>
<div class="line"><span class="keyword">static</span> USB_HID_HANDLE add_mouse(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    USB_HID_INIT_DATA init_data;</div>
<div class="line">    USB_ADD_EP_INFO   ep_int_in;</div>
<div class="line">    USB_HID_HANDLE    mouse_handler;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets the init_data elements to 0 value */</span></div>
<div class="line">    memset(&amp;init_data, 0, <span class="keyword">sizeof</span>(init_data));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets the flags of the not-used state */</span></div>
<div class="line">    ep_int_in.Flags = 0;</div>
<div class="line">    <span class="comment">/* Sets the IN-direction (Device to Host) */</span></div>
<div class="line">    ep_int_in.InDir = USB_DIR_IN;</div>
<div class="line">    <span class="comment">/* Sets the interval of 8 ms (125 us * 64) */</span></div>
<div class="line">    ep_int_in.Interval = 64;</div>
<div class="line">    <span class="comment">/* Sets the maximum packet size (64 for Interrupt) */</span></div>
<div class="line">    ep_int_in.MaxPacketSize = USB_HS_INT_MAX_PACKET_SIZE;</div>
<div class="line">    <span class="comment">/* Sets the endpoint type as Interrupt */</span></div>
<div class="line">    ep_int_in.TransferType = USB_TRANSFER_TYPE_INT;</div>
<div class="line">    <span class="comment">/* Initializes the endpoint handle data */</span></div>
<div class="line">    init_data.EPIn = USBD_AddEPEx(&amp;ep_int_in, NULL, 0);</div>
<div class="line">    <span class="comment">/* Gets the pointer to a report mouse descriptor */</span></div>
<div class="line">    init_data.pReport = hid_report_mouse;</div>
<div class="line">    <span class="comment">/* Initializes the size of the HID report descriptor */</span></div>
<div class="line">    init_data.NumBytesReport = <span class="keyword">sizeof</span>(hid_report_mouse);</div>
<div class="line">    <span class="comment">/* Adds an HID mouse device to the USB interface */</span></div>
<div class="line">    mouse_handler = USBD_HID_Add(&amp;init_data);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> mouse_handler;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Add the function for writing the keyboard data to the host. <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div>
<div class="line"><span class="comment">* Function Name: keyboard_send_text</span></div>
<div class="line"><span class="comment">********************************************************************************</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* Writes the keyboard data to the host.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* \param keyboard_handler  The HID keyboard device handler.</span></div>
<div class="line"><span class="comment">* \param keyboard_text  The text data to send to the host.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*******************************************************************************/</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> keyboard_send_text(USB_HID_HANDLE keyboard_handler, <span class="keyword">const</span> <span class="keywordtype">char</span>* keyboard_text)</div>
<div class="line">{</div>
<div class="line">    uint8_t  char_arr[8];</div>
<div class="line">    <span class="keywordtype">char</span>     char_temp;</div>
<div class="line">    uint32_t i;</div>
<div class="line">    uint32_t j;</div>
<div class="line">    uint32_t key_code_to_string_table_size;</div>
<div class="line"> </div>
<div class="line">    key_code_to_string_table_size = ((<span class="keyword">sizeof</span>(key_code_to_string_table)) / (<span class="keyword">sizeof</span>(key_code_to_string_table[0])));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets all char_arr elements with 0 */</span></div>
<div class="line">    memset(char_arr, 0, <span class="keyword">sizeof</span>(char_arr));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; keyboard_text[i] != 0; i++)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* A character is uppercase if its hex value is less than 0x61 (&#39;a&#39;)</span></div>
<div class="line"><span class="comment">         * and greater or equal to 0x41 (&#39;A&#39;), therefore we set the LeftShiftUp</span></div>
<div class="line"><span class="comment">         * bit for those characters</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        <span class="keywordflow">if</span> (keyboard_text[i] &lt; 0x61 &amp;&amp; keyboard_text[i] &gt;= 0x41)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* Disables LeftShiftUp */</span></div>
<div class="line">            char_arr[0] = (1 &lt;&lt; 1);</div>
<div class="line">            <span class="comment">/* Converts the character to lowercase */</span></div>
<div class="line">            char_temp = tolower((<span class="keywordtype">int</span>)keyboard_text[i]);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            char_temp = keyboard_text[i];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; key_code_to_string_table_size; j++)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (key_code_to_string_table[j].key_char == char_temp)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">/* Gets the character code */</span></div>
<div class="line">                char_arr[2] = key_code_to_string_table[j].key_code;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Writes data to the host */</span></div>
<div class="line">        USBD_HID_Write(keyboard_handler, <span class="comment">/* The HID instance */</span></div>
<div class="line">            &amp;char_arr[0],                <span class="comment">/* The pointer to the data array to send */</span></div>
<div class="line">            8u,                          <span class="comment">/* The number of bytes to send */</span></div>
<div class="line">            0);                          <span class="comment">/* The Timeout in milliseconds */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Sets all char_arr elements with 0 */</span></div>
<div class="line">        memset(char_arr, 0, <span class="keyword">sizeof</span>(char_arr));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Send a 0 field packet to tell the host that the key has been released */</span></div>
<div class="line">        USBD_HID_Write(keyboard_handler, <span class="comment">/* The HID instance */</span></div>
<div class="line">            &amp;char_arr[0],                <span class="comment">/* The pointer to the data array to send */</span></div>
<div class="line">            8u,                          <span class="comment">/* The number of bytes to send */</span></div>
<div class="line">            0);                          <span class="comment">/* The Timeout in milliseconds */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* The delay is 50 milliseconds */</span></div>
<div class="line">        USB_OS_Delay(50);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Add the function for writing the mouse movements data to the host. <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div>
<div class="line"><span class="comment">* Function Name: mouse_moves</span></div>
<div class="line"><span class="comment">********************************************************************************</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* Writes the mouse movements data to the host.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* \param mouse_handler  The HID mouse device handler.</span></div>
<div class="line"><span class="comment">* \param mouse_move gets data about the mouse movement.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*******************************************************************************/</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> mouse_moves(USB_HID_HANDLE mouse_handler, int8_t mouse_move)</div>
<div class="line">{</div>
<div class="line">    uint8_t move_arr[3];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets all move_arr elements with 0 */</span></div>
<div class="line">    memset(move_arr, 0, <span class="keyword">sizeof</span>(move_arr));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Gets the mouse movement value */</span></div>
<div class="line">    move_arr[1] = (uint8_t)mouse_move;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Writes data to the host */</span></div>
<div class="line">    USBD_HID_Write(mouse_handler, <span class="comment">/* The HID instance */</span></div>
<div class="line">        &amp;move_arr[0],             <span class="comment">/* The pointer to the data array to send */</span></div>
<div class="line">        3u,                       <span class="comment">/* The number of bytes to send */</span></div>
<div class="line">        0);                       <span class="comment">/* The Timeout in milliseconds */</span></div>
<div class="line"> </div>
<div class="line">    USB_OS_Delay(1000);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli">Initialize retarget-io to use the debug UART port:</p>
<p class="startli"><b> For PSE84 devices:</b> Open Device Configurator, select Peripherals, select the desired SCB resource (#1.1), select the UART in the window of choosing the personality (#1.2), click OK (#1.3). </p><div class="image">
<img src="pse84_emusb_device_uart_1.png" alt=""/>
</div>
<p> Select the desired name for the SCB (#2.1) and the pins and clock for the SCB (#2.2). The other UART options can be set by default, see the screenshot below. </p><div class="image">
<img src="pse84_emusb_device_uart_2.png" alt=""/>
</div>
<p> The desired name for the SCB resource is important because the generated structures, defines and variables have the prefix of that name. See below.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> retarget_io_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    cy_rslt_t result;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> cy_stc_scb_uart_context_t  CYBSP_DEBUG_UART_context;                </div>
<div class="line">    <span class="keyword">static</span> mtb_hal_uart_t             CYBSP_DEBUG_UART_hal_obj;                </div>
<div class="line">    result = (cy_rslt_t)Cy_SCB_UART_Init(CYBSP_DEBUG_UART_HW, &amp;CYBSP_DEBUG_UART_config, &amp;CYBSP_DEBUG_UART_context);</div>
<div class="line">    <span class="keywordflow">if</span> (result != CY_RSLT_SUCCESS)</div>
<div class="line">    {</div>
<div class="line">        CY_ASSERT(0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Cy_SCB_UART_Enable(CYBSP_DEBUG_UART_HW);</div>
<div class="line"> </div>
<div class="line">    result = mtb_hal_uart_setup(&amp;CYBSP_DEBUG_UART_hal_obj, &amp;CYBSP_DEBUG_UART_hal_config, &amp;CYBSP_DEBUG_UART_context, NULL);</div>
<div class="line">    <span class="keywordflow">if</span> (result != CY_RSLT_SUCCESS)</div>
<div class="line">    {</div>
<div class="line">        CY_ASSERT(0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    result = cy_retarget_io_init(&amp;CYBSP_DEBUG_UART_hal_obj);</div>
<div class="line">    <span class="keywordflow">if</span> (result != CY_RSLT_SUCCESS)</div>
<div class="line">    {</div>
<div class="line">        CY_ASSERT(0);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Create the main_task() function <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div>
<div class="line"><span class="comment">* Function Name: main_task</span></div>
<div class="line"><span class="comment">********************************************************************************</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* Initializes the emUSB-Device stack.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* \param arg  is not used in this function but required for using FreeRTOS.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*******************************************************************************/</span></div>
<div class="line"><span class="keywordtype">void</span> main_task(<span class="keywordtype">void</span>* arg)</div>
<div class="line">{</div>
<div class="line">    (void)arg;</div>
<div class="line"> </div>
<div class="line">    retarget_io_init();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Mouse movement values */</span></div>
<div class="line">    int8_t mouse_move_left = -75;</div>
<div class="line">    int8_t mouse_move_right = 75;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* The output text from the keyboard */</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* keyboard_text = <span class="stringliteral">&quot;Hello world! &quot;</span>;</div>
<div class="line"> </div>
<div class="line">    USB_HID_HANDLE mouse_handler;</div>
<div class="line">    USB_HID_HANDLE keyboard_handler;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Initialization of emUSB-Device */</span></div>
<div class="line">    USBD_Init();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Adds the HID keyboard device to the USB stack */</span></div>
<div class="line">    keyboard_handler = add_keyboard();</div>
<div class="line">    <span class="comment">/* Adds the HID mouse device to the USB stack */</span></div>
<div class="line">    mouse_handler = add_mouse();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets information used during the device enumeration */</span></div>
<div class="line">    USBD_SetDeviceInfo(&amp;device_info);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Starts emUSB-Device */</span></div>
<div class="line">    USBD_Start();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Waits for configuration */</span></div>
<div class="line">        <span class="keywordflow">while</span> ((USBD_GetState() &amp; (USB_STAT_CONFIGURED | USB_STAT_SUSPENDED)) != USB_STAT_CONFIGURED)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* Do something to indicate waiting for configuration */</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Moves the mouse cursor left and right */</span></div>
<div class="line">        mouse_moves(mouse_handler, mouse_move_left);</div>
<div class="line">        mouse_moves(mouse_handler, mouse_move_right);</div>
<div class="line">        <span class="comment">/* Prints the text */</span></div>
<div class="line">        keyboard_send_text(keyboard_handler, keyboard_text);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli">Call main_task():</p>
<p class="startli"><b> For non-RTOS environments:</b></p>
<p class="startli">Call the main_task() into the main() function. </p><div class="fragment"><div class="line">    main_task(NULL);</div>
</div><!-- fragment --><p class="startli"><b> For RTOS environments:</b></p>
<p class="startli">Create a FreeRTOS task with main_task() using xTaskCreate and start the task scheduler instead of calling main_task(): </p><div class="fragment"><div class="line">    <span class="comment">/* Creates a FreeRTOS task of the main_task() function */</span></div>
<div class="line">    xTaskCreate(main_task, <span class="stringliteral">&quot;main_task&quot;</span>, 500U, NULL, configMAX_PRIORITIES - 6, NULL);</div>
<div class="line">    vTaskStartScheduler();</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Typically, the default interrupt priority-configuration from the usbd_config.c file will work with the default FreeRTOS config file. For a malfunction USB project, ensure that the USB interrupt priority is aligned with MAX_API_CALL_INTERRUPT_PRIORITY. See <a class="el" href="index.html#section_emusb_device_use_in_rtos">Using emUSB-Device in an RTOS Environment</a>.</dd></dl>
</li>
</ol>
<h2><a class="anchor" id="subsection_qsg_step5"></a>
STEP 4: Check the emUSB-Device workability.</h2>
<ol type="1">
<li>Build and program your project.</li>
<li>Connect the USB-Device connector to the PC host.</li>
<li>Observe the mouse cursor move and print the "Hello world" message into the text editor.</li>
</ol>
<h1><a class="anchor" id="section_emusb_device_config_cons"></a>
Configuration Considerations</h1>
<p >This section explains the details of the emUSB-Device configuration.</p>
<h2><a class="anchor" id="section_emusb_device_hw_dep_conf"></a>
Hardware-dependent Configuration</h2>
<p >The hardware resources (Pins, clocks, interrupts, timer) required for USB must be configured before the start of USB operation before calling USBD_Init() or in USBD_X_Config(). Interrupts must be configured in the USBD_X_Config() function. Also, USBD_X_EnableInterrupt() and USBD_X_DisableInterrupt() must be implemented when the USBD_OS_USE_USBD_X_INTERRUPT compile time option is enabled.</p>
<p >The implementation template of USBD_X_Config(), USBD_X_EnableInterrupt() and USBD_X_DisableInterrupt() is provided for each device in the Config directory under COMPONENT_*. This template is automatically copied into your project when middleware is added to project. This template does not include the configuration of clock and pins required for USB operation. The configuration of timer is provided. Need to setup provided structures, defines and variables from Device Configurator in USB personality.</p>
<p >For details on Hardware Dependent Configuration, refer to the - <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a>.</p>
<h3><a class="anchor" id="section_emusb_device_hw_dep_conf_pins"></a>
USB Pins Configuration</h3>
<p ><b> PSE84 Devices Family </b></p>
<p >The D+/D- pins are dedicated and do not require configuration.</p>
<h3><a class="anchor" id="section_emusb_device_hw_dep_conf_clock"></a>
USB Clock Configuration</h3>
<p >The USB 2.0 specification defines the required bit rate accuracy for the device in section 7.1.11. Ensure that the clock sources for USB meet the requirements.</p>
<p >The emUSB-Host/Device personality in the Device Configurator allows for easy configuration of the clocks for USB operation and also check if the clocks meet the requirements. Otherwise, the clocks can be configured manually by PDL/HAL Next APIs for PSE84.</p>
<p ><b> PSE84 Devices Family </b></p>
<p >The USB Device requires two clocks for operation:</p><ul>
<li>Phy Pll reference clock configured at 50 MHz with the required bit rate accuracy according to the USB 2.0 specification. Typically, this clock is the CLK_HF8 output signal, but refer to the device datasheet to identify the clock source for USB for a specific device.</li>
<li>The main clock configured at 400 MHz. This clock does not have requirements for the bit rate accuracy. Typically, this clock is the CLK_HF1 output signal, but refer to the device datasheet to identify the clock source for USB for a specific device. In addition, set to 4 the Divider of Peri 1 Group 3 to generate 100 MHz signal after CLK_HF1 for the USB controller.</li>
</ul>
<p >Also, enable the corresponding Peri Group by the Cy_SysClk_PeriGroupSlaveInit() function from the SysClk driver of mtb-dsl-pse8xxgp.</p>
<dl class="section note"><dt>Note</dt><dd>If the USB must operate during Deep Sleep, keep both clocks enabled.</dd></dl>
<h3><a class="anchor" id="section_emusb_device_hw_dep_conf_int"></a>
USB Interrupt Configuration</h3>
<p >The interrupt is mandatory for the emUSB-Device Middleware operation. The interrupt priority selection is a part of Application level - the interrupt priority selected in the template files is not suitable for real project. For USB recommended setting the interrupt priority as high as possible.</p>
<p ><b> PSE84 Devices </b></p>
<p >emUSB-Device use one interrupt source - usbhs_interrupt_usbhsctrl_IRQn. The emUSB-Device can be executed on the CM33 or CM55 core. The interrupt configuration is the same for both cores.</p>
<ul>
<li>The following code snippet shows the interrupt configuration: <div class="fragment"><div class="line"><span class="comment">/* Define interrupt priority */</span></div>
<div class="line"><span class="preprocessor">#define USBD_ISR_PRIO                           (3U)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Register this function as a callback in USBD_SetISREnableFunc(). */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> enable_isr(USB_ISR_HANDLER * pfISRHandler)</div>
<div class="line">{</div>
<div class="line">    cy_stc_sysint_t usb_int_cfg =</div>
<div class="line">    {</div>
<div class="line">        .intrSrc = usbhs_interrupt_usbhsctrl_IRQn,</div>
<div class="line">        .intrPriority = USBD_ISR_PRIO</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    cy_en_sysint_status_t status;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Install the interrupt service routine */</span></div>
<div class="line">    status = Cy_SysInt_Init(&amp;usb_int_cfg, pfISRHandler);</div>
<div class="line">    CY_ASSERT(CY_RSLT_SUCCESS == status);</div>
<div class="line">    (void) status; <span class="comment">/* To avoid the compiler warning in Release mode */</span></div>
<div class="line"> </div>
<div class="line">    NVIC_EnableIRQ(usbhs_interrupt_usbhsctrl_IRQn);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="section_emusb_device_hw_dep_add_conf_pse84_timer"></a>
USB Timer Configuration</h3>
<p ><b> PSE84 Devices Family </b></p>
<p >This configuration is for non-RTOS environment. The timer is already configured in the usbd_config.c file for PSE84. But its initialization takes data from the generated code from the Device Configurator USB personality. Enable the "Enable 1ms Times" checkbox, and select the TCPWM set of the clock divider. The prefix name of the structures, defines, and variables set by default for TCPWM is "emUSB_OS_Timer". The prefix can be changed but note that it impacts the generated code used in the export/Config/COMPONENT_PSE84/usbd_config.c file. For details on setting up the timer in the personality, see <a class="el" href="index.html#section_emusb_device_quick_start">Quick Start</a> for PSE84 devices.</p>
<h2><a class="anchor" id="section_emusb_device_debug_mes_out"></a>
Debug Message Output</h2>
<p >The debug builds of emUSB-Device allow using the debug message outputs. The template implementation of the message output functions is in export/Config/usbd_config_io.c file. This file is automatically copied into the ModusToolbox project when emUSB-Device middleware is added for the first time by the Library manager. Otherwise, copy this file manually. By default, <a href="https://github.com/Infineon/retarget-io"><b>retarget-io</b></a> is used for the message output, but message outputs can be redefined to any suitable output way. To disable the default message outputs, set USBD_DISABLE_STANDARD_OUTPUT=1 in the DEFINES variable in the application project Makefile. To provide a custom output method in addition to setting a variable add corresponding API under the #if (USBD_DISABLE_STANDARD_OUTPUT == 1U) condition inside the _puts() function.</p>
<p >For details on Hardware Debug Message Output, refer to the - <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Debugging chapter.</p>
<dl class="section note"><dt>Note</dt><dd>The retarget-io middleware must be configured outside of the emUSB-Device middleware for the message output. Refer to the <a href="https://github.com/Infineon/retarget-io#quick-start"><b>retarget-io Quick Start</b></a>.</dd>
<dd>
The retarget-io does not send the debug message from the interrupt in RTOS aware environments. These messages are ignored. But some of them can be critical for debugging. For this case recommended to use other message output method to print all messages.</dd></dl>
<h2><a class="anchor" id="section_emusb_device_low_power"></a>
Low Power Support</h2>
<p >The USB Host can initiate Suspend condition on the USB bus to reduce power consumption of the connected device. emUSB-Device can identify Suspend condition in a few ways. For example: calling USBD_GetState() through a specific time interval (typically 1 ms), by the callback function registered in USBD_RegisterSCHook() or by the other ways supported in the emUSB-Device stack. When Suspend condition is identified, the suspended device must limits the current consumption from VBUS to 0.5 mA. Therefore, put the device into Low-power mode to consume less current. emUSB-Device does not change the microcontroller Power mode by itself. It is the application responsibility to reduce power consumption to meet the requirements. Also, it is the application responsibility to prepare emUSB-Device for low-power mode and detect Resume condition. The preparation of the emUSB-Device middleware for low-power mode and detection of Resume condition differ among devices. Pay attention for the following explanation for the required devices.</p>
<p >Refer to the - <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Low power mode chapter for additional information about the behavior of emUSB-Device in low-power mode.</p>
<p >Typically, the microcontroller enters Deep Sleep or similar mode to achieve the required current consumption, but other approaches are also possible if they exist. The next table shows the recommended low-power modes for Suspend state for each supported device:</p>
<table class="doxtable">
<tr>
<th>Device family</th><th>Recommended low-power mode </th></tr>
<tr>
<td>PSE84 </td><td>Sleep  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>After a wake-up from low-power modes in which USB IP block cannot operate, the emUSB-Device must be re-initialized.</dd></dl>
<p><b> PSE84 Devices </b></p>
<p >The USB IP block can operate only in Active and Sleep mode.</p>
<h3><a class="anchor" id="section_emusb_device_low_power_rtos"></a>
emUSB-Device in RTOS environment</h3>
<p >Typically, RTOS decide to go to Idle state when no active tasks remain active. Often, the transition into Idle condition is accompanied by entering the microcontroller in one of low-power modes (Depends on RTOS configuration). But the USB device must provide correct responses to all events on the USB bus. The preventing mechanism must be implemented, which does not allow the microcontroller to enter low-power mode when emUSB-Device is not in Suspended state. For example, for FreeRTOS, a custom implementation of vApplicationSleep() must be provided.</p>
<h3><a class="anchor" id="section_emusb_device_low_power_lpm"></a>
Link Power Management (LPM)</h3>
<p >emUSB-Device supports the Link Power Management feature like the configuration BESL (Best Effort Service Latency) value and reports on LPM transition on USB lines (L0 &lt;--&gt; L1).</p>
<p >To enable LPM:</p><ol type="1">
<li>Call the USBD_UseV210() function in USBD_X_Config().</li>
<li>(optional) Set the recommended BESL values by USBD_SetBESLValues().</li>
<li>Register the callback, which reports on the LPM state transition by USBD_SetOnLPMChange().</li>
<li>Define the behavior of the device on LPM request from the Host by USBD_SetLPMResponse() (reject or acknowledge the LPM request). Call USBD_SetLPMResponse() after USBD_Start(), otherwise, the response configuration may be lost.</li>
</ol>
<p >Based on the received BESL value, the application can determine the level of the power optimization and select appropriate low-power modes. The behavior of the USB IP block during low-power modes for each device described in <a class="el" href="index.html#section_emusb_device_low_power">Low Power Support</a>.</p>
<p >For more information about LPM, refer to "USB 2.0 Link Power Management
Addendum" and "Errata for USB 2.0 ECN: Link Power Management (LPM) - 7/2007" from usb.org.</p>
<h2><a class="anchor" id="section_emusb_device_only_pdl"></a>
Only PDL APIs support</h2>
<p >By default, emUSB-Device requires HAL Next APIs for operation. However, when HAL Next APIs cannot be used in the application, the USBD_USE_PDL option is available. With this macro set to 1, the emUSB-Device middleware will use PDL APIs instead of HAL Next APIs. When USBD_USE_PDL=1, the application must disable the standard debug output (USBD_DISABLE_STANDARD_OUTPUT=1) and, in a non-RTOS environment, provide the custom implementation for USB_OS_GetTickCnt() function (USBD_NORTOS_TICKCNT_ENABLE=0). The USBD_USE_PDL macro must be set in the DEFINES variable in the application project Makefile.</p>
<h2><a class="anchor" id="section_emusb_device_pick_lib"></a>
Picking an emUSB-Device Library Variant</h2>
<p >The Middleware provides emUSB-Device as pre-build libraries. The pre-build libraries are selected automatically based on configurations of Makefile configurations. The table below shows the availability of the configuration options.</p>
<table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Make Variable </th></tr>
<tr>
<td>Device family </td><td>PSE84 </td><td>DEVICE_COMPONENTS  </td></tr>
<tr>
<td>Build configuration </td><td>Debug, Release </td><td>CONFIG  </td></tr>
<tr>
<td>Core </td><td><ul>
<li>CM33, CM55 for PSE84;  </li>
</ul>
</td><td>CORE  </td></tr>
<tr>
<td>Floating point </td><td>hardfp, softfp </td><td>VFP_SELECT  </td></tr>
<tr>
<td>Toolchain </td><td>GCC_ARM, IAR, ARM, LLVM-ARM </td><td>TOOLCHAIN  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Typically, the device family and core are selected in BSP Makefile.</dd>
<dd>
CM55 LLVM-ARM supports only hardfp.</dd></dl>
<h3><a class="anchor" id="section_emusb_device_lib_conf"></a>
Pre-build libraries configuration</h3>
<p >Some of the parameters/features of emUSB-Device are configured by the compile-time options (like the number of the interface that supports the ISO transfer, etc) during generation of pre-build libraries and cannot change in run-time. Header file USBD_ConfDefaults.h under the USBD directory contains the common compile time options used during pre-build libraries creation. Similarly, USBD_Conf.h under each COMPONENT_&lt;Device family&gt;/CONFIG_&lt; Build configuration&gt; directory contains the compile time options specific to the set of library variants. The compile time options defined in USBD_Conf.h have a higher priority than in USBD_ConfDefaults.h. Most of the compile time options are defined in these two header files but some are not visible like the macro, which define the number of interfaces. This section describes the compile time options not defined in USBD_Conf.h and USBD_ConfDefaults.h.</p>
<p >This table shows the number of supported interfaces for each class between the device families.</p>
<table class="doxtable">
<tr>
<th>USB Class</th><th>PSE84 </th></tr>
<tr>
<td>Audio </td><td>1  </td></tr>
<tr>
<td>Legacy Audio </td><td>1  </td></tr>
<tr>
<td>Bulk </td><td>4  </td></tr>
<tr>
<td>CCID </td><td>1  </td></tr>
<tr>
<td>CDC </td><td>2  </td></tr>
<tr>
<td>HID </td><td>2  </td></tr>
<tr>
<td>MSD </td><td>1  </td></tr>
<tr>
<td>MTP </td><td>1  </td></tr>
<tr>
<td>Printer </td><td>1  </td></tr>
<tr>
<td>VirtualMSD </td><td>1  </td></tr>
<tr>
<td>VSC </td><td>Limited by USB_MAX_NUM_IF  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The MSD and MTP classes support the connection to up-to-four logical/storage units.</dd></dl>
<h2><a class="anchor" id="section_emusb_device_emfile"></a>
Integration with emFile</h2>
<p >The MSD and MTP are supplied with already implemented storage drivers using <a href="https://github.com/Infineon/emfile"><b>emFile</b></a>. The MSD supports: USB_MSD_StorageByName and USB_MSD_StorageByIndex, the MTP supports: USB_MTP_StorageFS drivers. The implementation of these drivers are present in additional pre-build libraries. By default these libraries are not added to the build, to enable them - add USBD_EMFILE to the COMPONENTS variable in Makefile. The additional pre-build libraries with emFile storage drivers support the three different FAT sub types: FAT12, FAT16 and FAT32. The selection of a specific FAT type is the same as for the <a href="https://github.com/Infineon/emfile"><b>emFile</b></a> middleware - add EMFILE_FAT16 for FAT12/16 or EMFILE_FAT32 for supporting all three sub types to the COMPONENTS variable in Makefile.</p>
<h2><a class="anchor" id="section_emusb_device_use_in_rtos"></a>
Using emUSB-Device in an RTOS Environment</h2>
<p >The emUSB-device has been already implemented the Target OS Interface for both RTOS and non-RTOS aware environments. Selecting the OS layer implementation is automatic based on the <em>RTOS_AWARE</em> component. To inform the emUSB-Device that an RTOS environment is being used, set the <em>RTOS_AWARE</em> component (<em>COMPONENTS+=RTOS_AWARE</em>).</p>
<p >For the RTOS environment, the OS layer uses the <a href="https://github.com/Infineon/abstraction-rtos"><b>abstraction-rtos</b></a> library, and as a result, the emUSB-Device can be used with RTOSes supported by the <a href="https://github.com/Infineon/abstraction-rtos"><b>abstraction-rtos</b></a> library.</p>
<p >Specific implementation of Target OS Interface: </p><ul>
<li>
USB_OS_DecRI() and USB_OS_IncDI() have only alternate implementation because the USBD_OS_USE_USBD_X_INTERRUPT compile time option is enabled. Alternate implementation is more effective compared to the standard one because it allows disabling/enabling USB interrupts only before entering/exiting the critical section for emUSB-device.  </li>
<li>
The emUSB-Device middleware calls some functions of the OS layer from the USB interrupt. As a result, the USB interrupt priority must be aligned with the RTOS configuration. For example, for FreeRTOS, the USB interrupt must have a lower or equal priority to the MAX_API_CALL_INTERRUPT_PRIORITY macro.  </li>
<li>
<p class="startli">For non-RTOS environment: For <b>PSE84</b> devices: USB_OS_GetTickCnt() configures one instance of the timer by the driver of HAL Next library for returning the current system time in milliseconds. The timer is started by initializing the emUSB-Device middleware with data from the Universal Serial Bus (USB) personality by checking "Enable 1ms Timer". Universal Serial Bus (USB) personality reserves one of the available TCPWM that has the Timer-Counter setting. For details on the timer usage, see in <a class="el" href="index.html#section_emusb_device_quick_start">Quick Start</a> for PSE84 devices.</p>
<p class="interli">USB_OS_GetTickCnt() own implementation can be provided due to: </p><ul>
<li>
The optimization of handling the ISR routine (the timer generates an interrupt every 1 millisecond);  </li>
<li>
Providing more reliable implementation (the timer value reloads every 49 days, 17 hours, 2 mins, 47.296 seconds);  </li>
<li>
The optimization of the HW resources usage (one instance of the TCPWM counter or similar HW resources, which can be used by <code>Timer (Timer/Counter)</code> Driver);  </li>
</ul>
<p>To do that, set the USBD_NORTOS_TICKCNT_ENABLE macro value to zero in Makefile file.</p>
<dl class="section note"><dt>Note</dt><dd><b>For PSE84 devices:</b> The own implementation of USB_OS_GetTickCnt() must be provided if the application uses the transit into Deep Sleep or Hibernate low-power modes.  </dd></dl>
</li>
<li>
For Free-RTOS, USB tasks priority must be lower than the priority of RTOS daemon tasks (also known as timer service tasks). The RTOS daemon task priority is defined in configTIMER_TASK_PRIORITY.  </li>
</ul>
<p >For details on Target OS Interface, refer to the - <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Target OS Interface chapter.</p>
<h1><a class="anchor" id="section_emusb_device_package_str"></a>
emUSB-Device Package Structure</h1>
<p >The Middleware structure:</p><ul>
<li><b>export/Config:</b> Contains sample configuration files for hardware-specific configuration.</li>
<li><b>OS:</b> Contains the OS layer implementation.</li>
<li><b>USBD:</b> Contains a set of pre-build emUSB-Device libraries for different configurations of user applications (Device family, Build configuration, Core, Floating point, Toolchain), and a set of header files.</li>
<li><b>tool:</b> Contains the tool for code generation (Audio class only).</li>
<li><b>docs:</b> Contains the API Reference Guide, SEGGER-provided emUSB-Device User Guide &amp; Reference Manual and other supporting documentation.</li>
</ul>
<h1><a class="anchor" id="section_emusb_device_changelog"></a>
Changelog</h1>
<p >Note that the emUSB-Device Middleware by Infineon and emUSB-Device stack by Segger have different versions</p>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td rowspan="1">2.1.0 </td><td>Updated the emUSB-Device stack to 3.66.5 </td><td>New version is available  </td></tr>
<tr>
<td rowspan="3">2.0.0 </td><td>Added LLVM compiler support. </td><td rowspan="2">Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td>Migrated to HAL-Next.  </td></tr>
<tr>
<td>Updated the emUSB-Device stack to 3.66.0 </td><td>New version is available  </td></tr>
<tr>
<td rowspan="2">1.5.0 </td><td>For MSD and MTP classes the already implemented storage drivers are added. These drivers are implemented by <a href="https://github.com/Infineon/emfile"><b>emFile</b></a> APIs. For more details, refer to the <a class="el" href="index.html#section_emusb_device_emfile">Integration with emFile</a>.  </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td>Updated the emUSB-Device stack to 3.64.3 </td><td>New version is available  </td></tr>
<tr>
<td rowspan="4">1.4.0 </td><td>Add a new driver for PSoC 6 with DMA support. Now for PSoC 6, the total size of all endpoints is not limited by 512 bytes for DMA driver. </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td>Updated the emUSB-Device stack to 3.64.1 </td><td>New version is available  </td></tr>
<tr>
<td>Add the props.json file </td><td>Improve the integration with the ModusToolbox 3.0+ flow  </td></tr>
<tr>
<td>Update usbd_config.c file for XMC4000 to support OTG. OTG feature is supported in emUSB-Device and emUSB-Host middleware </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td rowspan="6">1.3.0 </td><td>Added support of Smart Card Device Class (CCID) </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td>Added new Audio class with extended features like compatibility to USB Audio version 2 device class, explicit feedback and others. The legacy Audio class is not recommended to use in new applications. </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td>Updated the emUSB-Device stack to 3.62.0 </td><td>New version is available  </td></tr>
<tr>
<td>Added the new compile time option to allow use emUSB-Device without HAL library. For details, refer to the <a class="el" href="index.html#section_emusb_device_only_pdl">Only PDL APIs support</a>.  </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td>The maximum number of alternative interfaces are increased from 2 to 4 for all supported device families (See the USB_MAX_NUM_ALT_IF macro in the USB_Conf.h file). </td><td></td></tr>
<tr>
<td>Minor documentation updates </td><td></td></tr>
<tr>
<td rowspan="4">1.2.0 </td><td>Provided support for XMC4000 devices. </td><td></td></tr>
<tr>
<td>Updated the emUSB-Device stack to 3.60.1 </td><td>New version is available  </td></tr>
<tr>
<td>Added a new section in the documentation <a class="el" href="index.html#section_emusb_device_lib_conf">Pre-build libraries configuration</a>  </td><td></td></tr>
<tr>
<td>Minors improvements in OS layer </td><td></td></tr>
<tr>
<td rowspan="8">1.1.0 </td><td>Updated the emUSB-Device stack to 3.58.0 </td><td>New version is available  </td></tr>
<tr>
<td>Added support of Audio class </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td>The OS layer uses abstraction-rtos APIs instead of FreeRTOS. This means that emUSB-Device can be used with RTOS supported by abstraction-rtos including FreeRTOS  </td><td>Extend the number of supported RTOS  </td></tr>
<tr>
<td>The next compile time options were updated for PSOC6 devices:<ul>
<li>The maximum numbers of DATA Endpoints increased from 7 -&gt; 8 (See the USB_NUM_EPS macro in the USB_Conf.h file), <dl class="section note"><dt>Note</dt><dd>USB_NUM_EPS define number data endpoints + 1 control endpoint</dd></dl>
</li>
<li>The maximum numbers of Bulk interface increased from 1 -&gt; 4</li>
<li>The maximum number of interface association descriptors increased 3 -&gt; 4 (See the USB_MAX_NUM_IAD macro in the USB_Conf.h file).</li>
<li>The maximum number of Microsoft OS descriptors increased from 3 -&gt; 4 (See the USB_MAX_NUM_MS_DESC macro in the USB_Conf.h file).  </li>
</ul>
</td><td>Extending the supported features for PSOC6 devices  </td></tr>
<tr>
<td>Added remote wake-up functionality for PSOC6 devices </td><td>Extending the supported features for PSOC6 devices  </td></tr>
<tr>
<td>Updated the implementation of Debug Message Output. The usbd_config_io.c file became more friendly for updating and a USBD_DISABLE_STANDARD_OUTPUT macro was added. For details, refer to <a class="el" href="index.html#section_emusb_device_debug_mes_out">Debug Message Output</a>  </td><td>Improved the usability of Debug Message Output  </td></tr>
<tr>
<td>Added a new section in the documentation <a class="el" href="index.html#section_emusb_device_low_power_lpm">Link Power Management (LPM)</a>  </td><td></td></tr>
<tr>
<td>Minor documentation updates </td><td></td></tr>
<tr>
<td>1.0.1 </td><td>Updating the LICENSE file </td><td></td></tr>
<tr>
<td>1.0.0 </td><td>Initial release of emUSB-Device stack 3.52.2 </td><td></td></tr>
</table>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>emusb-device</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
