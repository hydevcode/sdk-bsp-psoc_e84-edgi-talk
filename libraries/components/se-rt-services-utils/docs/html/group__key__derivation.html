<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SE RT Services Utilities library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SE RT Services Utilities library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__key__derivation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Key derivation<div class="ingroups"><a class="el" href="group__psacrypto.html">IFX SE PSA crypto API</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p >Key derivation definitions. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gafca93273f27540fe01ce009ff8e3a716"><td class="memItemLeft" align="right" valign="top"><a id="gafca93273f27540fe01ce009ff8e3a716" name="gafca93273f27540fe01ce009ff8e3a716"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFX_SE_KEY_DERIVATION_OPERATION_INIT</b>&#160;&#160;&#160;{0}</td></tr>
<tr class="memdesc:gafca93273f27540fe01ce009ff8e3a716"><td class="mdescLeft">&#160;</td><td class="mdescRight">This only zeroes out the first byte in the union, the rest is unspecified. <br /></td></tr>
<tr class="separator:gafca93273f27540fe01ce009ff8e3a716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac670b2115b71ff7c5b517bb6e90bb0ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#gac670b2115b71ff7c5b517bb6e90bb0ed">IFX_SE_KEY_DERIVATION_INPUT_SECRET</a>&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0101)</td></tr>
<tr class="memdesc:gac670b2115b71ff7c5b517bb6e90bb0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A secret input for key derivation.  <a href="group__key__derivation.html#gac670b2115b71ff7c5b517bb6e90bb0ed">More...</a><br /></td></tr>
<tr class="separator:gac670b2115b71ff7c5b517bb6e90bb0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga027514f96faf9bc353ccceb78888dc99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga027514f96faf9bc353ccceb78888dc99">IFX_SE_KEY_DERIVATION_INPUT_PASSWORD</a>&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0102)</td></tr>
<tr class="memdesc:ga027514f96faf9bc353ccceb78888dc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">A low-entropy secret input for password hashing / key stretching.  <a href="group__key__derivation.html#ga027514f96faf9bc353ccceb78888dc99">More...</a><br /></td></tr>
<tr class="separator:ga027514f96faf9bc353ccceb78888dc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga627a3b3bb2b53257c81748391752e8dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga627a3b3bb2b53257c81748391752e8dc">IFX_SE_KEY_DERIVATION_INPUT_OTHER_SECRET</a>&#160;&#160;&#160;                                            ((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0103)</td></tr>
<tr class="memdesc:ga627a3b3bb2b53257c81748391752e8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A high-entropy additional secret input for key derivation.  <a href="group__key__derivation.html#ga627a3b3bb2b53257c81748391752e8dc">More...</a><br /></td></tr>
<tr class="separator:ga627a3b3bb2b53257c81748391752e8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a5a001c6ed17f8e094f1a3e35781c26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga2a5a001c6ed17f8e094f1a3e35781c26">IFX_SE_KEY_DERIVATION_INPUT_LABEL</a>&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0201)</td></tr>
<tr class="memdesc:ga2a5a001c6ed17f8e094f1a3e35781c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">A label for key derivation.  <a href="group__key__derivation.html#ga2a5a001c6ed17f8e094f1a3e35781c26">More...</a><br /></td></tr>
<tr class="separator:ga2a5a001c6ed17f8e094f1a3e35781c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83059e068d87ee0e7ab8e1d4feb2ba7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga83059e068d87ee0e7ab8e1d4feb2ba7a">IFX_SE_KEY_DERIVATION_INPUT_SALT</a>&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0202)</td></tr>
<tr class="memdesc:ga83059e068d87ee0e7ab8e1d4feb2ba7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A salt for key derivation.  <a href="group__key__derivation.html#ga83059e068d87ee0e7ab8e1d4feb2ba7a">More...</a><br /></td></tr>
<tr class="separator:ga83059e068d87ee0e7ab8e1d4feb2ba7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2796c4a2ecdac1ccc59ae890744ef3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga7a2796c4a2ecdac1ccc59ae890744ef3">IFX_SE_KEY_DERIVATION_INPUT_INFO</a>&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0203)</td></tr>
<tr class="memdesc:ga7a2796c4a2ecdac1ccc59ae890744ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">An information string for key derivation.  <a href="group__key__derivation.html#ga7a2796c4a2ecdac1ccc59ae890744ef3">More...</a><br /></td></tr>
<tr class="separator:ga7a2796c4a2ecdac1ccc59ae890744ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff60c4048c55b337c48db1a74ef3a86d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#gaff60c4048c55b337c48db1a74ef3a86d">IFX_SE_KEY_DERIVATION_INPUT_SEED</a>&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0204)</td></tr>
<tr class="memdesc:gaff60c4048c55b337c48db1a74ef3a86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A seed for key derivation.  <a href="group__key__derivation.html#gaff60c4048c55b337c48db1a74ef3a86d">More...</a><br /></td></tr>
<tr class="separator:gaff60c4048c55b337c48db1a74ef3a86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac2d333450e0ba4a45f4160a6403494a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#gaac2d333450e0ba4a45f4160a6403494a">IFX_SE_KEY_DERIVATION_INPUT_COST</a>&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0205)</td></tr>
<tr class="memdesc:gaac2d333450e0ba4a45f4160a6403494a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cost parameter for password hashing / key stretching.  <a href="group__key__derivation.html#gaac2d333450e0ba4a45f4160a6403494a">More...</a><br /></td></tr>
<tr class="separator:gaac2d333450e0ba4a45f4160a6403494a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86d8620e5ad2460b2dba3e0382a2e8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#gac86d8620e5ad2460b2dba3e0382a2e8d">IFX_SE_KEY_DERIVATION_INPUT_FIXED_DATA</a>&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0206)</td></tr>
<tr class="memdesc:gac86d8620e5ad2460b2dba3e0382a2e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed data for the key derivation.  <a href="group__key__derivation.html#gac86d8620e5ad2460b2dba3e0382a2e8d">More...</a><br /></td></tr>
<tr class="separator:gac86d8620e5ad2460b2dba3e0382a2e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9083cc558b17b558d62eaf74f6f699fc"><td class="memItemLeft" align="right" valign="top">typedef struct ifx_se_key_derivation_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a></td></tr>
<tr class="memdesc:ga9083cc558b17b558d62eaf74f6f699fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the state data structure for key derivation operations.  <a href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">More...</a><br /></td></tr>
<tr class="separator:ga9083cc558b17b558d62eaf74f6f699fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8178cf73cbb1c3dfc41eca4397038200"><td class="memItemLeft" align="right" valign="top"><a id="ga8178cf73cbb1c3dfc41eca4397038200" name="ga8178cf73cbb1c3dfc41eca4397038200"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>ifx_se_key_derivation_step_t</b></td></tr>
<tr class="memdesc:ga8178cf73cbb1c3dfc41eca4397038200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoding of the step of a key derivation. <br /></td></tr>
<tr class="separator:ga8178cf73cbb1c3dfc41eca4397038200"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa4c3f9a1959b6403be6021f0d16c6105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#gaa4c3f9a1959b6403be6021f0d16c6105">ifx_se_key_derivation_abort</a> (<a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *operation, void *ctx)</td></tr>
<tr class="memdesc:gaa4c3f9a1959b6403be6021f0d16c6105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort a key derivation operation.  <a href="group__key__derivation.html#gaa4c3f9a1959b6403be6021f0d16c6105">More...</a><br /></td></tr>
<tr class="separator:gaa4c3f9a1959b6403be6021f0d16c6105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24279023e83b8eebdec720f2eaa18ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#gae24279023e83b8eebdec720f2eaa18ad">ifx_se_key_derivation_setup</a> (<a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *operation, <a class="el" href="group__fih.html#gae48734cc37441057b24896ec06080819">ifx_se_alg_fih_t</a> alg, void *ctx)</td></tr>
<tr class="memdesc:gae24279023e83b8eebdec720f2eaa18ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a key derivation operation.  <a href="group__key__derivation.html#gae24279023e83b8eebdec720f2eaa18ad">More...</a><br /></td></tr>
<tr class="separator:gae24279023e83b8eebdec720f2eaa18ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ed9269567c488bf943cdbb9da533829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga0ed9269567c488bf943cdbb9da533829">ifx_se_key_derivation_get_capacity</a> (const <a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *operation, <a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a> capacity, void *ctx)</td></tr>
<tr class="memdesc:ga0ed9269567c488bf943cdbb9da533829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current capacity of a key derivation operation.  <a href="group__key__derivation.html#ga0ed9269567c488bf943cdbb9da533829">More...</a><br /></td></tr>
<tr class="separator:ga0ed9269567c488bf943cdbb9da533829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293ed5472882630c0168b196b9e5dcaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga293ed5472882630c0168b196b9e5dcaf">ifx_se_key_derivation_set_capacity</a> (<a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *operation, <a class="el" href="group__fih.html#ga3f01e5cacf10e2e35af27096b162037a">ifx_se_fih_t</a> capacity, void *ctx)</td></tr>
<tr class="memdesc:ga293ed5472882630c0168b196b9e5dcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum capacity of a key derivation operation.  <a href="group__key__derivation.html#ga293ed5472882630c0168b196b9e5dcaf">More...</a><br /></td></tr>
<tr class="separator:ga293ed5472882630c0168b196b9e5dcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa70ea4b4e0435634b8c6df52aaab0f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#gaa70ea4b4e0435634b8c6df52aaab0f64">ifx_se_key_derivation_input_key</a> (<a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *operation, <a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a> step, <a class="el" href="group__key__attributes.html#ga40f81e5fa5d5b8c64b81b49d60ccc6dc">ifx_se_key_id_fih_t</a> key, void *ctx)</td></tr>
<tr class="memdesc:gaa70ea4b4e0435634b8c6df52aaab0f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an input for key derivation in the form of a key.  <a href="group__key__derivation.html#gaa70ea4b4e0435634b8c6df52aaab0f64">More...</a><br /></td></tr>
<tr class="separator:gaa70ea4b4e0435634b8c6df52aaab0f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce3f57827865aa44cadb501d3af73e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga8ce3f57827865aa44cadb501d3af73e1">ifx_se_key_derivation_input_bytes</a> (<a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *operation, <a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a> step, const <a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a> data, <a class="el" href="group__fih.html#ga3f01e5cacf10e2e35af27096b162037a">ifx_se_fih_t</a> data_length, void *ctx)</td></tr>
<tr class="memdesc:ga8ce3f57827865aa44cadb501d3af73e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an input for key derivation or key agreement.  <a href="group__key__derivation.html#ga8ce3f57827865aa44cadb501d3af73e1">More...</a><br /></td></tr>
<tr class="separator:ga8ce3f57827865aa44cadb501d3af73e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103033116e74486ea161e764e7b28fcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga103033116e74486ea161e764e7b28fcd">ifx_se_key_derivation_output_bytes</a> (<a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *operation, <a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a> output, <a class="el" href="group__fih.html#ga3f01e5cacf10e2e35af27096b162037a">ifx_se_fih_t</a> output_length, void *ctx)</td></tr>
<tr class="memdesc:ga103033116e74486ea161e764e7b28fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data from a key derivation operation.  <a href="group__key__derivation.html#ga103033116e74486ea161e764e7b28fcd">More...</a><br /></td></tr>
<tr class="separator:ga103033116e74486ea161e764e7b28fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454b8a7f1df96b26ec407b6e133eb4e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga454b8a7f1df96b26ec407b6e133eb4e6">ifx_se_key_derivation_output_key</a> (const <a class="el" href="group__key__attributes.html#gad1ded78e935cd08ba08a5a27c003d7b3">ifx_se_key_attributes_t</a> *attributes, <a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *operation, <a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a> key, void *ctx)</td></tr>
<tr class="memdesc:ga454b8a7f1df96b26ec407b6e133eb4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive a key from an ongoing key derivation operation.  <a href="group__key__derivation.html#ga454b8a7f1df96b26ec407b6e133eb4e6">More...</a><br /></td></tr>
<tr class="separator:ga454b8a7f1df96b26ec407b6e133eb4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a911ad2d28e124a069ffa0bd420e46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga39a911ad2d28e124a069ffa0bd420e46">ifx_se_key_derivation_key_agreement</a> (<a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *operation, <a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a> step, <a class="el" href="group__key__attributes.html#ga40f81e5fa5d5b8c64b81b49d60ccc6dc">ifx_se_key_id_fih_t</a> private_key, const <a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a> peer_key, <a class="el" href="group__fih.html#ga3f01e5cacf10e2e35af27096b162037a">ifx_se_fih_t</a> peer_key_length, void *ctx)</td></tr>
<tr class="memdesc:ga39a911ad2d28e124a069ffa0bd420e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a key agreement and use the shared secret as input to a key derivation.  <a href="group__key__derivation.html#ga39a911ad2d28e124a069ffa0bd420e46">More...</a><br /></td></tr>
<tr class="separator:ga39a911ad2d28e124a069ffa0bd420e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad36f8eff1151d8ae5b9a9e204cd32c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#gaad36f8eff1151d8ae5b9a9e204cd32c3">ifx_se_raw_key_agreement</a> (<a class="el" href="group__fih.html#gae48734cc37441057b24896ec06080819">ifx_se_alg_fih_t</a> alg, <a class="el" href="group__key__attributes.html#ga40f81e5fa5d5b8c64b81b49d60ccc6dc">ifx_se_key_id_fih_t</a> private_key, const <a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a> peer_key, <a class="el" href="group__fih.html#ga3f01e5cacf10e2e35af27096b162037a">ifx_se_fih_t</a> peer_key_length, <a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a> output, <a class="el" href="group__fih.html#ga3f01e5cacf10e2e35af27096b162037a">ifx_se_fih_t</a> output_size, <a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a> output_length, void *ctx)</td></tr>
<tr class="memdesc:gaad36f8eff1151d8ae5b9a9e204cd32c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a key agreement and return the raw shared secret.  <a href="group__key__derivation.html#gaad36f8eff1151d8ae5b9a9e204cd32c3">More...</a><br /></td></tr>
<tr class="separator:gaad36f8eff1151d8ae5b9a9e204cd32c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d2a63031c941cba0d279ae78d83a0b3"><td class="memItemLeft" align="right" valign="top">static struct ifx_se_key_derivation_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__key__derivation.html#ga7d2a63031c941cba0d279ae78d83a0b3">ifx_se_key_derivation_operation_init</a> (void)</td></tr>
<tr class="memdesc:ga7d2a63031c941cba0d279ae78d83a0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the key derivation context.  <a href="group__key__derivation.html#ga7d2a63031c941cba0d279ae78d83a0b3">More...</a><br /></td></tr>
<tr class="separator:ga7d2a63031c941cba0d279ae78d83a0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gac670b2115b71ff7c5b517bb6e90bb0ed" name="gac670b2115b71ff7c5b517bb6e90bb0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac670b2115b71ff7c5b517bb6e90bb0ed">&#9670;&nbsp;</a></span>IFX_SE_KEY_DERIVATION_INPUT_SECRET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_KEY_DERIVATION_INPUT_SECRET&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0101)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A secret input for key derivation. </p>
<p >This should be a key of type <a class="el" href="group__crypto__types.html#ga954abb950069b6104f746304e1a17b79" title="A secret for key derivation.">IFX_SE_KEY_TYPE_DERIVE</a> (passed to <a class="el" href="group__key__derivation.html#gaa70ea4b4e0435634b8c6df52aaab0f64" title="Provide an input for key derivation in the form of a key.">ifx_se_key_derivation_input_key()</a>) or the shared secret resulting from a key agreement (obtained via <a class="el" href="group__key__derivation.html#ga39a911ad2d28e124a069ffa0bd420e46" title="Perform a key agreement and use the shared secret as input to a key derivation.">ifx_se_key_derivation_key_agreement()</a>).</p>
<p >The secret can also be a direct input (passed to key_derivation_input_bytes()). In this case, the derivation operation may not be used to derive keys: the operation will only allow <a class="el" href="group__key__derivation.html#ga103033116e74486ea161e764e7b28fcd" title="Read some data from a key derivation operation.">ifx_se_key_derivation_output_bytes()</a>, ifx_se_key_derivation_verify_bytes(), or ifx_se_key_derivation_verify_key(), but not <a class="el" href="group__key__derivation.html#ga454b8a7f1df96b26ec407b6e133eb4e6" title="Derive a key from an ongoing key derivation operation.">ifx_se_key_derivation_output_key()</a>. </p>

</div>
</div>
<a id="ga027514f96faf9bc353ccceb78888dc99" name="ga027514f96faf9bc353ccceb78888dc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga027514f96faf9bc353ccceb78888dc99">&#9670;&nbsp;</a></span>IFX_SE_KEY_DERIVATION_INPUT_PASSWORD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_KEY_DERIVATION_INPUT_PASSWORD&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0102)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A low-entropy secret input for password hashing / key stretching. </p>
<p >This is usually a key of type <a class="el" href="group__crypto__types.html#ga094ca6a6b1849a5743afa8c4c4010822" title="A low-entropy secret for password hashing or key derivation.">IFX_SE_KEY_TYPE_PASSWORD</a> (passed to <a class="el" href="group__key__derivation.html#gaa70ea4b4e0435634b8c6df52aaab0f64" title="Provide an input for key derivation in the form of a key.">ifx_se_key_derivation_input_key()</a>) or a direct input (passed to <a class="el" href="group__key__derivation.html#ga8ce3f57827865aa44cadb501d3af73e1" title="Provide an input for key derivation or key agreement.">ifx_se_key_derivation_input_bytes()</a>) that is a password or passphrase. It can also be high-entropy secret such as a key of type <a class="el" href="group__crypto__types.html#ga954abb950069b6104f746304e1a17b79" title="A secret for key derivation.">IFX_SE_KEY_TYPE_DERIVE</a> or the shared secret resulting from a key agreement.</p>
<p >The secret can also be a direct input (passed to key_derivation_input_bytes()). In this case, the derivation operation may not be used to derive keys: the operation will only allow <a class="el" href="group__key__derivation.html#ga103033116e74486ea161e764e7b28fcd" title="Read some data from a key derivation operation.">ifx_se_key_derivation_output_bytes()</a>, ifx_se_key_derivation_verify_bytes(), or ifx_se_key_derivation_verify_key(), but not <a class="el" href="group__key__derivation.html#ga454b8a7f1df96b26ec407b6e133eb4e6" title="Derive a key from an ongoing key derivation operation.">ifx_se_key_derivation_output_key()</a>. </p>

</div>
</div>
<a id="ga627a3b3bb2b53257c81748391752e8dc" name="ga627a3b3bb2b53257c81748391752e8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga627a3b3bb2b53257c81748391752e8dc">&#9670;&nbsp;</a></span>IFX_SE_KEY_DERIVATION_INPUT_OTHER_SECRET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_KEY_DERIVATION_INPUT_OTHER_SECRET&#160;&#160;&#160;                                            ((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0103)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A high-entropy additional secret input for key derivation. </p>
<p >This is typically the shared secret resulting from a key agreement obtained via <code><a class="el" href="group__key__derivation.html#ga39a911ad2d28e124a069ffa0bd420e46" title="Perform a key agreement and use the shared secret as input to a key derivation.">ifx_se_key_derivation_key_agreement()</a></code>. It may alternatively be a key of type <code>IFX_SE_KEY_TYPE_DERIVE</code> passed to <code><a class="el" href="group__key__derivation.html#gaa70ea4b4e0435634b8c6df52aaab0f64" title="Provide an input for key derivation in the form of a key.">ifx_se_key_derivation_input_key()</a></code>, or a direct input passed to <code><a class="el" href="group__key__derivation.html#ga8ce3f57827865aa44cadb501d3af73e1" title="Provide an input for key derivation or key agreement.">ifx_se_key_derivation_input_bytes()</a></code>. </p>

</div>
</div>
<a id="ga2a5a001c6ed17f8e094f1a3e35781c26" name="ga2a5a001c6ed17f8e094f1a3e35781c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a5a001c6ed17f8e094f1a3e35781c26">&#9670;&nbsp;</a></span>IFX_SE_KEY_DERIVATION_INPUT_LABEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_KEY_DERIVATION_INPUT_LABEL&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0201)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A label for key derivation. </p>
<p >This should be a direct input. It can also be a key of type <a class="el" href="group__crypto__types.html#ga2f3f8cf749aa6dc07c6e6c7d83afeb35" title="Raw data.">IFX_SE_KEY_TYPE_RAW_DATA</a>. </p>

</div>
</div>
<a id="ga83059e068d87ee0e7ab8e1d4feb2ba7a" name="ga83059e068d87ee0e7ab8e1d4feb2ba7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83059e068d87ee0e7ab8e1d4feb2ba7a">&#9670;&nbsp;</a></span>IFX_SE_KEY_DERIVATION_INPUT_SALT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_KEY_DERIVATION_INPUT_SALT&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0202)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A salt for key derivation. </p>
<p >This should be a direct input. It can also be a key of type <a class="el" href="group__crypto__types.html#ga2f3f8cf749aa6dc07c6e6c7d83afeb35" title="Raw data.">IFX_SE_KEY_TYPE_RAW_DATA</a> or <a class="el" href="group__crypto__types.html#ga687fd8ad8eb5eb3adfc6999f5cd2406d" title="A secret value that can be used in when computing a password hash.">IFX_SE_KEY_TYPE_PEPPER</a>. </p>

</div>
</div>
<a id="ga7a2796c4a2ecdac1ccc59ae890744ef3" name="ga7a2796c4a2ecdac1ccc59ae890744ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a2796c4a2ecdac1ccc59ae890744ef3">&#9670;&nbsp;</a></span>IFX_SE_KEY_DERIVATION_INPUT_INFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_KEY_DERIVATION_INPUT_INFO&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0203)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An information string for key derivation. </p>
<p >This should be a direct input. It can also be a key of type <a class="el" href="group__crypto__types.html#ga2f3f8cf749aa6dc07c6e6c7d83afeb35" title="Raw data.">IFX_SE_KEY_TYPE_RAW_DATA</a>. </p>

</div>
</div>
<a id="gaff60c4048c55b337c48db1a74ef3a86d" name="gaff60c4048c55b337c48db1a74ef3a86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff60c4048c55b337c48db1a74ef3a86d">&#9670;&nbsp;</a></span>IFX_SE_KEY_DERIVATION_INPUT_SEED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_KEY_DERIVATION_INPUT_SEED&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0204)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A seed for key derivation. </p>
<p >This should be a direct input. It can also be a key of type <a class="el" href="group__crypto__types.html#ga2f3f8cf749aa6dc07c6e6c7d83afeb35" title="Raw data.">IFX_SE_KEY_TYPE_RAW_DATA</a>. </p>

</div>
</div>
<a id="gaac2d333450e0ba4a45f4160a6403494a" name="gaac2d333450e0ba4a45f4160a6403494a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac2d333450e0ba4a45f4160a6403494a">&#9670;&nbsp;</a></span>IFX_SE_KEY_DERIVATION_INPUT_COST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_KEY_DERIVATION_INPUT_COST&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0205)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A cost parameter for password hashing / key stretching. </p>
<p >This must be a direct input, passed to ifx_se_key_derivation_input_integer(). </p>

</div>
</div>
<a id="gac86d8620e5ad2460b2dba3e0382a2e8d" name="gac86d8620e5ad2460b2dba3e0382a2e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac86d8620e5ad2460b2dba3e0382a2e8d">&#9670;&nbsp;</a></span>IFX_SE_KEY_DERIVATION_INPUT_FIXED_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_KEY_DERIVATION_INPUT_FIXED_DATA&#160;&#160;&#160;((<a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>)0x0206)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixed data for the key derivation. </p>
<p >This should be a direct input. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga9083cc558b17b558d62eaf74f6f699fc" name="ga9083cc558b17b558d62eaf74f6f699fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9083cc558b17b558d62eaf74f6f699fc">&#9670;&nbsp;</a></span>ifx_se_key_derivation_operation_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ifx_se_key_derivation_s <a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the state data structure for key derivation operations. </p>
<p >This is an implementation-defined <code>struct</code>. Applications should not make any assumptions about the content of this structure except as directed by the documentation of a specific implementation. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa4c3f9a1959b6403be6021f0d16c6105" name="gaa4c3f9a1959b6403be6021f0d16c6105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4c3f9a1959b6403be6021f0d16c6105">&#9670;&nbsp;</a></span>ifx_se_key_derivation_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a> ifx_se_key_derivation_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort a key derivation operation. </p>
<p >Aborting an operation frees all associated resources except for the <code>operation</code> structure itself. Once aborted, the operation object can be reused for another operation by calling <a class="el" href="group__key__derivation.html#gae24279023e83b8eebdec720f2eaa18ad" title="Set up a key derivation operation.">ifx_se_key_derivation_setup()</a> again.</p>
<p >This function may be called at any time after the operation object has been initialized as described in <a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc" title="The type of the state data structure for key derivation operations.">ifx_se_key_derivation_operation_t</a>.</p>
<p >In particular, it is valid to call <a class="el" href="group__key__derivation.html#gaa4c3f9a1959b6403be6021f0d16c6105" title="Abort a key derivation operation.">ifx_se_key_derivation_abort()</a> twice, or to call <a class="el" href="group__key__derivation.html#gaa4c3f9a1959b6403be6021f0d16c6105" title="Abort a key derivation operation.">ifx_se_key_derivation_abort()</a> on an operation that has not been set up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>The operation to abort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The pointer to the SE syscall context that contain a special syscall data (IPC release callback etc).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47" title="Success operation.">IFX_SE_SUCCESS</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaee4d9090ad3ca96300447d0368092cbe" title="There was a communication failure inside the implementation.">IFX_SE_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga06d90cd8966c5061f118ca580d76a2e0" title="A hardware failure was detected.">IFX_SE_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga90718ef69f96a0ff2b2877f65e58a3e1" title="A tampering attempt was detected.">IFX_SE_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae24279023e83b8eebdec720f2eaa18ad" name="gae24279023e83b8eebdec720f2eaa18ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae24279023e83b8eebdec720f2eaa18ad">&#9670;&nbsp;</a></span>ifx_se_key_derivation_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a> ifx_se_key_derivation_setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fih.html#gae48734cc37441057b24896ec06080819">ifx_se_alg_fih_t</a>&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up a key derivation operation. </p>
<p >A key derivation algorithm takes some inputs and uses them to generate a byte stream in a deterministic way. This byte stream can be used to produce keys and other cryptographic material.</p>
<p >To derive a key:</p><ol type="1">
<li>Start with an initialized object of type <a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc" title="The type of the state data structure for key derivation operations.">ifx_se_key_derivation_operation_t</a>.</li>
<li>Call <a class="el" href="group__key__derivation.html#gae24279023e83b8eebdec720f2eaa18ad" title="Set up a key derivation operation.">ifx_se_key_derivation_setup()</a> to select the algorithm.</li>
<li>Provide the inputs for the key derivation by calling <a class="el" href="group__key__derivation.html#ga8ce3f57827865aa44cadb501d3af73e1" title="Provide an input for key derivation or key agreement.">ifx_se_key_derivation_input_bytes()</a> or <a class="el" href="group__key__derivation.html#gaa70ea4b4e0435634b8c6df52aaab0f64" title="Provide an input for key derivation in the form of a key.">ifx_se_key_derivation_input_key()</a> as appropriate. Which inputs are needed, in what order, and whether they may be keys and if so of what type depends on the algorithm.</li>
<li>Optionally set the operation's maximum capacity with <a class="el" href="group__key__derivation.html#ga293ed5472882630c0168b196b9e5dcaf" title="Set the maximum capacity of a key derivation operation.">ifx_se_key_derivation_set_capacity()</a>. You may do this before, in the middle of or after providing inputs. For some algorithms, this step is mandatory because the output depends on the maximum capacity.</li>
<li>To derive a key, call <a class="el" href="group__key__derivation.html#ga454b8a7f1df96b26ec407b6e133eb4e6" title="Derive a key from an ongoing key derivation operation.">ifx_se_key_derivation_output_key()</a>. To derive a byte string for a different purpose, call <a class="el" href="group__key__derivation.html#ga103033116e74486ea161e764e7b28fcd" title="Read some data from a key derivation operation.">ifx_se_key_derivation_output_bytes()</a>. Successive calls to these functions use successive output bytes calculated by the key derivation algorithm.</li>
<li>Clean up the key derivation operation object with <a class="el" href="group__key__derivation.html#gaa4c3f9a1959b6403be6021f0d16c6105" title="Abort a key derivation operation.">ifx_se_key_derivation_abort()</a>.</li>
</ol>
<p >If this function returns an error, the key derivation operation object is not changed.</p>
<p >If an error occurs at any step after a call to <a class="el" href="group__key__derivation.html#gae24279023e83b8eebdec720f2eaa18ad" title="Set up a key derivation operation.">ifx_se_key_derivation_setup()</a>, the operation will need to be reset by a call to <a class="el" href="group__key__derivation.html#gaa4c3f9a1959b6403be6021f0d16c6105" title="Abort a key derivation operation.">ifx_se_key_derivation_abort()</a>.</p>
<p >Implementations must reject an attempt to derive a key of size 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>The key derivation operation object to set up. It must have been initialized but not set up yet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alg</td><td>The key derivation algorithm to compute (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#ga4bbc9bd09118a1967d93614a232ca40a" title="Whether the specified algorithm is a key derivation algorithm.">IFX_SE_ALG_IS_KEY_DERIVATION</a>(<code>alg</code>) is true). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The pointer to the SE syscall context that contain a special syscall data (IPC release callback etc).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47" title="Success operation.">IFX_SE_SUCCESS</a></td><td>Success. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga40c10ca60e337c7f6071577c5ce9b108" title="The parameters passed to the function are invalid.">IFX_SE_ERROR_INVALID_ARGUMENT</a></td><td><code>alg</code> is not a key derivation algorithm. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gae3392ff6990c04e50c7fcfd34bc60f2f" title="The requested operation or a parameter is not supported by this implementation.">IFX_SE_ERROR_NOT_SUPPORTED</a></td><td><code>alg</code> is not supported or is not a key derivation algorithm. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaa6d53bc35e03dd93f863cb2687b79546" title="There is not enough runtime memory.">IFX_SE_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaee4d9090ad3ca96300447d0368092cbe" title="There was a communication failure inside the implementation.">IFX_SE_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga06d90cd8966c5061f118ca580d76a2e0" title="A hardware failure was detected.">IFX_SE_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga90718ef69f96a0ff2b2877f65e58a3e1" title="A tampering attempt was detected.">IFX_SE_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gadbe9aa2de2448391e663c45506ada4e0" title="There was a storage failure that may have led to data loss.">IFX_SE_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga3a99268d483c4255eb0368d879ecfc7a" title="The requested action cannot be performed in the current state.">IFX_SE_ERROR_BAD_STATE</a></td><td>The operation state is not valid (it must be inactive). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ed9269567c488bf943cdbb9da533829" name="ga0ed9269567c488bf943cdbb9da533829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ed9269567c488bf943cdbb9da533829">&#9670;&nbsp;</a></span>ifx_se_key_derivation_get_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a> ifx_se_key_derivation_get_capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a>&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current capacity of a key derivation operation. </p>
<p >The capacity of a key derivation is the maximum number of bytes that it can return. When you get <em>N</em> bytes of output from a key derivation operation, this reduces its capacity by <em>N</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operation</td><td>The operation to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">capacity</td><td>On success, the capacity of the operation (encoded pointer to size_t variable). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The pointer to the SE syscall context that contain a special syscall data (IPC release callback etc).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47" title="Success operation.">IFX_SE_SUCCESS</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaee4d9090ad3ca96300447d0368092cbe" title="There was a communication failure inside the implementation.">IFX_SE_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga06d90cd8966c5061f118ca580d76a2e0" title="A hardware failure was detected.">IFX_SE_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga90718ef69f96a0ff2b2877f65e58a3e1" title="A tampering attempt was detected.">IFX_SE_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga3a99268d483c4255eb0368d879ecfc7a" title="The requested action cannot be performed in the current state.">IFX_SE_ERROR_BAD_STATE</a></td><td>The operation state is not valid (it must be active). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga293ed5472882630c0168b196b9e5dcaf" name="ga293ed5472882630c0168b196b9e5dcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga293ed5472882630c0168b196b9e5dcaf">&#9670;&nbsp;</a></span>ifx_se_key_derivation_set_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a> ifx_se_key_derivation_set_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fih.html#ga3f01e5cacf10e2e35af27096b162037a">ifx_se_fih_t</a>&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum capacity of a key derivation operation. </p>
<p >The capacity of a key derivation operation is the maximum number of bytes that the key derivation operation can return from this point onwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>The key derivation operation object to modify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The new capacity of the operation. It must be less or equal to the operation's current capacity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The pointer to the SE syscall context that contain a special syscall data (IPC release callback etc).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47" title="Success operation.">IFX_SE_SUCCESS</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga40c10ca60e337c7f6071577c5ce9b108" title="The parameters passed to the function are invalid.">IFX_SE_ERROR_INVALID_ARGUMENT</a></td><td><code>capacity</code> is larger than the operation's current capacity. In this case, the operation object remains valid and its capacity remains unchanged. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaee4d9090ad3ca96300447d0368092cbe" title="There was a communication failure inside the implementation.">IFX_SE_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga06d90cd8966c5061f118ca580d76a2e0" title="A hardware failure was detected.">IFX_SE_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga90718ef69f96a0ff2b2877f65e58a3e1" title="A tampering attempt was detected.">IFX_SE_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga3a99268d483c4255eb0368d879ecfc7a" title="The requested action cannot be performed in the current state.">IFX_SE_ERROR_BAD_STATE</a></td><td>The operation state is not valid (it must be active). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa70ea4b4e0435634b8c6df52aaab0f64" name="gaa70ea4b4e0435634b8c6df52aaab0f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa70ea4b4e0435634b8c6df52aaab0f64">&#9670;&nbsp;</a></span>ifx_se_key_derivation_input_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a> ifx_se_key_derivation_input_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__key__attributes.html#ga40f81e5fa5d5b8c64b81b49d60ccc6dc">ifx_se_key_id_fih_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide an input for key derivation in the form of a key. </p>
<p >Which inputs are required and in what order depends on the algorithm. Refer to the documentation of each key derivation or key agreement algorithm for information.</p>
<p >This function obtains input from a key object, which is usually correct for secret inputs or for non-secret personalization strings kept in the key store. To pass a non-secret parameter which is not in the key store, call <a class="el" href="group__key__derivation.html#ga8ce3f57827865aa44cadb501d3af73e1" title="Provide an input for key derivation or key agreement.">ifx_se_key_derivation_input_bytes()</a> instead of this function. Refer to the documentation of individual step types (<code>IFX_SE_KEY_DERIVATION_INPUT_xxx</code> values of type <a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200" title="Encoding of the step of a key derivation.">ifx_se_key_derivation_step_t</a>) for more information.</p>
<p >If this function returns an error status, the operation enters an error state and must be aborted by calling <a class="el" href="group__key__derivation.html#gaa4c3f9a1959b6403be6021f0d16c6105" title="Abort a key derivation operation.">ifx_se_key_derivation_abort()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>The key derivation operation object to use. It must have been set up with <a class="el" href="group__key__derivation.html#gae24279023e83b8eebdec720f2eaa18ad" title="Set up a key derivation operation.">ifx_se_key_derivation_setup()</a> and must not have produced any output yet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>Which step the input data is for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Identifier of the key. It must have an appropriate type for step and must allow the usage <a class="el" href="group__key__policy.html#ga70772b0c644888fb60605bfddd86f1bb" title="Whether the key may be used to derive other keys or produce a password hash.">IFX_SE_KEY_USAGE_DERIVE</a> or <a class="el" href="group__key__policy.html#ga3b40ef045d9fcc8a773a3d86e6d39dd4" title="Whether the key may be used to verify the result of a key derivation, including password hashing.">IFX_SE_KEY_USAGE_VERIFY_DERIVATION</a> (see note) and the algorithm used by the operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The pointer to the SE syscall context that contain a special syscall data (IPC release callback etc).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Once all inputs steps are completed, the operations will allow:<ul>
<li><a class="el" href="group__key__derivation.html#ga103033116e74486ea161e764e7b28fcd" title="Read some data from a key derivation operation.">ifx_se_key_derivation_output_bytes()</a> if each input was either a direct input or a key with <a class="el" href="group__key__policy.html#ga70772b0c644888fb60605bfddd86f1bb" title="Whether the key may be used to derive other keys or produce a password hash.">IFX_SE_KEY_USAGE_DERIVE</a> set;</li>
<li><a class="el" href="group__key__derivation.html#ga454b8a7f1df96b26ec407b6e133eb4e6" title="Derive a key from an ongoing key derivation operation.">ifx_se_key_derivation_output_key()</a> if the input for step <a class="el" href="group__key__derivation.html#gac670b2115b71ff7c5b517bb6e90bb0ed" title="A secret input for key derivation.">IFX_SE_KEY_DERIVATION_INPUT_SECRET</a> or <a class="el" href="group__key__derivation.html#ga027514f96faf9bc353ccceb78888dc99" title="A low-entropy secret input for password hashing / key stretching.">IFX_SE_KEY_DERIVATION_INPUT_PASSWORD</a> was from a key slot with <a class="el" href="group__key__policy.html#ga70772b0c644888fb60605bfddd86f1bb" title="Whether the key may be used to derive other keys or produce a password hash.">IFX_SE_KEY_USAGE_DERIVE</a> and each other input was either a direct input or a key with <a class="el" href="group__key__policy.html#ga70772b0c644888fb60605bfddd86f1bb" title="Whether the key may be used to derive other keys or produce a password hash.">IFX_SE_KEY_USAGE_DERIVE</a> set;</li>
<li>ifx_se_key_derivation_verify_bytes() if each input was either a direct input or a key with <a class="el" href="group__key__policy.html#ga3b40ef045d9fcc8a773a3d86e6d39dd4" title="Whether the key may be used to verify the result of a key derivation, including password hashing.">IFX_SE_KEY_USAGE_VERIFY_DERIVATION</a> set;</li>
<li>ifx_se_key_derivation_verify_key() under the same conditions as ifx_se_key_derivation_verify_bytes().</li>
</ul>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47" title="Success operation.">IFX_SE_SUCCESS</a></td><td>Success. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga4a7a5be0f27e1cf5576df18e6a626c1b" title="The key identifier is not valid.">IFX_SE_ERROR_INVALID_HANDLE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga61a9aad149daa181f3e15f63b778e8e7" title="The requested action is denied by a policy.">IFX_SE_ERROR_NOT_PERMITTED</a></td><td>The key allows neither <a class="el" href="group__key__policy.html#ga70772b0c644888fb60605bfddd86f1bb" title="Whether the key may be used to derive other keys or produce a password hash.">IFX_SE_KEY_USAGE_DERIVE</a> nor <a class="el" href="group__key__policy.html#ga3b40ef045d9fcc8a773a3d86e6d39dd4" title="Whether the key may be used to verify the result of a key derivation, including password hashing.">IFX_SE_KEY_USAGE_VERIFY_DERIVATION</a>, or it doesn't allow this algorithm. Also operation rejected with this response when HUK key is selected in SECURE life cycle and debug port is opened or enabled by policy. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga40c10ca60e337c7f6071577c5ce9b108" title="The parameters passed to the function are invalid.">IFX_SE_ERROR_INVALID_ARGUMENT</a></td><td><code>step</code> is not compatible with the operation's algorithm, or <code>step</code> does not allow key inputs of the given type or does not allow key inputs at all. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaa6d53bc35e03dd93f863cb2687b79546" title="There is not enough runtime memory.">IFX_SE_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaee4d9090ad3ca96300447d0368092cbe" title="There was a communication failure inside the implementation.">IFX_SE_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga06d90cd8966c5061f118ca580d76a2e0" title="A hardware failure was detected.">IFX_SE_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga90718ef69f96a0ff2b2877f65e58a3e1" title="A tampering attempt was detected.">IFX_SE_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gadbe9aa2de2448391e663c45506ada4e0" title="There was a storage failure that may have led to data loss.">IFX_SE_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga3a99268d483c4255eb0368d879ecfc7a" title="The requested action cannot be performed in the current state.">IFX_SE_ERROR_BAD_STATE</a></td><td>The operation state is not valid for this input <code>step</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ce3f57827865aa44cadb501d3af73e1" name="ga8ce3f57827865aa44cadb501d3af73e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ce3f57827865aa44cadb501d3af73e1">&#9670;&nbsp;</a></span>ifx_se_key_derivation_input_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a> ifx_se_key_derivation_input_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fih.html#ga3f01e5cacf10e2e35af27096b162037a">ifx_se_fih_t</a>&#160;</td>
          <td class="paramname"><em>data_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide an input for key derivation or key agreement. </p>
<p >Which inputs are required and in what order depends on the algorithm. Refer to the documentation of each key derivation or key agreement algorithm for information.</p>
<p >This function passes direct inputs, which is usually correct for non-secret inputs. To pass a secret input, which should be in a key object, call <a class="el" href="group__key__derivation.html#gaa70ea4b4e0435634b8c6df52aaab0f64" title="Provide an input for key derivation in the form of a key.">ifx_se_key_derivation_input_key()</a> instead of this function. Refer to the documentation of individual step types (<code>IFX_SE_KEY_DERIVATION_INPUT_xxx</code> values of type <a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200" title="Encoding of the step of a key derivation.">ifx_se_key_derivation_step_t</a>) for more information.</p>
<p >If this function returns an error status, the operation enters an error state and must be aborted by calling <a class="el" href="group__key__derivation.html#gaa4c3f9a1959b6403be6021f0d16c6105" title="Abort a key derivation operation.">ifx_se_key_derivation_abort()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>The key derivation operation object to use. It must have been set up with <a class="el" href="group__key__derivation.html#gae24279023e83b8eebdec720f2eaa18ad" title="Set up a key derivation operation.">ifx_se_key_derivation_setup()</a> and must not have produced any output yet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>Which step the input data is for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Input data to use (encoded pointer to input data). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_length</td><td>Size of the <code>data</code> buffer in bytes (size_t). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The pointer to the SE syscall context that contain a special syscall data (IPC release callback etc).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47" title="Success operation.">IFX_SE_SUCCESS</a></td><td>Success. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga40c10ca60e337c7f6071577c5ce9b108" title="The parameters passed to the function are invalid.">IFX_SE_ERROR_INVALID_ARGUMENT</a></td><td><code>step</code> is not compatible with the operation's algorithm, or <code>step</code> does not allow direct inputs. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaa6d53bc35e03dd93f863cb2687b79546" title="There is not enough runtime memory.">IFX_SE_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaee4d9090ad3ca96300447d0368092cbe" title="There was a communication failure inside the implementation.">IFX_SE_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga06d90cd8966c5061f118ca580d76a2e0" title="A hardware failure was detected.">IFX_SE_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga90718ef69f96a0ff2b2877f65e58a3e1" title="A tampering attempt was detected.">IFX_SE_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gadbe9aa2de2448391e663c45506ada4e0" title="There was a storage failure that may have led to data loss.">IFX_SE_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga3a99268d483c4255eb0368d879ecfc7a" title="The requested action cannot be performed in the current state.">IFX_SE_ERROR_BAD_STATE</a></td><td>The operation state is not valid for this input <code>step</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga103033116e74486ea161e764e7b28fcd" name="ga103033116e74486ea161e764e7b28fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga103033116e74486ea161e764e7b28fcd">&#9670;&nbsp;</a></span>ifx_se_key_derivation_output_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a> ifx_se_key_derivation_output_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a>&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fih.html#ga3f01e5cacf10e2e35af27096b162037a">ifx_se_fih_t</a>&#160;</td>
          <td class="paramname"><em>output_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read some data from a key derivation operation. </p>
<p >This function calculates output bytes from a key derivation algorithm and return those bytes. If you view the key derivation's output as a stream of bytes, this function destructively reads the requested number of bytes from the stream. The operation's capacity decreases by the number of bytes read.</p>
<p >If this function returns an error status other than <a class="el" href="group__psacrypto__error.html#ga049f222176a2260f8735409c4426bcc3" title="Return this error when there&#39;s insufficient data when attempting to read from a resource.">IFX_SE_ERROR_INSUFFICIENT_DATA</a>, the operation enters an error state and must be aborted by calling <a class="el" href="group__key__derivation.html#gaa4c3f9a1959b6403be6021f0d16c6105" title="Abort a key derivation operation.">ifx_se_key_derivation_abort()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>The key derivation operation object to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Buffer where the output will be written (encoded pointer to output buffer). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_length</td><td>Number of bytes to output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The pointer to the SE syscall context that contain a special syscall data (IPC release callback etc).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47" title="Success operation.">IFX_SE_SUCCESS</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga61a9aad149daa181f3e15f63b778e8e7" title="The requested action is denied by a policy.">IFX_SE_ERROR_NOT_PERMITTED</a></td><td>One of the inputs was a key whose policy didn't allow <a class="el" href="group__key__policy.html#ga70772b0c644888fb60605bfddd86f1bb" title="Whether the key may be used to derive other keys or produce a password hash.">IFX_SE_KEY_USAGE_DERIVE</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga049f222176a2260f8735409c4426bcc3" title="Return this error when there&#39;s insufficient data when attempting to read from a resource.">IFX_SE_ERROR_INSUFFICIENT_DATA</a></td><td>The operation's capacity was less than <code>output_length</code> bytes. Note that in this case, no output is written to the output buffer. The operation's capacity is set to 0, thus subsequent calls to this function will not succeed, even with a smaller output buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaa6d53bc35e03dd93f863cb2687b79546" title="There is not enough runtime memory.">IFX_SE_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaee4d9090ad3ca96300447d0368092cbe" title="There was a communication failure inside the implementation.">IFX_SE_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga06d90cd8966c5061f118ca580d76a2e0" title="A hardware failure was detected.">IFX_SE_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga90718ef69f96a0ff2b2877f65e58a3e1" title="A tampering attempt was detected.">IFX_SE_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gadbe9aa2de2448391e663c45506ada4e0" title="There was a storage failure that may have led to data loss.">IFX_SE_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga3a99268d483c4255eb0368d879ecfc7a" title="The requested action cannot be performed in the current state.">IFX_SE_ERROR_BAD_STATE</a></td><td>The operation state is not valid (it must be active and completed all required input steps). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga454b8a7f1df96b26ec407b6e133eb4e6" name="ga454b8a7f1df96b26ec407b6e133eb4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga454b8a7f1df96b26ec407b6e133eb4e6">&#9670;&nbsp;</a></span>ifx_se_key_derivation_output_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a> ifx_se_key_derivation_output_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__key__attributes.html#gad1ded78e935cd08ba08a5a27c003d7b3">ifx_se_key_attributes_t</a> *&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derive a key from an ongoing key derivation operation. </p>
<p >This function calculates output bytes from a key derivation algorithm and uses those bytes to generate a key deterministically. The key's location, usage policy, type and size are taken from <code>attributes</code>.</p>
<p >If you view the key derivation's output as a stream of bytes, this function destructively reads as many bytes as required from the stream. The operation's capacity decreases by the number of bytes read.</p>
<p >If this function returns an error status other than <a class="el" href="group__psacrypto__error.html#ga049f222176a2260f8735409c4426bcc3" title="Return this error when there&#39;s insufficient data when attempting to read from a resource.">IFX_SE_ERROR_INSUFFICIENT_DATA</a>, the operation enters an error state and must be aborted by calling <a class="el" href="group__key__derivation.html#gaa4c3f9a1959b6403be6021f0d16c6105" title="Abort a key derivation operation.">ifx_se_key_derivation_abort()</a>.</p>
<p >How much output is produced and consumed from the operation, and how the key is derived, depends on the key type and on the key size (denoted <code>bits</code> below):</p>
<ul>
<li>For key types for which the key is an arbitrary sequence of bytes of a given size, this function is functionally equivalent to calling <a class="el" href="group__key__derivation.html#ga103033116e74486ea161e764e7b28fcd" title="Read some data from a key derivation operation.">ifx_se_key_derivation_output_bytes</a> and passing the resulting output to <a class="el" href="group__import__export.html#ga8c4b3683086bedb13cf0ceb6f6b2c1f6" title="Import a key in binary format.">ifx_se_import_key</a>. However, this function has a security benefit: if the implementation provides an isolation boundary then the key material is not exposed outside the isolation boundary. As a consequence, for these key types, this function always consumes exactly (<code>bits</code> / 8) bytes from the operation. The following key types defined in this specification follow this scheme:<ul>
<li><a class="el" href="group__crypto__types.html#ga666a9c5f33dc3223aa48bea5a038c61b" title="Key for a cipher, AEAD or MAC algorithm based on the AES block cipher.">IFX_SE_KEY_TYPE_AES</a>;</li>
<li><a class="el" href="group__crypto__types.html#ga0df32d9dad694429c2194fad80b0ed4c" title="Key for a cipher, AEAD or MAC algorithm based on the ARIA block cipher.">IFX_SE_KEY_TYPE_ARIA</a>;</li>
<li><a class="el" href="group__crypto__types.html#ga57486c019510acdc11cd3645b5ce5487" title="Key for a cipher, AEAD or MAC algorithm based on the Camellia block cipher.">IFX_SE_KEY_TYPE_CAMELLIA</a>;</li>
<li><a class="el" href="group__crypto__types.html#ga954abb950069b6104f746304e1a17b79" title="A secret for key derivation.">IFX_SE_KEY_TYPE_DERIVE</a>;</li>
<li><a class="el" href="group__crypto__types.html#gac6b7eefd436c63341115e2a7d61fa1df" title="HMAC key.">IFX_SE_KEY_TYPE_HMAC</a>;</li>
<li><a class="el" href="group__crypto__types.html#ga1e7258c4c49b804ea349b77722af86a8" title="A secret value that can be used to verify a password hash.">IFX_SE_KEY_TYPE_PASSWORD_HASH</a>.</li>
</ul>
</li>
<li>For ECC keys on a Montgomery elliptic curve (<a class="el" href="group__crypto__types.html#gae6c9176de74920d61e06da98db9f42df" title="Elliptic curve key pair.">IFX_SE_KEY_TYPE_ECC_KEY_PAIR</a>(<code>curve</code>) where <code>curve</code> designates a Montgomery curve), this function always draws a byte string whose length is determined by the curve, and sets the mandatory bits accordingly. That is:<ul>
<li>Curve25519 (<a class="el" href="group__crypto__types.html#gab3d64458e79de9c522c3e93059101f64" title="Curve25519 and Curve448.">IFX_SE_ECC_FAMILY_MONTGOMERY</a>, 255 bits): draw a 32-byte string and process it as specified in RFC 7748 &sect;5.</li>
<li>Curve448 (<a class="el" href="group__crypto__types.html#gab3d64458e79de9c522c3e93059101f64" title="Curve25519 and Curve448.">IFX_SE_ECC_FAMILY_MONTGOMERY</a>, 448 bits): draw a 56-byte string and process it as specified in RFC 7748 &sect;5.</li>
</ul>
</li>
<li>For key types for which the key is represented by a single sequence of <code>bits</code> bits with constraints as to which bit sequences are acceptable, this function draws a byte string of length (<code>bits</code> / 8) bytes rounded up to the nearest whole number of bytes. If the resulting byte string is acceptable, it becomes the key, otherwise the drawn bytes are discarded. This process is repeated until an acceptable byte string is drawn. The byte string drawn from the operation is interpreted as specified for the output produced by <a class="el" href="group__import__export.html#ga4a53bdb503a45522b6555cc255364759" title="Export a key in binary format.">ifx_se_export_key()</a>. The following key types defined in this specification follow this scheme:<ul>
<li><a class="el" href="group__crypto__types.html#ga5fd36fb39629d7cef8d96c108c3211a8" title="Key for a cipher or MAC algorithm based on DES or 3DES (Triple-DES).">IFX_SE_KEY_TYPE_DES</a>. Force-set the parity bits, but discard forbidden weak keys. For 2-key and 3-key triple-DES, the three keys are generated successively (for example, for 3-key triple-DES, if the first 8 bytes specify a weak key and the next 8 bytes do not, discard the first 8 bytes, use the next 8 bytes as the first key, and continue reading output from the operation to derive the other two keys).</li>
<li>Finite-field Diffie-Hellman keys (<a class="el" href="group__crypto__types.html#gaedd39a8381474f7f03dc729b923ade51" title="Diffie-Hellman key pair.">IFX_SE_KEY_TYPE_DH_KEY_PAIR</a>(<code>group</code>) where <code>group</code> designates any Diffie-Hellman group) and ECC keys on a Weierstrass elliptic curve (<a class="el" href="group__crypto__types.html#gae6c9176de74920d61e06da98db9f42df" title="Elliptic curve key pair.">IFX_SE_KEY_TYPE_ECC_KEY_PAIR</a>(<code>curve</code>) where <code>curve</code> designates a Weierstrass curve). For these key types, interpret the byte string as integer in big-endian order. Discard it if it is not in the range [0, <em>N</em> - 2] where <em>N</em> is the boundary of the private key domain (the prime <em>p</em> for Diffie-Hellman, the subprime <em>q</em> for DSA, or the order of the curve's base point for ECC). Add 1 to the resulting integer and use this as the private key <em>x</em>. This method allows compliance to NIST standards, specifically the methods titled "key-pair generation by testing candidates" in NIST SP 800-56A &sect;5.6.1.1.4 for Diffie-Hellman, in FIPS 186-4 &sect;B.1.2 for DSA, and in NIST SP 800-56A &sect;5.6.1.2.2 or FIPS 186-4 &sect;B.4.2 for elliptic curve keys.</li>
</ul>
</li>
<li>For other key types, including <a class="el" href="group__crypto__types.html#gab822af2ec3721c13eb05b9ad261ef3ee" title="RSA key pair (private and public key).">IFX_SE_KEY_TYPE_RSA_KEY_PAIR</a>, the way in which the operation output is consumed is implementation-defined.</li>
</ul>
<p >In all cases, the data that is read is discarded from the operation. The operation's capacity is decreased by the number of bytes read.</p>
<p >For algorithms that take an input step <a class="el" href="group__key__derivation.html#gac670b2115b71ff7c5b517bb6e90bb0ed" title="A secret input for key derivation.">IFX_SE_KEY_DERIVATION_INPUT_SECRET</a>, the input to that step must be provided with <a class="el" href="group__key__derivation.html#gaa70ea4b4e0435634b8c6df52aaab0f64" title="Provide an input for key derivation in the form of a key.">ifx_se_key_derivation_input_key()</a>. Future versions of this specification may include additional restrictions on the derived key based on the attributes and strength of the secret key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attributes</td><td>The attributes for the new key. If the key type to be created is <a class="el" href="group__crypto__types.html#ga1e7258c4c49b804ea349b77722af86a8" title="A secret value that can be used to verify a password hash.">IFX_SE_KEY_TYPE_PASSWORD_HASH</a> then the algorithm in the policy must be the same as in the current operation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>The key derivation operation object to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>On success, an identifier for the newly created key (encoded pointer to <a class="el" href="group__key__attributes.html#ga40f81e5fa5d5b8c64b81b49d60ccc6dc" title="The type of the of keys identifier transfer data.">ifx_se_key_id_fih_t</a> variable). For persistent keys, this is the key identifier defined in <code>attributes</code>. <code>0</code> on failure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The pointer to the SE syscall context that contain a special syscall data (IPC release callback etc).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47" title="Success operation.">IFX_SE_SUCCESS</a></td><td>Success. If the key is persistent, the key material and the key's metadata have been saved to persistent storage. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga5f106d0be31d45029271a9b859f945c7" title="Asking for an item that already exists.">IFX_SE_ERROR_ALREADY_EXISTS</a></td><td>This is an attempt to create a persistent key, and there is already a persistent key with the given identifier. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga049f222176a2260f8735409c4426bcc3" title="Return this error when there&#39;s insufficient data when attempting to read from a resource.">IFX_SE_ERROR_INSUFFICIENT_DATA</a></td><td>There was not enough data to create the desired key. Note that in this case, no output is written to the output buffer. The operation's capacity is set to 0, thus subsequent calls to this function will not succeed, even with a smaller output buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gae3392ff6990c04e50c7fcfd34bc60f2f" title="The requested operation or a parameter is not supported by this implementation.">IFX_SE_ERROR_NOT_SUPPORTED</a></td><td>The key type or key size is not supported, either by the implementation in general or in this particular location. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga40c10ca60e337c7f6071577c5ce9b108" title="The parameters passed to the function are invalid.">IFX_SE_ERROR_INVALID_ARGUMENT</a></td><td>The provided key attributes are not valid for the operation. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga61a9aad149daa181f3e15f63b778e8e7" title="The requested action is denied by a policy.">IFX_SE_ERROR_NOT_PERMITTED</a></td><td>The <a class="el" href="group__key__derivation.html#gac670b2115b71ff7c5b517bb6e90bb0ed" title="A secret input for key derivation.">IFX_SE_KEY_DERIVATION_INPUT_SECRET</a> or <a class="el" href="group__key__derivation.html#ga027514f96faf9bc353ccceb78888dc99" title="A low-entropy secret input for password hashing / key stretching.">IFX_SE_KEY_DERIVATION_INPUT_PASSWORD</a> input was not provided through a key; or one of the inputs was a key whose policy didn't allow <a class="el" href="group__key__policy.html#ga70772b0c644888fb60605bfddd86f1bb" title="Whether the key may be used to derive other keys or produce a password hash.">IFX_SE_KEY_USAGE_DERIVE</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaa6d53bc35e03dd93f863cb2687b79546" title="There is not enough runtime memory.">IFX_SE_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga24e6279e65ec7dd4224cf9741265bf06" title="There is not enough persistent storage.">IFX_SE_ERROR_INSUFFICIENT_STORAGE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaee4d9090ad3ca96300447d0368092cbe" title="There was a communication failure inside the implementation.">IFX_SE_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga06d90cd8966c5061f118ca580d76a2e0" title="A hardware failure was detected.">IFX_SE_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga90718ef69f96a0ff2b2877f65e58a3e1" title="A tampering attempt was detected.">IFX_SE_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gace7d14b77fd021177e5ae525d1c1fab2" title="Data read from storage is not valid for the implementation.">IFX_SE_ERROR_DATA_INVALID</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga9af1a17c1068eab5865933aa74fba9f3" title="Stored data has been corrupted.">IFX_SE_ERROR_DATA_CORRUPT</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gadbe9aa2de2448391e663c45506ada4e0" title="There was a storage failure that may have led to data loss.">IFX_SE_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga3a99268d483c4255eb0368d879ecfc7a" title="The requested action cannot be performed in the current state.">IFX_SE_ERROR_BAD_STATE</a></td><td>The operation state is not valid (it must be active and completed all required input steps). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39a911ad2d28e124a069ffa0bd420e46" name="ga39a911ad2d28e124a069ffa0bd420e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39a911ad2d28e124a069ffa0bd420e46">&#9670;&nbsp;</a></span>ifx_se_key_derivation_key_agreement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a> ifx_se_key_derivation_key_agreement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__key__derivation.html#ga9083cc558b17b558d62eaf74f6f699fc">ifx_se_key_derivation_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__key__derivation.html#ga8178cf73cbb1c3dfc41eca4397038200">ifx_se_key_derivation_step_t</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__key__attributes.html#ga40f81e5fa5d5b8c64b81b49d60ccc6dc">ifx_se_key_id_fih_t</a>&#160;</td>
          <td class="paramname"><em>private_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a>&#160;</td>
          <td class="paramname"><em>peer_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fih.html#ga3f01e5cacf10e2e35af27096b162037a">ifx_se_fih_t</a>&#160;</td>
          <td class="paramname"><em>peer_key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a key agreement and use the shared secret as input to a key derivation. </p>
<p >A key agreement algorithm takes two inputs: a private key <code>private_key</code> a public key <code>peer_key</code>. The result of this function is passed as input to a key derivation. The output of this key derivation can be extracted by reading from the resulting operation to produce keys and other cryptographic material.</p>
<p >If this function returns an error status, the operation enters an error state and must be aborted by calling <a class="el" href="group__key__derivation.html#gaa4c3f9a1959b6403be6021f0d16c6105" title="Abort a key derivation operation.">ifx_se_key_derivation_abort()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>The key derivation operation object to use. It must have been set up with <a class="el" href="group__key__derivation.html#gae24279023e83b8eebdec720f2eaa18ad" title="Set up a key derivation operation.">ifx_se_key_derivation_setup()</a> with a key agreement and derivation algorithm <code>alg</code> (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#ga0d3e7ebf3f1412e39ed64ebc99c7c86a" title="Whether the specified algorithm is a key agreement algorithm.">IFX_SE_ALG_IS_KEY_AGREEMENT</a>(<code>alg</code>) is true and <a class="el" href="group__crypto__algs.html#gab3cfe6bc355240097b853cebae8e2d4c" title="Whether the specified algorithm is a raw key agreement algorithm.">IFX_SE_ALG_IS_RAW_KEY_AGREEMENT</a>(<code>alg</code>) is false). The operation must be ready for an input of the type given by <code>step</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>Which step the input data is for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">private_key</td><td>Identifier of the private key to use. It must allow the usage <a class="el" href="group__key__policy.html#ga70772b0c644888fb60605bfddd86f1bb" title="Whether the key may be used to derive other keys or produce a password hash.">IFX_SE_KEY_USAGE_DERIVE</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peer_key</td><td>Public key of the peer (encoded pointer to input data). The peer key must be in the same format that <a class="el" href="group__import__export.html#ga8c4b3683086bedb13cf0ceb6f6b2c1f6" title="Import a key in binary format.">ifx_se_import_key()</a> accepts for the public key type corresponding to the type of private_key. That is, this function performs the equivalent of <a class="el" href="group__import__export.html#ga8c4b3683086bedb13cf0ceb6f6b2c1f6" title="Import a key in binary format.">ifx_se_import_key</a>(..., <code>peer_key</code>, <code>peer_key_length</code>) where with key attributes indicating the public key type corresponding to the type of <code>private_key</code>. For example, for EC keys, this means that peer_key is interpreted as a point on the curve that the private key is on. The standard formats for public keys are documented in the documentation of <a class="el" href="group__import__export.html#ga120a3d6cb22b2a2d438edf1cdebc560f" title="Export a public key or the public part of a key pair in binary format.">ifx_se_export_public_key()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peer_key_length</td><td>Size of <code>peer_key</code> in bytes (size_t). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The pointer to the SE syscall context that contain a special syscall data (IPC release callback etc).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47" title="Success operation.">IFX_SE_SUCCESS</a></td><td>Success. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga4a7a5be0f27e1cf5576df18e6a626c1b" title="The key identifier is not valid.">IFX_SE_ERROR_INVALID_HANDLE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga61a9aad149daa181f3e15f63b778e8e7" title="The requested action is denied by a policy.">IFX_SE_ERROR_NOT_PERMITTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga40c10ca60e337c7f6071577c5ce9b108" title="The parameters passed to the function are invalid.">IFX_SE_ERROR_INVALID_ARGUMENT</a></td><td><code>private_key</code> is not compatible with <code>alg</code>, or <code>peer_key</code> is not valid for <code>alg</code> or not compatible with <code>private_key</code>, or <code>step</code> does not allow an input resulting from a key agreement. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gae3392ff6990c04e50c7fcfd34bc60f2f" title="The requested operation or a parameter is not supported by this implementation.">IFX_SE_ERROR_NOT_SUPPORTED</a></td><td><code>alg</code> is not supported or is not a key derivation algorithm. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaa6d53bc35e03dd93f863cb2687b79546" title="There is not enough runtime memory.">IFX_SE_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaee4d9090ad3ca96300447d0368092cbe" title="There was a communication failure inside the implementation.">IFX_SE_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga06d90cd8966c5061f118ca580d76a2e0" title="A hardware failure was detected.">IFX_SE_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga90718ef69f96a0ff2b2877f65e58a3e1" title="A tampering attempt was detected.">IFX_SE_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gadbe9aa2de2448391e663c45506ada4e0" title="There was a storage failure that may have led to data loss.">IFX_SE_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga3a99268d483c4255eb0368d879ecfc7a" title="The requested action cannot be performed in the current state.">IFX_SE_ERROR_BAD_STATE</a></td><td>The operation state is not valid for this key agreement <code>step</code>, or the library has not been previously initialized by ifx_se_crypto_init(). It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad36f8eff1151d8ae5b9a9e204cd32c3" name="gaad36f8eff1151d8ae5b9a9e204cd32c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad36f8eff1151d8ae5b9a9e204cd32c3">&#9670;&nbsp;</a></span>ifx_se_raw_key_agreement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a> ifx_se_raw_key_agreement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fih.html#gae48734cc37441057b24896ec06080819">ifx_se_alg_fih_t</a>&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__key__attributes.html#ga40f81e5fa5d5b8c64b81b49d60ccc6dc">ifx_se_key_id_fih_t</a>&#160;</td>
          <td class="paramname"><em>private_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a>&#160;</td>
          <td class="paramname"><em>peer_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fih.html#ga3f01e5cacf10e2e35af27096b162037a">ifx_se_fih_t</a>&#160;</td>
          <td class="paramname"><em>peer_key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a>&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fih.html#ga3f01e5cacf10e2e35af27096b162037a">ifx_se_fih_t</a>&#160;</td>
          <td class="paramname"><em>output_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fih.html#structifx__se__fih__ptr__t">ifx_se_fih_ptr_t</a>&#160;</td>
          <td class="paramname"><em>output_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a key agreement and return the raw shared secret. </p>
<dl class="section warning"><dt>Warning</dt><dd>The raw result of a key agreement algorithm such as finite-field Diffie-Hellman or elliptic curve Diffie-Hellman has biases and should not be used directly as key material. It should instead be passed as input to a key derivation algorithm. To chain a key agreement with a key derivation, use <a class="el" href="group__key__derivation.html#ga39a911ad2d28e124a069ffa0bd420e46" title="Perform a key agreement and use the shared secret as input to a key derivation.">ifx_se_key_derivation_key_agreement()</a> and other functions from the key derivation interface.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">alg</td><td>The key agreement algorithm to compute (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#gab3cfe6bc355240097b853cebae8e2d4c" title="Whether the specified algorithm is a raw key agreement algorithm.">IFX_SE_ALG_IS_RAW_KEY_AGREEMENT</a>(<code>alg</code>) is true). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">private_key</td><td>Identifier of the private key to use. It must allow the usage <a class="el" href="group__key__policy.html#ga70772b0c644888fb60605bfddd86f1bb" title="Whether the key may be used to derive other keys or produce a password hash.">IFX_SE_KEY_USAGE_DERIVE</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peer_key</td><td>Public key of the peer (encoded pointer to input data). It must be in the same format that <a class="el" href="group__import__export.html#ga8c4b3683086bedb13cf0ceb6f6b2c1f6" title="Import a key in binary format.">ifx_se_import_key()</a> accepts. The standard formats for public keys are documented in the documentation of <a class="el" href="group__import__export.html#ga120a3d6cb22b2a2d438edf1cdebc560f" title="Export a public key or the public part of a key pair in binary format.">ifx_se_export_public_key()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peer_key_length</td><td>Size of <code>peer_key</code> in bytes (size_t). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Buffer where the raw shared secret is to be written (encoded pointer to output buffer). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_size</td><td>Size of the <code>output</code> buffer in bytes (size_t). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_length</td><td>On success, the number of bytes that make up the returned output (encoded pointer to size_t variable). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The pointer to the SE syscall context that contain a special syscall data (IPC release callback etc).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47" title="Success operation.">IFX_SE_SUCCESS</a></td><td>Success. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga4a7a5be0f27e1cf5576df18e6a626c1b" title="The key identifier is not valid.">IFX_SE_ERROR_INVALID_HANDLE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga61a9aad149daa181f3e15f63b778e8e7" title="The requested action is denied by a policy.">IFX_SE_ERROR_NOT_PERMITTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga40c10ca60e337c7f6071577c5ce9b108" title="The parameters passed to the function are invalid.">IFX_SE_ERROR_INVALID_ARGUMENT</a></td><td><code>alg</code> is not a key agreement algorithm, or <code>private_key</code> is not compatible with <code>alg</code>, or <code>peer_key</code> is not valid for <code>alg</code> or not compatible with <code>private_key</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga9deeddae437b2f7a9ebf6f030fe00522" title="An output buffer is too small.">IFX_SE_ERROR_BUFFER_TOO_SMALL</a></td><td><code>output_size</code> is too small </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gae3392ff6990c04e50c7fcfd34bc60f2f" title="The requested operation or a parameter is not supported by this implementation.">IFX_SE_ERROR_NOT_SUPPORTED</a></td><td><code>alg</code> is not a supported key agreement algorithm. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaa6d53bc35e03dd93f863cb2687b79546" title="There is not enough runtime memory.">IFX_SE_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gaee4d9090ad3ca96300447d0368092cbe" title="There was a communication failure inside the implementation.">IFX_SE_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga06d90cd8966c5061f118ca580d76a2e0" title="A hardware failure was detected.">IFX_SE_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga90718ef69f96a0ff2b2877f65e58a3e1" title="A tampering attempt was detected.">IFX_SE_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#gadbe9aa2de2448391e663c45506ada4e0" title="There was a storage failure that may have led to data loss.">IFX_SE_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__psacrypto__error.html#ga3a99268d483c4255eb0368d879ecfc7a" title="The requested action cannot be performed in the current state.">IFX_SE_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by ifx_se_crypto_init(). It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7d2a63031c941cba0d279ae78d83a0b3" name="ga7d2a63031c941cba0d279ae78d83a0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d2a63031c941cba0d279ae78d83a0b3">&#9670;&nbsp;</a></span>ifx_se_key_derivation_operation_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct ifx_se_key_derivation_s ifx_se_key_derivation_operation_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the key derivation context. </p>
<dl class="section return"><dt>Returns</dt><dd>ifx_se_key_derivation_s structure </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>SE RT Services Utilities library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
