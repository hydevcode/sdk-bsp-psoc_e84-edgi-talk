<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SE RT Services Utilities library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SE RT Services Utilities library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__constants__sizes.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">Data size definitions<div class="ingroups"><a class="el" href="group__psacrypto.html">IFX SE PSA crypto API</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p >Data size definitions. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacf3d12460006bc833f9e0d84155ca86b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gacf3d12460006bc833f9e0d84155ca86b">IFX_SE_HASH_LENGTH</a>(alg)</td></tr>
<tr class="memdesc:gacf3d12460006bc833f9e0d84155ca86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the output of <a class="el" href="group__hash__operations.html#ga70d1bc920c44155d1c25c3a32b44a0bd" title="Finish the calculation of the hash of a message.">ifx_se_hash_finish()</a>, in bytes.  <a href="group__constants__sizes.html#gacf3d12460006bc833f9e0d84155ca86b">More...</a><br /></td></tr>
<tr class="separator:gacf3d12460006bc833f9e0d84155ca86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01aa456863662842e4c04ac7626a1400"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga01aa456863662842e4c04ac7626a1400">IFX_SE_HASH_BLOCK_LENGTH</a>(alg)</td></tr>
<tr class="memdesc:ga01aa456863662842e4c04ac7626a1400"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input block size of a hash algorithm, in bytes.  <a href="group__constants__sizes.html#ga01aa456863662842e4c04ac7626a1400">More...</a><br /></td></tr>
<tr class="separator:ga01aa456863662842e4c04ac7626a1400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13dbde3636480a7b39a2cbddee0a1698"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga13dbde3636480a7b39a2cbddee0a1698">IFX_SE_HASH_MAX_SIZE</a>&#160;&#160;&#160;32u</td></tr>
<tr class="memdesc:ga13dbde3636480a7b39a2cbddee0a1698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of a hash.  <a href="group__constants__sizes.html#ga13dbde3636480a7b39a2cbddee0a1698">More...</a><br /></td></tr>
<tr class="separator:ga13dbde3636480a7b39a2cbddee0a1698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e5c9dcc7656d6e7ef330d96899f452"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga85e5c9dcc7656d6e7ef330d96899f452">IFX_SE_MAC_MAX_SIZE</a>&#160;&#160;&#160;<a class="el" href="group__constants__sizes.html#ga13dbde3636480a7b39a2cbddee0a1698">IFX_SE_HASH_MAX_SIZE</a></td></tr>
<tr class="memdesc:ga85e5c9dcc7656d6e7ef330d96899f452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of a MAC.  <a href="group__constants__sizes.html#ga85e5c9dcc7656d6e7ef330d96899f452">More...</a><br /></td></tr>
<tr class="separator:ga85e5c9dcc7656d6e7ef330d96899f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d620a1aca480b838d59906bc6c4f7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga52d620a1aca480b838d59906bc6c4f7f">IFX_SE_AEAD_TAG_LENGTH</a>(key_type,  key_bits,  alg)</td></tr>
<tr class="memdesc:ga52d620a1aca480b838d59906bc6c4f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of a tag for an AEAD algorithm, in bytes.  <a href="group__constants__sizes.html#ga52d620a1aca480b838d59906bc6c4f7f">More...</a><br /></td></tr>
<tr class="separator:ga52d620a1aca480b838d59906bc6c4f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6591d9decbc41e79aaef7643192bd696"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga6591d9decbc41e79aaef7643192bd696">IFX_SE_AEAD_TAG_MAX_SIZE</a>&#160;&#160;&#160;16u</td></tr>
<tr class="memdesc:ga6591d9decbc41e79aaef7643192bd696"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum tag size for all supported AEAD algorithms, in bytes.  <a href="group__constants__sizes.html#ga6591d9decbc41e79aaef7643192bd696">More...</a><br /></td></tr>
<tr class="separator:ga6591d9decbc41e79aaef7643192bd696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga210e5a934a8c404fa528fc32330b748d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga210e5a934a8c404fa528fc32330b748d">IFX_SE_VENDOR_RSA_MAX_KEY_BITS</a>&#160;&#160;&#160;4096u</td></tr>
<tr class="memdesc:ga210e5a934a8c404fa528fc32330b748d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of an RSA key on this implementation, in bits.  <a href="group__constants__sizes.html#ga210e5a934a8c404fa528fc32330b748d">More...</a><br /></td></tr>
<tr class="separator:ga210e5a934a8c404fa528fc32330b748d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39f5e5fdc4276b750e9e446ffc86d09c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga39f5e5fdc4276b750e9e446ffc86d09c">IFX_SE_VENDOR_ECC_MAX_CURVE_BITS</a>&#160;&#160;&#160;384u</td></tr>
<tr class="memdesc:ga39f5e5fdc4276b750e9e446ffc86d09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of an ECC key on this implementation, in bits.  <a href="group__constants__sizes.html#ga39f5e5fdc4276b750e9e446ffc86d09c">More...</a><br /></td></tr>
<tr class="separator:ga39f5e5fdc4276b750e9e446ffc86d09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4730eb9452405d8b70bfc85e8745037c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga4730eb9452405d8b70bfc85e8745037c">IFX_SE_TLS12_PSK_TO_MS_PSK_MAX_SIZE</a>&#160;&#160;&#160;128u</td></tr>
<tr class="memdesc:ga4730eb9452405d8b70bfc85e8745037c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns the maximum supported length of the PSK for the TLS-1.2 PSK-to-MS key derivation (<a class="el" href="group__crypto__algs.html#ga6833a6db2ee9a48106e35f47ba61f960" title="Macro to build a TLS-1.2 PSK-to-MasterSecret algorithm.">IFX_SE_ALG_TLS12_PSK_TO_MS</a>(<code>hash_alg</code>)).  <a href="group__constants__sizes.html#ga4730eb9452405d8b70bfc85e8745037c">More...</a><br /></td></tr>
<tr class="separator:ga4730eb9452405d8b70bfc85e8745037c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45af326ee82009b61b2d48dbd1048757"><td class="memItemLeft" align="right" valign="top"><a id="ga45af326ee82009b61b2d48dbd1048757" name="ga45af326ee82009b61b2d48dbd1048757"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</b>&#160;&#160;&#160;16u</td></tr>
<tr class="memdesc:ga45af326ee82009b61b2d48dbd1048757"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of a block cipher. <br /></td></tr>
<tr class="separator:ga45af326ee82009b61b2d48dbd1048757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga367279ec4469f4d87c604f82bdd1ef3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga367279ec4469f4d87c604f82bdd1ef3b">IFX_SE_MAC_LENGTH</a>(key_type,  key_bits,  alg)</td></tr>
<tr class="memdesc:ga367279ec4469f4d87c604f82bdd1ef3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the output of <a class="el" href="group__mac__operations.html#ga10989d4f93cdbcb597b8e29ab769db84" title="Finish the calculation of the MAC of a message.">ifx_se_mac_sign_finish()</a>, in bytes.  <a href="group__constants__sizes.html#ga367279ec4469f4d87c604f82bdd1ef3b">More...</a><br /></td></tr>
<tr class="separator:ga367279ec4469f4d87c604f82bdd1ef3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c38388015c7b105bd6e9020836adcf4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga2c38388015c7b105bd6e9020836adcf4">IFX_SE_AEAD_ENCRYPT_OUTPUT_SIZE</a>(key_type,  alg,  plaintext_length)</td></tr>
<tr class="memdesc:ga2c38388015c7b105bd6e9020836adcf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of the output of <a class="el" href="group__aead__operations.html#gafd13261ad6f7c90c49a2d8fc7ad43cf0" title="Process an authenticated encryption operation.">ifx_se_aead_encrypt()</a>, in bytes.  <a href="group__constants__sizes.html#ga2c38388015c7b105bd6e9020836adcf4">More...</a><br /></td></tr>
<tr class="separator:ga2c38388015c7b105bd6e9020836adcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a73783b9da0130c07bca3d0c60b1ee8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga2a73783b9da0130c07bca3d0c60b1ee8">IFX_SE_AEAD_ENCRYPT_OUTPUT_MAX_SIZE</a>(plaintext_length)&#160;&#160;&#160;    ((plaintext_length) + <a class="el" href="group__constants__sizes.html#ga6591d9decbc41e79aaef7643192bd696">IFX_SE_AEAD_TAG_MAX_SIZE</a>)</td></tr>
<tr class="memdesc:ga2a73783b9da0130c07bca3d0c60b1ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient output buffer size for <a class="el" href="group__aead__operations.html#gafd13261ad6f7c90c49a2d8fc7ad43cf0" title="Process an authenticated encryption operation.">ifx_se_aead_encrypt()</a>, for any of the supported key types and AEAD algorithms.  <a href="group__constants__sizes.html#ga2a73783b9da0130c07bca3d0c60b1ee8">More...</a><br /></td></tr>
<tr class="separator:ga2a73783b9da0130c07bca3d0c60b1ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6122d9a995791d57949601534822d8a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga6122d9a995791d57949601534822d8a1">IFX_SE_AEAD_DECRYPT_OUTPUT_SIZE</a>(key_type,  alg,  ciphertext_length)</td></tr>
<tr class="memdesc:ga6122d9a995791d57949601534822d8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of the output of <a class="el" href="group__aead__operations.html#gad2df9a6ff46e11fdc3b2102052102ca7" title="Process an authenticated decryption operation.">ifx_se_aead_decrypt()</a>, in bytes.  <a href="group__constants__sizes.html#ga6122d9a995791d57949601534822d8a1">More...</a><br /></td></tr>
<tr class="separator:ga6122d9a995791d57949601534822d8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce2ffa19d267d9d53f2617fd1ab2e60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gadce2ffa19d267d9d53f2617fd1ab2e60">IFX_SE_AEAD_DECRYPT_OUTPUT_MAX_SIZE</a>(ciphertext_length)&#160;&#160;&#160;     (ciphertext_length)</td></tr>
<tr class="memdesc:gadce2ffa19d267d9d53f2617fd1ab2e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient output buffer size for <a class="el" href="group__aead__operations.html#gad2df9a6ff46e11fdc3b2102052102ca7" title="Process an authenticated decryption operation.">ifx_se_aead_decrypt()</a>, for any of the supported key types and AEAD algorithms.  <a href="group__constants__sizes.html#gadce2ffa19d267d9d53f2617fd1ab2e60">More...</a><br /></td></tr>
<tr class="separator:gadce2ffa19d267d9d53f2617fd1ab2e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43719e5e58b2600aea95d1d9f46accfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga43719e5e58b2600aea95d1d9f46accfc">IFX_SE_AEAD_NONCE_LENGTH</a>(key_type,  alg)</td></tr>
<tr class="memdesc:ga43719e5e58b2600aea95d1d9f46accfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default nonce size for an AEAD algorithm, in bytes.  <a href="group__constants__sizes.html#ga43719e5e58b2600aea95d1d9f46accfc">More...</a><br /></td></tr>
<tr class="separator:ga43719e5e58b2600aea95d1d9f46accfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b03a104ec896af5607d1a2be56e9a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga52b03a104ec896af5607d1a2be56e9a5">IFX_SE_AEAD_NONCE_MAX_SIZE</a>&#160;&#160;&#160;13u</td></tr>
<tr class="memdesc:ga52b03a104ec896af5607d1a2be56e9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum default nonce size among all supported pairs of key types and AEAD algorithms, in bytes.  <a href="group__constants__sizes.html#ga52b03a104ec896af5607d1a2be56e9a5">More...</a><br /></td></tr>
<tr class="separator:ga52b03a104ec896af5607d1a2be56e9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f8444c61884d0b1e6f210abecd2b22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gab8f8444c61884d0b1e6f210abecd2b22">IFX_SE_AEAD_UPDATE_OUTPUT_SIZE</a>(key_type,  alg,  input_length)</td></tr>
<tr class="memdesc:gab8f8444c61884d0b1e6f210abecd2b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient output buffer size for <a class="el" href="group__aead__operations.html#ga088505209fac640f5de807198d4f16bd" title="Encrypt or decrypt a message fragment in an active AEAD operation.">ifx_se_aead_update()</a>.  <a href="group__constants__sizes.html#gab8f8444c61884d0b1e6f210abecd2b22">More...</a><br /></td></tr>
<tr class="separator:gab8f8444c61884d0b1e6f210abecd2b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce84030bb402e16e2abec0f5da32f3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gadce84030bb402e16e2abec0f5da32f3b">IFX_SE_AEAD_UPDATE_OUTPUT_MAX_SIZE</a>(input_length)&#160;&#160;&#160;    (IFX_SE_ROUND_UP_TO_MULTIPLE(<a class="el" href="group__constants__sizes.html#ga45af326ee82009b61b2d48dbd1048757">IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</a>, (input_length)))</td></tr>
<tr class="memdesc:gadce84030bb402e16e2abec0f5da32f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient output buffer size for <a class="el" href="group__aead__operations.html#ga088505209fac640f5de807198d4f16bd" title="Encrypt or decrypt a message fragment in an active AEAD operation.">ifx_se_aead_update()</a>, for any of the supported key types and AEAD algorithms.  <a href="group__constants__sizes.html#gadce84030bb402e16e2abec0f5da32f3b">More...</a><br /></td></tr>
<tr class="separator:gadce84030bb402e16e2abec0f5da32f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dcccf0e8f57e2b61636da7531347b96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga0dcccf0e8f57e2b61636da7531347b96">IFX_SE_AEAD_FINISH_OUTPUT_SIZE</a>(key_type,  alg)</td></tr>
<tr class="memdesc:ga0dcccf0e8f57e2b61636da7531347b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient ciphertext buffer size for <a class="el" href="group__aead__operations.html#gacadd06a79d3016fbbe49c624f6de41b9" title="Finish encrypting a message in an AEAD operation.">ifx_se_aead_finish()</a>.  <a href="group__constants__sizes.html#ga0dcccf0e8f57e2b61636da7531347b96">More...</a><br /></td></tr>
<tr class="separator:ga0dcccf0e8f57e2b61636da7531347b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28978e87d066f8157038215f2a3d7245"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga28978e87d066f8157038215f2a3d7245">IFX_SE_AEAD_FINISH_OUTPUT_MAX_SIZE</a>&#160;&#160;&#160;(<a class="el" href="group__constants__sizes.html#ga45af326ee82009b61b2d48dbd1048757">IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</a>)</td></tr>
<tr class="memdesc:ga28978e87d066f8157038215f2a3d7245"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient ciphertext buffer size for <a class="el" href="group__aead__operations.html#gacadd06a79d3016fbbe49c624f6de41b9" title="Finish encrypting a message in an AEAD operation.">ifx_se_aead_finish()</a>, for any of the supported key types and AEAD algorithms.  <a href="group__constants__sizes.html#ga28978e87d066f8157038215f2a3d7245">More...</a><br /></td></tr>
<tr class="separator:ga28978e87d066f8157038215f2a3d7245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4eecf0f99f3eff7a55191a2a3637e70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gaf4eecf0f99f3eff7a55191a2a3637e70">IFX_SE_AEAD_VERIFY_OUTPUT_SIZE</a>(key_type,  alg)</td></tr>
<tr class="memdesc:gaf4eecf0f99f3eff7a55191a2a3637e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient plaintext buffer size for <a class="el" href="group__aead__operations.html#ga2709dc768af62670cbfc7b0259b6f82c" title="Finish authenticating and decrypting a message in an AEAD operation.">ifx_se_aead_verify()</a>.  <a href="group__constants__sizes.html#gaf4eecf0f99f3eff7a55191a2a3637e70">More...</a><br /></td></tr>
<tr class="separator:gaf4eecf0f99f3eff7a55191a2a3637e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cce514238c203a25cfacdc468a744a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga3cce514238c203a25cfacdc468a744a0">IFX_SE_AEAD_VERIFY_OUTPUT_MAX_SIZE</a>&#160;&#160;&#160;(<a class="el" href="group__constants__sizes.html#ga45af326ee82009b61b2d48dbd1048757">IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</a>)</td></tr>
<tr class="memdesc:ga3cce514238c203a25cfacdc468a744a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient plaintext buffer size for <a class="el" href="group__aead__operations.html#ga2709dc768af62670cbfc7b0259b6f82c" title="Finish authenticating and decrypting a message in an AEAD operation.">ifx_se_aead_verify()</a>, for any of the supported key types and AEAD algorithms.  <a href="group__constants__sizes.html#ga3cce514238c203a25cfacdc468a744a0">More...</a><br /></td></tr>
<tr class="separator:ga3cce514238c203a25cfacdc468a744a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab15d9c8f7f362a839301c8187eae78c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gab15d9c8f7f362a839301c8187eae78c5">IFX_SE_ECDSA_SIGNATURE_SIZE</a>(curve_bits)&#160;&#160;&#160;    (IFX_SE_BITS_TO_BYTES(curve_bits) * 2u)</td></tr>
<tr class="memdesc:gab15d9c8f7f362a839301c8187eae78c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDSA signature size for a given curve bit size.  <a href="group__constants__sizes.html#gab15d9c8f7f362a839301c8187eae78c5">More...</a><br /></td></tr>
<tr class="separator:gab15d9c8f7f362a839301c8187eae78c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f947bd48cf391becc3d49d1a16a9813"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga5f947bd48cf391becc3d49d1a16a9813">IFX_SE_SIGN_OUTPUT_SIZE</a>(key_type,  key_bits,  alg)</td></tr>
<tr class="memdesc:ga5f947bd48cf391becc3d49d1a16a9813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sufficient signature buffer size for <a class="el" href="group__async__operations.html#ga9a357621153662289ed7ad1eef7fff1d" title="Sign a hash or short message with a private key.">ifx_se_sign_hash()</a>.  <a href="group__constants__sizes.html#ga5f947bd48cf391becc3d49d1a16a9813">More...</a><br /></td></tr>
<tr class="separator:ga5f947bd48cf391becc3d49d1a16a9813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3320dec942ac856b711debc88579b1d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gac3320dec942ac856b711debc88579b1d">IFX_SE_SIGNATURE_MAX_SIZE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gac3320dec942ac856b711debc88579b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of an asymmetric signature.  <a href="group__constants__sizes.html#gac3320dec942ac856b711debc88579b1d">More...</a><br /></td></tr>
<tr class="separator:gac3320dec942ac856b711debc88579b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3320dec942ac856b711debc88579b1d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gac3320dec942ac856b711debc88579b1d">IFX_SE_SIGNATURE_MAX_SIZE</a>&#160;&#160;&#160;IFX_SE_BITS_TO_BYTES(<a class="el" href="group__constants__sizes.html#ga210e5a934a8c404fa528fc32330b748d">IFX_SE_VENDOR_RSA_MAX_KEY_BITS</a>)</td></tr>
<tr class="memdesc:gac3320dec942ac856b711debc88579b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of an asymmetric signature.  <a href="group__constants__sizes.html#gac3320dec942ac856b711debc88579b1d">More...</a><br /></td></tr>
<tr class="separator:gac3320dec942ac856b711debc88579b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69cd9eb2a526db33495fd9e97db6c988"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga69cd9eb2a526db33495fd9e97db6c988">IFX_SE_KEY_EXPORT_ECC_PUBLIC_KEY_MAX_SIZE</a>(key_bits)&#160;&#160;&#160;    (2u * IFX_SE_BITS_TO_BYTES(key_bits) + 1u)</td></tr>
<tr class="memdesc:ga69cd9eb2a526db33495fd9e97db6c988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of the export encoding of an ECC public key.  <a href="group__constants__sizes.html#ga69cd9eb2a526db33495fd9e97db6c988">More...</a><br /></td></tr>
<tr class="separator:ga69cd9eb2a526db33495fd9e97db6c988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9de7c6911ef3cb793268d442d7520c26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga9de7c6911ef3cb793268d442d7520c26">IFX_SE_KEY_EXPORT_ECC_KEY_PAIR_MAX_SIZE</a>(key_bits)&#160;&#160;&#160;    (IFX_SE_BITS_TO_BYTES(key_bits))</td></tr>
<tr class="memdesc:ga9de7c6911ef3cb793268d442d7520c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of the export encoding of an ECC key pair.  <a href="group__constants__sizes.html#ga9de7c6911ef3cb793268d442d7520c26">More...</a><br /></td></tr>
<tr class="separator:ga9de7c6911ef3cb793268d442d7520c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1222750b6bc259514a3f784cffd01165"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga1222750b6bc259514a3f784cffd01165">IFX_SE_EXPORT_KEY_OUTPUT_SIZE</a>(key_type,  key_bits)</td></tr>
<tr class="memdesc:ga1222750b6bc259514a3f784cffd01165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sufficient output buffer size for <a class="el" href="group__import__export.html#ga4a53bdb503a45522b6555cc255364759" title="Export a key in binary format.">ifx_se_export_key()</a> or <a class="el" href="group__import__export.html#ga120a3d6cb22b2a2d438edf1cdebc560f" title="Export a public key or the public part of a key pair in binary format.">ifx_se_export_public_key()</a>.  <a href="group__constants__sizes.html#ga1222750b6bc259514a3f784cffd01165">More...</a><br /></td></tr>
<tr class="separator:ga1222750b6bc259514a3f784cffd01165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece8655cb723c849956466f8474f10f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gaece8655cb723c849956466f8474f10f9">IFX_SE_EXPORT_PUBLIC_KEY_OUTPUT_SIZE</a>(key_type,  key_bits)</td></tr>
<tr class="memdesc:gaece8655cb723c849956466f8474f10f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sufficient output buffer size for <a class="el" href="group__import__export.html#ga120a3d6cb22b2a2d438edf1cdebc560f" title="Export a public key or the public part of a key pair in binary format.">ifx_se_export_public_key()</a>.  <a href="group__constants__sizes.html#gaece8655cb723c849956466f8474f10f9">More...</a><br /></td></tr>
<tr class="separator:gaece8655cb723c849956466f8474f10f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35e41b3adbcd1ee53ae335c978012d7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga35e41b3adbcd1ee53ae335c978012d7d">IFX_SE_EXPORT_KEY_PAIR_MAX_SIZE</a>&#160;&#160;&#160;     <a class="el" href="group__constants__sizes.html#ga9de7c6911ef3cb793268d442d7520c26">IFX_SE_KEY_EXPORT_ECC_KEY_PAIR_MAX_SIZE</a>(<a class="el" href="group__constants__sizes.html#ga39f5e5fdc4276b750e9e446ffc86d09c">IFX_SE_VENDOR_ECC_MAX_CURVE_BITS</a>)</td></tr>
<tr class="memdesc:ga35e41b3adbcd1ee53ae335c978012d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sufficient buffer size for exporting any asymmetric key pair.  <a href="group__constants__sizes.html#ga35e41b3adbcd1ee53ae335c978012d7d">More...</a><br /></td></tr>
<tr class="separator:ga35e41b3adbcd1ee53ae335c978012d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14163c233baafff5514fd7a3a3e3e4b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga14163c233baafff5514fd7a3a3e3e4b6">IFX_SE_EXPORT_PUBLIC_KEY_MAX_SIZE</a>&#160;&#160;&#160;     <a class="el" href="group__constants__sizes.html#ga69cd9eb2a526db33495fd9e97db6c988">IFX_SE_KEY_EXPORT_ECC_PUBLIC_KEY_MAX_SIZE</a>(<a class="el" href="group__constants__sizes.html#ga39f5e5fdc4276b750e9e446ffc86d09c">IFX_SE_VENDOR_ECC_MAX_CURVE_BITS</a>)</td></tr>
<tr class="memdesc:ga14163c233baafff5514fd7a3a3e3e4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sufficient buffer size for exporting any asymmetric public key.  <a href="group__constants__sizes.html#ga14163c233baafff5514fd7a3a3e3e4b6">More...</a><br /></td></tr>
<tr class="separator:ga14163c233baafff5514fd7a3a3e3e4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7d96d626f91d48517605ecbe0a585ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gad7d96d626f91d48517605ecbe0a585ce">IFX_SE_RAW_KEY_AGREEMENT_OUTPUT_SIZE</a>(key_type,  key_bits)</td></tr>
<tr class="memdesc:gad7d96d626f91d48517605ecbe0a585ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sufficient output buffer size for <a class="el" href="group__key__derivation.html#gaad36f8eff1151d8ae5b9a9e204cd32c3" title="Perform a key agreement and return the raw shared secret.">ifx_se_raw_key_agreement()</a>.  <a href="group__constants__sizes.html#gad7d96d626f91d48517605ecbe0a585ce">More...</a><br /></td></tr>
<tr class="separator:gad7d96d626f91d48517605ecbe0a585ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829bcbdc55e2d936296dae2e0ccc8a0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga829bcbdc55e2d936296dae2e0ccc8a0f">IFX_SE_RAW_KEY_AGREEMENT_OUTPUT_MAX_SIZE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga829bcbdc55e2d936296dae2e0ccc8a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of the output from <a class="el" href="group__key__derivation.html#gaad36f8eff1151d8ae5b9a9e204cd32c3" title="Perform a key agreement and return the raw shared secret.">ifx_se_raw_key_agreement()</a>.  <a href="group__constants__sizes.html#ga829bcbdc55e2d936296dae2e0ccc8a0f">More...</a><br /></td></tr>
<tr class="separator:ga829bcbdc55e2d936296dae2e0ccc8a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829bcbdc55e2d936296dae2e0ccc8a0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga829bcbdc55e2d936296dae2e0ccc8a0f">IFX_SE_RAW_KEY_AGREEMENT_OUTPUT_MAX_SIZE</a>&#160;&#160;&#160;IFX_SE_BITS_TO_BYTES(<a class="el" href="group__constants__sizes.html#ga39f5e5fdc4276b750e9e446ffc86d09c">IFX_SE_VENDOR_ECC_MAX_CURVE_BITS</a>)</td></tr>
<tr class="memdesc:ga829bcbdc55e2d936296dae2e0ccc8a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of the output from <a class="el" href="group__key__derivation.html#gaad36f8eff1151d8ae5b9a9e204cd32c3" title="Perform a key agreement and return the raw shared secret.">ifx_se_raw_key_agreement()</a>.  <a href="group__constants__sizes.html#ga829bcbdc55e2d936296dae2e0ccc8a0f">More...</a><br /></td></tr>
<tr class="separator:ga829bcbdc55e2d936296dae2e0ccc8a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a6ebbb4b75aa5f3f03318786cc120f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga46a6ebbb4b75aa5f3f03318786cc120f">IFX_SE_CIPHER_IV_LENGTH</a>(key_type,  alg)</td></tr>
<tr class="memdesc:ga46a6ebbb4b75aa5f3f03318786cc120f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default IV size for a cipher algorithm, in bytes.  <a href="group__constants__sizes.html#ga46a6ebbb4b75aa5f3f03318786cc120f">More...</a><br /></td></tr>
<tr class="separator:ga46a6ebbb4b75aa5f3f03318786cc120f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932d510c0ff49d175395c01acb03c62d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga932d510c0ff49d175395c01acb03c62d">IFX_SE_CIPHER_IV_MAX_SIZE</a>&#160;&#160;&#160;16u</td></tr>
<tr class="memdesc:ga932d510c0ff49d175395c01acb03c62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum IV size for all supported cipher algorithms, in bytes.  <a href="group__constants__sizes.html#ga932d510c0ff49d175395c01acb03c62d">More...</a><br /></td></tr>
<tr class="separator:ga932d510c0ff49d175395c01acb03c62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe733f9c479459aef5e84608c2e6250"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga5fe733f9c479459aef5e84608c2e6250">IFX_SE_CIPHER_ENCRYPT_OUTPUT_SIZE</a>(key_type,  alg,  input_length)</td></tr>
<tr class="memdesc:ga5fe733f9c479459aef5e84608c2e6250"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of the output of <a class="el" href="group__cipher__operations.html#gaeee781aa1fb49cd63e4ae965236b50e3" title="Encrypt a message using a symmetric cipher with provided IV.">ifx_se_cipher_encrypt()</a>, in bytes.  <a href="group__constants__sizes.html#ga5fe733f9c479459aef5e84608c2e6250">More...</a><br /></td></tr>
<tr class="separator:ga5fe733f9c479459aef5e84608c2e6250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af584fa9db0035c29faa9e97610cd4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga4af584fa9db0035c29faa9e97610cd4f">IFX_SE_CIPHER_ENCRYPT_OUTPUT_MAX_SIZE</a>(input_length)</td></tr>
<tr class="memdesc:ga4af584fa9db0035c29faa9e97610cd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient output buffer size for <a class="el" href="group__cipher__operations.html#gaeee781aa1fb49cd63e4ae965236b50e3" title="Encrypt a message using a symmetric cipher with provided IV.">ifx_se_cipher_encrypt()</a>, for any of the supported key types and cipher algorithms.  <a href="group__constants__sizes.html#ga4af584fa9db0035c29faa9e97610cd4f">More...</a><br /></td></tr>
<tr class="separator:ga4af584fa9db0035c29faa9e97610cd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ea52a825d5762baa0d2b4227c2c852"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gaf2ea52a825d5762baa0d2b4227c2c852">IFX_SE_CIPHER_DECRYPT_OUTPUT_SIZE</a>(key_type,  alg,  input_length)</td></tr>
<tr class="memdesc:gaf2ea52a825d5762baa0d2b4227c2c852"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of the output of <a class="el" href="group__cipher__operations.html#gac7bee80fdabbfdcdf6f7b63589da4f1e" title="Decrypt a message using a symmetric cipher.">ifx_se_cipher_decrypt()</a>, in bytes.  <a href="group__constants__sizes.html#gaf2ea52a825d5762baa0d2b4227c2c852">More...</a><br /></td></tr>
<tr class="separator:gaf2ea52a825d5762baa0d2b4227c2c852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaadeef370df21730b4a379b64c57add0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gaaadeef370df21730b4a379b64c57add0">IFX_SE_CIPHER_DECRYPT_OUTPUT_MAX_SIZE</a>(input_length)&#160;&#160;&#160;    (input_length)</td></tr>
<tr class="memdesc:gaaadeef370df21730b4a379b64c57add0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient output buffer size for <a class="el" href="group__cipher__operations.html#gac7bee80fdabbfdcdf6f7b63589da4f1e" title="Decrypt a message using a symmetric cipher.">ifx_se_cipher_decrypt()</a>, for any of the supported key types and cipher algorithms.  <a href="group__constants__sizes.html#gaaadeef370df21730b4a379b64c57add0">More...</a><br /></td></tr>
<tr class="separator:gaaadeef370df21730b4a379b64c57add0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa948930db4125ccca73ca9b5f260bdb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gaa948930db4125ccca73ca9b5f260bdb1">IFX_SE_CIPHER_UPDATE_OUTPUT_SIZE</a>(key_type,  alg,  input_length)</td></tr>
<tr class="memdesc:gaa948930db4125ccca73ca9b5f260bdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient output buffer size for <a class="el" href="group__cipher__operations.html#ga7b8d71cf584073e170643dbcfb3b65e1" title="Encrypt or decrypt a message fragment in an active cipher operation.">ifx_se_cipher_update()</a>.  <a href="group__constants__sizes.html#gaa948930db4125ccca73ca9b5f260bdb1">More...</a><br /></td></tr>
<tr class="separator:gaa948930db4125ccca73ca9b5f260bdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae039b00e80973aedad17435d6e7272d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#gae039b00e80973aedad17435d6e7272d5">IFX_SE_CIPHER_UPDATE_OUTPUT_MAX_SIZE</a>(input_length)&#160;&#160;&#160;    (IFX_SE_ROUND_UP_TO_MULTIPLE(<a class="el" href="group__constants__sizes.html#ga45af326ee82009b61b2d48dbd1048757">IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</a>, input_length))</td></tr>
<tr class="memdesc:gae039b00e80973aedad17435d6e7272d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient output buffer size for <a class="el" href="group__cipher__operations.html#ga7b8d71cf584073e170643dbcfb3b65e1" title="Encrypt or decrypt a message fragment in an active cipher operation.">ifx_se_cipher_update()</a>, for any of the supported key types and cipher algorithms.  <a href="group__constants__sizes.html#gae039b00e80973aedad17435d6e7272d5">More...</a><br /></td></tr>
<tr class="separator:gae039b00e80973aedad17435d6e7272d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f23e81bf35448d7aad3e29ee11a8a33"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga6f23e81bf35448d7aad3e29ee11a8a33">IFX_SE_CIPHER_FINISH_OUTPUT_SIZE</a>(key_type,  alg)</td></tr>
<tr class="memdesc:ga6f23e81bf35448d7aad3e29ee11a8a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient ciphertext buffer size for <a class="el" href="group__cipher__operations.html#ga966417e3efb26f0453f3c1d93b3b4403" title="Finish encrypting or decrypting a message in a cipher operation.">ifx_se_cipher_finish()</a>.  <a href="group__constants__sizes.html#ga6f23e81bf35448d7aad3e29ee11a8a33">More...</a><br /></td></tr>
<tr class="separator:ga6f23e81bf35448d7aad3e29ee11a8a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga099608392403a28feb1516835c3ff64f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constants__sizes.html#ga099608392403a28feb1516835c3ff64f">IFX_SE_CIPHER_FINISH_OUTPUT_MAX_SIZE</a>&#160;&#160;&#160;    (<a class="el" href="group__constants__sizes.html#ga45af326ee82009b61b2d48dbd1048757">IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</a>)</td></tr>
<tr class="memdesc:ga099608392403a28feb1516835c3ff64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sufficient ciphertext buffer size for <a class="el" href="group__cipher__operations.html#ga966417e3efb26f0453f3c1d93b3b4403" title="Finish encrypting or decrypting a message in a cipher operation.">ifx_se_cipher_finish()</a>, for any of the supported key types and cipher algorithms.  <a href="group__constants__sizes.html#ga099608392403a28feb1516835c3ff64f">More...</a><br /></td></tr>
<tr class="separator:ga099608392403a28feb1516835c3ff64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gacf3d12460006bc833f9e0d84155ca86b" name="gacf3d12460006bc833f9e0d84155ca86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf3d12460006bc833f9e0d84155ca86b">&#9670;&nbsp;</a></span>IFX_SE_HASH_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_HASH_LENGTH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (                                                               \</div>
<div class="line">        IFX_SE_ALG_HMAC_GET_HASH(alg) == <a class="code hl_define" href="group__crypto__algs.html#gadcc8ddfd60433866f8dea0925c1fa1b7">IFX_SE_ALG_SHA_256</a> ? 32u :        \</div>
<div class="line">        IFX_SE_ALG_HMAC_GET_HASH(alg) == <a class="code hl_define" href="group__crypto__algs.html#gab0ca5a481ce3a41667671aaee6079c86">IFX_SE_ALG_SHA_384</a> ? 48u :        \</div>
<div class="line">        IFX_SE_ALG_HMAC_GET_HASH(alg) == <a class="code hl_define" href="group__crypto__algs.html#ga7cd4ddf6333ee3073a479b12bc387389">IFX_SE_ALG_SHA_512</a> ? 64u :        \</div>
<div class="line">        IFX_SE_ALG_HMAC_GET_HASH(alg) == <a class="code hl_define" href="group__crypto__algs.html#gafc7355dededf765d550f1e92b54d6c85">IFX_SE_ALG_SHA_512_224</a> ? 28u :    \</div>
<div class="line">        IFX_SE_ALG_HMAC_GET_HASH(alg) == <a class="code hl_define" href="group__crypto__algs.html#ga819c4028b6b7f08d13168dcc7ff0404f">IFX_SE_ALG_SHA_512_256</a> ? 32u :    \</div>
<div class="line">        0u)</div>
<div class="ttc" id="agroup__crypto__algs_html_ga7cd4ddf6333ee3073a479b12bc387389"><div class="ttname"><a href="group__crypto__algs.html#ga7cd4ddf6333ee3073a479b12bc387389">IFX_SE_ALG_SHA_512</a></div><div class="ttdeci">#define IFX_SE_ALG_SHA_512</div><div class="ttdoc">SHA2-512.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:909</div></div>
<div class="ttc" id="agroup__crypto__algs_html_ga819c4028b6b7f08d13168dcc7ff0404f"><div class="ttname"><a href="group__crypto__algs.html#ga819c4028b6b7f08d13168dcc7ff0404f">IFX_SE_ALG_SHA_512_256</a></div><div class="ttdeci">#define IFX_SE_ALG_SHA_512_256</div><div class="ttdoc">SHA2-512/256.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:913</div></div>
<div class="ttc" id="agroup__crypto__algs_html_gab0ca5a481ce3a41667671aaee6079c86"><div class="ttname"><a href="group__crypto__algs.html#gab0ca5a481ce3a41667671aaee6079c86">IFX_SE_ALG_SHA_384</a></div><div class="ttdeci">#define IFX_SE_ALG_SHA_384</div><div class="ttdoc">SHA2-384.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:907</div></div>
<div class="ttc" id="agroup__crypto__algs_html_gadcc8ddfd60433866f8dea0925c1fa1b7"><div class="ttname"><a href="group__crypto__algs.html#gadcc8ddfd60433866f8dea0925c1fa1b7">IFX_SE_ALG_SHA_256</a></div><div class="ttdeci">#define IFX_SE_ALG_SHA_256</div><div class="ttdoc">SHA2-256.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:905</div></div>
<div class="ttc" id="agroup__crypto__algs_html_gafc7355dededf765d550f1e92b54d6c85"><div class="ttname"><a href="group__crypto__algs.html#gafc7355dededf765d550f1e92b54d6c85">IFX_SE_ALG_SHA_512_224</a></div><div class="ttdeci">#define IFX_SE_ALG_SHA_512_224</div><div class="ttdoc">SHA2-512/224.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:911</div></div>
</div><!-- fragment -->
<p>The size of the output of <a class="el" href="group__hash__operations.html#ga70d1bc920c44155d1c25c3a32b44a0bd" title="Finish the calculation of the hash of a message.">ifx_se_hash_finish()</a>, in bytes. </p>
<p >This is also the hash size that <a class="el" href="group__hash__operations.html#ga6a269c81a11227bd75b0ed32536d03a2" title="Finish the calculation of the hash of a message and compare it with an expected value.">ifx_se_hash_verify()</a> expects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>A hash algorithm (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#ga14193e748272b357afe84b12b95de5a6" title="Whether the specified algorithm is a hash algorithm.">IFX_SE_ALG_IS_HASH</a>(<code>alg</code>) is true), or an HMAC algorithm (<a class="el" href="group__crypto__algs.html#gafc62488c54d17492951cc0d34d5ede05" title="Macro to build an HMAC algorithm.">IFX_SE_ALG_HMAC</a>(<code>hash_alg</code>) where <code>hash_alg</code> is a hash algorithm).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash size for the specified hash algorithm. If the hash algorithm is not recognized, return 0. </dd></dl>

</div>
</div>
<a id="ga01aa456863662842e4c04ac7626a1400" name="ga01aa456863662842e4c04ac7626a1400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01aa456863662842e4c04ac7626a1400">&#9670;&nbsp;</a></span>IFX_SE_HASH_BLOCK_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_HASH_BLOCK_LENGTH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (                                                               \</div>
<div class="line">        IFX_SE_ALG_HMAC_GET_HASH(alg) == <a class="code hl_define" href="group__crypto__algs.html#gadcc8ddfd60433866f8dea0925c1fa1b7">IFX_SE_ALG_SHA_256</a> ? 64u :        \</div>
<div class="line">        IFX_SE_ALG_HMAC_GET_HASH(alg) == <a class="code hl_define" href="group__crypto__algs.html#gab0ca5a481ce3a41667671aaee6079c86">IFX_SE_ALG_SHA_384</a> ? 128u :       \</div>
<div class="line">        IFX_SE_ALG_HMAC_GET_HASH(alg) == <a class="code hl_define" href="group__crypto__algs.html#ga7cd4ddf6333ee3073a479b12bc387389">IFX_SE_ALG_SHA_512</a> ? 128u :       \</div>
<div class="line">        IFX_SE_ALG_HMAC_GET_HASH(alg) == <a class="code hl_define" href="group__crypto__algs.html#gafc7355dededf765d550f1e92b54d6c85">IFX_SE_ALG_SHA_512_224</a> ? 128u :   \</div>
<div class="line">        IFX_SE_ALG_HMAC_GET_HASH(alg) == <a class="code hl_define" href="group__crypto__algs.html#ga819c4028b6b7f08d13168dcc7ff0404f">IFX_SE_ALG_SHA_512_256</a> ? 128u :   \</div>
<div class="line">        0)</div>
</div><!-- fragment -->
<p>The input block size of a hash algorithm, in bytes. </p>
<p >Hash algorithms process their input data in blocks. Hash operations will retain any partial blocks until they have enough input to fill the block or until the operation is finished. This affects the output from ifx_se_hash_suspend().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>A hash algorithm (<code>IFX_SE_ALG_XXX</code> value such that IFX_SE_ALG_IS_HASH(<code>alg</code>) is true).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The block size in bytes for the specified hash algorithm. If the hash algorithm is not recognized, return 0. An implementation can return either 0 or the correct size for a hash algorithm that it recognizes, but does not support. </dd></dl>

</div>
</div>
<a id="ga13dbde3636480a7b39a2cbddee0a1698" name="ga13dbde3636480a7b39a2cbddee0a1698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13dbde3636480a7b39a2cbddee0a1698">&#9670;&nbsp;</a></span>IFX_SE_HASH_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_HASH_MAX_SIZE&#160;&#160;&#160;32u</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size of a hash. </p>
<p >This macro expands to a compile-time constant integer. This value is the maximum size of a hash in bytes. </p>

</div>
</div>
<a id="ga85e5c9dcc7656d6e7ef330d96899f452" name="ga85e5c9dcc7656d6e7ef330d96899f452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85e5c9dcc7656d6e7ef330d96899f452">&#9670;&nbsp;</a></span>IFX_SE_MAC_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_MAC_MAX_SIZE&#160;&#160;&#160;<a class="el" href="group__constants__sizes.html#ga13dbde3636480a7b39a2cbddee0a1698">IFX_SE_HASH_MAX_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size of a MAC. </p>
<p >This macro expands to a compile-time constant integer. This value is the maximum size of a MAC in bytes. </p>

</div>
</div>
<a id="ga52d620a1aca480b838d59906bc6c4f7f" name="ga52d620a1aca480b838d59906bc6c4f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52d620a1aca480b838d59906bc6c4f7f">&#9670;&nbsp;</a></span>IFX_SE_AEAD_TAG_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_TAG_LENGTH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_bits, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__constants__sizes.html#ga43719e5e58b2600aea95d1d9f46accfc">IFX_SE_AEAD_NONCE_LENGTH</a>(key_type, alg) != 0 ?                            \</div>
<div class="line">     IFX_SE_ALG_AEAD_GET_TAG_LENGTH(alg) :                                     \</div>
<div class="line">     ((void) (key_bits), 0u))</div>
<div class="ttc" id="agroup__constants__sizes_html_ga43719e5e58b2600aea95d1d9f46accfc"><div class="ttname"><a href="group__constants__sizes.html#ga43719e5e58b2600aea95d1d9f46accfc">IFX_SE_AEAD_NONCE_LENGTH</a></div><div class="ttdeci">#define IFX_SE_AEAD_NONCE_LENGTH(key_type, alg)</div><div class="ttdoc">The default nonce size for an AEAD algorithm, in bytes.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_sizes.h:380</div></div>
</div><!-- fragment -->
<p>The length of a tag for an AEAD algorithm, in bytes. </p>
<p >This macro can be used to allocate a buffer of sufficient size to store the tag output from <a class="el" href="group__aead__operations.html#gacadd06a79d3016fbbe49c624f6de41b9" title="Finish encrypting a message in an AEAD operation.">ifx_se_aead_finish()</a>.</p>
<p >See also <a class="el" href="group__constants__sizes.html#ga6591d9decbc41e79aaef7643192bd696" title="The maximum tag size for all supported AEAD algorithms, in bytes.">IFX_SE_AEAD_TAG_MAX_SIZE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>The type of the AEAD key. </td></tr>
    <tr><td class="paramname">key_bits</td><td>The size of the AEAD key in bits. </td></tr>
    <tr><td class="paramname">alg</td><td>An AEAD algorithm (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#gad2180b8e6448f4b12f28b9a066ab21c3" title="Whether the specified algorithm is an authenticated encryption with associated data (AEAD) algorithm.">IFX_SE_ALG_IS_AEAD</a>(<code>alg</code>) is true).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tag length for the specified algorithm and key. If the AEAD algorithm does not have an identified tag that can be distinguished from the rest of the ciphertext, return 0. If the key type or AEAD algorithm is not recognized, or the parameters are incompatible, return 0. </dd></dl>

</div>
</div>
<a id="ga6591d9decbc41e79aaef7643192bd696" name="ga6591d9decbc41e79aaef7643192bd696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6591d9decbc41e79aaef7643192bd696">&#9670;&nbsp;</a></span>IFX_SE_AEAD_TAG_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_TAG_MAX_SIZE&#160;&#160;&#160;16u</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum tag size for all supported AEAD algorithms, in bytes. </p>
<p >See also <a class="el" href="group__constants__sizes.html#ga52d620a1aca480b838d59906bc6c4f7f" title="The length of a tag for an AEAD algorithm, in bytes.">IFX_SE_AEAD_TAG_LENGTH</a>(<code>key_type</code>, <code>key_bits</code>, <code>alg</code>). </p>

</div>
</div>
<a id="ga210e5a934a8c404fa528fc32330b748d" name="ga210e5a934a8c404fa528fc32330b748d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga210e5a934a8c404fa528fc32330b748d">&#9670;&nbsp;</a></span>IFX_SE_VENDOR_RSA_MAX_KEY_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_VENDOR_RSA_MAX_KEY_BITS&#160;&#160;&#160;4096u</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum size of an RSA key on this implementation, in bits. </p>
<p >This is a vendor-specific macro.</p>
<p >Mbed TLS does not set a hard limit on the size of RSA keys: any key whose parameters fit in a bignum is accepted. However large keys can induce a large memory usage and long computation times. Unlike other auxiliary macros in this file and in crypto.h, which reflect how the library is configured, this macro defines how the library is configured. This implementation refuses to import or generate an RSA key whose size is larger than the value defined here.</p>
<p >Note that an implementation may set different size limits for different operations, and does not need to accept all key sizes up to the limit. </p>

</div>
</div>
<a id="ga39f5e5fdc4276b750e9e446ffc86d09c" name="ga39f5e5fdc4276b750e9e446ffc86d09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39f5e5fdc4276b750e9e446ffc86d09c">&#9670;&nbsp;</a></span>IFX_SE_VENDOR_ECC_MAX_CURVE_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_VENDOR_ECC_MAX_CURVE_BITS&#160;&#160;&#160;384u</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum size of an ECC key on this implementation, in bits. </p>
<p >This is a vendor-specific macro. </p>

</div>
</div>
<a id="ga4730eb9452405d8b70bfc85e8745037c" name="ga4730eb9452405d8b70bfc85e8745037c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4730eb9452405d8b70bfc85e8745037c">&#9670;&nbsp;</a></span>IFX_SE_TLS12_PSK_TO_MS_PSK_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_TLS12_PSK_TO_MS_PSK_MAX_SIZE&#160;&#160;&#160;128u</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro returns the maximum supported length of the PSK for the TLS-1.2 PSK-to-MS key derivation (<a class="el" href="group__crypto__algs.html#ga6833a6db2ee9a48106e35f47ba61f960" title="Macro to build a TLS-1.2 PSK-to-MasterSecret algorithm.">IFX_SE_ALG_TLS12_PSK_TO_MS</a>(<code>hash_alg</code>)). </p>
<p >The maximum supported length does not depend on the chosen hash algorithm.</p>
<p >Quoting RFC 4279, Sect 5.3: TLS implementations supporting these ciphersuites MUST support arbitrary PSK identities up to 128 octets in length, and arbitrary PSKs up to 64 octets in length. Supporting longer identities and keys is RECOMMENDED.</p>
<p >Therefore, no implementation should define a value smaller than 64 for <a class="el" href="group__constants__sizes.html#ga4730eb9452405d8b70bfc85e8745037c" title="This macro returns the maximum supported length of the PSK for the TLS-1.2 PSK-to-MS key derivation (...">IFX_SE_TLS12_PSK_TO_MS_PSK_MAX_SIZE</a>. </p>

</div>
</div>
<a id="ga367279ec4469f4d87c604f82bdd1ef3b" name="ga367279ec4469f4d87c604f82bdd1ef3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga367279ec4469f4d87c604f82bdd1ef3b">&#9670;&nbsp;</a></span>IFX_SE_MAC_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_MAC_LENGTH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_bits, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((alg) &amp; <a class="code hl_define" href="group__crypto__algs.html#gadf31687d48992fa20e71f48d5a1e9a94">IFX_SE_ALG_MAC_TRUNCATION_MASK</a> ? <a class="code hl_define" href="group__crypto__algs.html#gab984c06f7d9e2695e1b7ffaf9de21be7">IFX_SE_MAC_TRUNCATED_LENGTH</a>(alg) :        \</div>
<div class="line">     IFX_SE_ALG_IS_HMAC(alg) ? <a class="code hl_define" href="group__constants__sizes.html#gacf3d12460006bc833f9e0d84155ca86b">IFX_SE_HASH_LENGTH</a>(IFX_SE_ALG_HMAC_GET_HASH(alg)) :         \</div>
<div class="line">     <a class="code hl_define" href="group__crypto__algs.html#gab4971fc50d25eed55f8bc4f9ab0b2408">IFX_SE_ALG_IS_BLOCK_CIPHER_MAC</a>(alg) ? <a class="code hl_define" href="group__crypto__types.html#ga249c8f65fc5e3a56a2d22981987bdfb2">IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH</a>(key_type) : \</div>
<div class="line">     ((void)(key_type), (void)(key_bits), 0u))</div>
<div class="ttc" id="agroup__constants__sizes_html_gacf3d12460006bc833f9e0d84155ca86b"><div class="ttname"><a href="group__constants__sizes.html#gacf3d12460006bc833f9e0d84155ca86b">IFX_SE_HASH_LENGTH</a></div><div class="ttdeci">#define IFX_SE_HASH_LENGTH(alg)</div><div class="ttdoc">The size of the output of ifx_se_hash_finish(), in bytes.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_sizes.h:82</div></div>
<div class="ttc" id="agroup__crypto__algs_html_gab4971fc50d25eed55f8bc4f9ab0b2408"><div class="ttname"><a href="group__crypto__algs.html#gab4971fc50d25eed55f8bc4f9ab0b2408">IFX_SE_ALG_IS_BLOCK_CIPHER_MAC</a></div><div class="ttdeci">#define IFX_SE_ALG_IS_BLOCK_CIPHER_MAC(alg)</div><div class="ttdoc">Whether the specified algorithm is a MAC algorithm based on a block cipher.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:1137</div></div>
<div class="ttc" id="agroup__crypto__algs_html_gab984c06f7d9e2695e1b7ffaf9de21be7"><div class="ttname"><a href="group__crypto__algs.html#gab984c06f7d9e2695e1b7ffaf9de21be7">IFX_SE_MAC_TRUNCATED_LENGTH</a></div><div class="ttdeci">#define IFX_SE_MAC_TRUNCATED_LENGTH(mac_alg)</div><div class="ttdoc">Length to which a MAC algorithm is truncated.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:1083</div></div>
<div class="ttc" id="agroup__crypto__algs_html_gadf31687d48992fa20e71f48d5a1e9a94"><div class="ttname"><a href="group__crypto__algs.html#gadf31687d48992fa20e71f48d5a1e9a94">IFX_SE_ALG_MAC_TRUNCATION_MASK</a></div><div class="ttdeci">#define IFX_SE_ALG_MAC_TRUNCATION_MASK</div><div class="ttdoc">In the encoding of a MAC algorithm, the bits corresponding to IFX_SE_ALG_MAC_TRUNCATION_MASK encode t...</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:1008</div></div>
<div class="ttc" id="agroup__crypto__types_html_ga249c8f65fc5e3a56a2d22981987bdfb2"><div class="ttname"><a href="group__crypto__types.html#ga249c8f65fc5e3a56a2d22981987bdfb2">IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH</a></div><div class="ttdeci">#define IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH(type)</div><div class="ttdoc">The block size of a block cipher.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:743</div></div>
</div><!-- fragment -->
<p>The size of the output of <a class="el" href="group__mac__operations.html#ga10989d4f93cdbcb597b8e29ab769db84" title="Finish the calculation of the MAC of a message.">ifx_se_mac_sign_finish()</a>, in bytes. </p>
<p >This is also the MAC size that <a class="el" href="group__mac__operations.html#ga3747616942e5915dbc7365825b063929" title="Finish the calculation of the MAC of a message and compare it with an expected value.">ifx_se_mac_verify_finish()</a> expects.</p>
<dl class="section warning"><dt>Warning</dt><dd>This macro may evaluate its arguments multiple times or zero times, so you should not pass arguments that contain side effects.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>The type of the MAC key. </td></tr>
    <tr><td class="paramname">key_bits</td><td>The size of the MAC key in bits. </td></tr>
    <tr><td class="paramname">alg</td><td>A MAC algorithm (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#ga6ecacfd1287129299bf280d0d30e7194" title="Whether the specified algorithm is a MAC algorithm.">IFX_SE_ALG_IS_MAC</a>(<code>alg</code>) is true).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MAC size for the specified algorithm with the specified key parameters. </dd>
<dd>
0 if the MAC algorithm is not recognized. </dd>
<dd>
Either 0 or the correct size for a MAC algorithm that the implementation recognizes, but does not support. </dd>
<dd>
Unspecified if the key parameters are not consistent with the algorithm. </dd></dl>

</div>
</div>
<a id="ga2c38388015c7b105bd6e9020836adcf4" name="ga2c38388015c7b105bd6e9020836adcf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c38388015c7b105bd6e9020836adcf4">&#9670;&nbsp;</a></span>IFX_SE_AEAD_ENCRYPT_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_ENCRYPT_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">plaintext_length&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__constants__sizes.html#ga43719e5e58b2600aea95d1d9f46accfc">IFX_SE_AEAD_NONCE_LENGTH</a>(key_type, alg) != 0 ?                      \</div>
<div class="line">     (plaintext_length) + <a class="code hl_define" href="group__crypto__algs.html#gaa4e6cfcdf8d0cd54e1d02ad0e0d8fb05">IFX_SE_ALG_AEAD_GET_TAG_LENGTH</a>(alg) :          \</div>
<div class="line">     0u)</div>
<div class="ttc" id="agroup__crypto__algs_html_gaa4e6cfcdf8d0cd54e1d02ad0e0d8fb05"><div class="ttname"><a href="group__crypto__algs.html#gaa4e6cfcdf8d0cd54e1d02ad0e0d8fb05">IFX_SE_ALG_AEAD_GET_TAG_LENGTH</a></div><div class="ttdeci">#define IFX_SE_ALG_AEAD_GET_TAG_LENGTH(aead_alg)</div><div class="ttdoc">Retrieve the tag length of a specified AEAD algorithm.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:1330</div></div>
</div><!-- fragment -->
<p>The maximum size of the output of <a class="el" href="group__aead__operations.html#gafd13261ad6f7c90c49a2d8fc7ad43cf0" title="Process an authenticated encryption operation.">ifx_se_aead_encrypt()</a>, in bytes. </p>
<p >If the size of the ciphertext buffer is at least this large, it is guaranteed that <a class="el" href="group__aead__operations.html#gafd13261ad6f7c90c49a2d8fc7ad43cf0" title="Process an authenticated encryption operation.">ifx_se_aead_encrypt()</a> will not fail due to an insufficient buffer size. Depending on the algorithm, the actual size of the ciphertext may be smaller.</p>
<p >See also <a class="el" href="group__constants__sizes.html#ga2a73783b9da0130c07bca3d0c60b1ee8" title="A sufficient output buffer size for ifx_se_aead_encrypt(), for any of the supported key types and AEA...">IFX_SE_AEAD_ENCRYPT_OUTPUT_MAX_SIZE</a>(<code>plaintext_length</code>).</p>
<dl class="section warning"><dt>Warning</dt><dd>This macro may evaluate its arguments multiple times or zero times, so you should not pass arguments that contain side effects.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A symmetric key type that is compatible with algorithm <code>alg</code>. </td></tr>
    <tr><td class="paramname">alg</td><td>An AEAD algorithm (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#gad2180b8e6448f4b12f28b9a066ab21c3" title="Whether the specified algorithm is an authenticated encryption with associated data (AEAD) algorithm.">IFX_SE_ALG_IS_AEAD</a>(<code>alg</code>) is true). </td></tr>
    <tr><td class="paramname">plaintext_length</td><td>Size of the plaintext in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The AEAD ciphertext size for the specified algorithm. If the key type or AEAD algorithm is not recognized, or the parameters are incompatible, return 0. </dd></dl>

</div>
</div>
<a id="ga2a73783b9da0130c07bca3d0c60b1ee8" name="ga2a73783b9da0130c07bca3d0c60b1ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a73783b9da0130c07bca3d0c60b1ee8">&#9670;&nbsp;</a></span>IFX_SE_AEAD_ENCRYPT_OUTPUT_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_ENCRYPT_OUTPUT_MAX_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">plaintext_length</td><td>)</td>
          <td>&#160;&#160;&#160;    ((plaintext_length) + <a class="el" href="group__constants__sizes.html#ga6591d9decbc41e79aaef7643192bd696">IFX_SE_AEAD_TAG_MAX_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sufficient output buffer size for <a class="el" href="group__aead__operations.html#gafd13261ad6f7c90c49a2d8fc7ad43cf0" title="Process an authenticated encryption operation.">ifx_se_aead_encrypt()</a>, for any of the supported key types and AEAD algorithms. </p>
<p >If the size of the ciphertext buffer is at least this large, it is guaranteed that <a class="el" href="group__aead__operations.html#gafd13261ad6f7c90c49a2d8fc7ad43cf0" title="Process an authenticated encryption operation.">ifx_se_aead_encrypt()</a> will not fail due to an insufficient buffer size.</p>
<dl class="section note"><dt>Note</dt><dd>This macro returns a compile-time constant if its arguments are compile-time constants.</dd></dl>
<p>See also <a class="el" href="group__constants__sizes.html#ga2c38388015c7b105bd6e9020836adcf4" title="The maximum size of the output of ifx_se_aead_encrypt(), in bytes.">IFX_SE_AEAD_ENCRYPT_OUTPUT_SIZE</a>(<code>key_type</code>, <code>alg</code>, <code>plaintext_length</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plaintext_length</td><td>Size of the plaintext in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sufficient output buffer size for any of the supported key types and AEAD algorithms. </dd></dl>

</div>
</div>
<a id="ga6122d9a995791d57949601534822d8a1" name="ga6122d9a995791d57949601534822d8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6122d9a995791d57949601534822d8a1">&#9670;&nbsp;</a></span>IFX_SE_AEAD_DECRYPT_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_DECRYPT_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ciphertext_length&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__constants__sizes.html#ga43719e5e58b2600aea95d1d9f46accfc">IFX_SE_AEAD_NONCE_LENGTH</a>(key_type, alg) != 0 &amp;&amp;                      \</div>
<div class="line">     (ciphertext_length) &gt; <a class="code hl_define" href="group__crypto__algs.html#gaa4e6cfcdf8d0cd54e1d02ad0e0d8fb05">IFX_SE_ALG_AEAD_GET_TAG_LENGTH</a>(alg) ?      \</div>
<div class="line">     (ciphertext_length) - <a class="code hl_define" href="group__crypto__algs.html#gaa4e6cfcdf8d0cd54e1d02ad0e0d8fb05">IFX_SE_ALG_AEAD_GET_TAG_LENGTH</a>(alg) :      \</div>
<div class="line">     0u)</div>
</div><!-- fragment -->
<p>The maximum size of the output of <a class="el" href="group__aead__operations.html#gad2df9a6ff46e11fdc3b2102052102ca7" title="Process an authenticated decryption operation.">ifx_se_aead_decrypt()</a>, in bytes. </p>
<p >If the size of the plaintext buffer is at least this large, it is guaranteed that <a class="el" href="group__aead__operations.html#gad2df9a6ff46e11fdc3b2102052102ca7" title="Process an authenticated decryption operation.">ifx_se_aead_decrypt()</a> will not fail due to an insufficient buffer size. Depending on the algorithm, the actual size of the plaintext may be smaller.</p>
<p >See also <a class="el" href="group__constants__sizes.html#gadce2ffa19d267d9d53f2617fd1ab2e60" title="A sufficient output buffer size for ifx_se_aead_decrypt(), for any of the supported key types and AEA...">IFX_SE_AEAD_DECRYPT_OUTPUT_MAX_SIZE</a>(<code>ciphertext_length</code>).</p>
<dl class="section warning"><dt>Warning</dt><dd>This macro may evaluate its arguments multiple times or zero times, so you should not pass arguments that contain side effects.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A symmetric key type that is compatible with algorithm <code>alg</code>. </td></tr>
    <tr><td class="paramname">alg</td><td>An AEAD algorithm (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#gad2180b8e6448f4b12f28b9a066ab21c3" title="Whether the specified algorithm is an authenticated encryption with associated data (AEAD) algorithm.">IFX_SE_ALG_IS_AEAD</a>(<code>alg</code>) is true). </td></tr>
    <tr><td class="paramname">ciphertext_length</td><td>Size of the plaintext in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The AEAD ciphertext size for the specified algorithm. If the key type or AEAD algorithm is not recognized, or the parameters are incompatible, return 0. </dd></dl>

</div>
</div>
<a id="gadce2ffa19d267d9d53f2617fd1ab2e60" name="gadce2ffa19d267d9d53f2617fd1ab2e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadce2ffa19d267d9d53f2617fd1ab2e60">&#9670;&nbsp;</a></span>IFX_SE_AEAD_DECRYPT_OUTPUT_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_DECRYPT_OUTPUT_MAX_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ciphertext_length</td><td>)</td>
          <td>&#160;&#160;&#160;     (ciphertext_length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sufficient output buffer size for <a class="el" href="group__aead__operations.html#gad2df9a6ff46e11fdc3b2102052102ca7" title="Process an authenticated decryption operation.">ifx_se_aead_decrypt()</a>, for any of the supported key types and AEAD algorithms. </p>
<p >If the size of the plaintext buffer is at least this large, it is guaranteed that <a class="el" href="group__aead__operations.html#gad2df9a6ff46e11fdc3b2102052102ca7" title="Process an authenticated decryption operation.">ifx_se_aead_decrypt()</a> will not fail due to an insufficient buffer size.</p>
<dl class="section note"><dt>Note</dt><dd>This macro returns a compile-time constant if its arguments are compile-time constants.</dd></dl>
<p>See also <a class="el" href="group__constants__sizes.html#ga6122d9a995791d57949601534822d8a1" title="The maximum size of the output of ifx_se_aead_decrypt(), in bytes.">IFX_SE_AEAD_DECRYPT_OUTPUT_SIZE</a>(<code>key_type</code>, <code>alg</code>, <code>ciphertext_length</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ciphertext_length</td><td>Size of the ciphertext in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sufficient output buffer size for any of the supported key types and AEAD algorithms. </dd></dl>

</div>
</div>
<a id="ga43719e5e58b2600aea95d1d9f46accfc" name="ga43719e5e58b2600aea95d1d9f46accfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43719e5e58b2600aea95d1d9f46accfc">&#9670;&nbsp;</a></span>IFX_SE_AEAD_NONCE_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_NONCE_LENGTH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__crypto__types.html#ga249c8f65fc5e3a56a2d22981987bdfb2">IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH</a>(key_type) == 16 ? \</div>
<div class="line">     IFX_SE_ALG_AEAD_EQUAL(alg, <a class="code hl_define" href="group__crypto__algs.html#ga5aba25fa163f6800043a7397c644b8a5">IFX_SE_ALG_CCM</a>) ? 13u : \</div>
<div class="line">     IFX_SE_ALG_AEAD_EQUAL(alg, <a class="code hl_define" href="group__crypto__algs.html#gaef4bc3a3ca5a54a081f925b7d77a372c">IFX_SE_ALG_GCM</a>) ? 12u : \</div>
<div class="line">     0u : \</div>
<div class="line">     (key_type) == <a class="code hl_define" href="group__crypto__types.html#ga5fa33b7f1f4836aae298084436bafaa9">IFX_SE_KEY_TYPE_CHACHA20</a> &amp;&amp; \</div>
<div class="line">     <a class="code hl_define" href="group__crypto__algs.html#gab36a27c43a4b17227dbe38c1d2efe314">IFX_SE_ALG_AEAD_EQUAL</a>(alg, <a class="code hl_define" href="group__crypto__algs.html#gaeaa61ee886223cc4106538f0b06b2f8f">IFX_SE_ALG_CHACHA20_POLY1305</a>) ? 12u : \</div>
<div class="line">     0u)</div>
<div class="ttc" id="agroup__crypto__algs_html_ga5aba25fa163f6800043a7397c644b8a5"><div class="ttname"><a href="group__crypto__algs.html#ga5aba25fa163f6800043a7397c644b8a5">IFX_SE_ALG_CCM</a></div><div class="ttdeci">#define IFX_SE_ALG_CCM</div><div class="ttdoc">The CCM authenticated encryption algorithm.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:1252</div></div>
<div class="ttc" id="agroup__crypto__algs_html_gab36a27c43a4b17227dbe38c1d2efe314"><div class="ttname"><a href="group__crypto__algs.html#gab36a27c43a4b17227dbe38c1d2efe314">IFX_SE_ALG_AEAD_EQUAL</a></div><div class="ttdeci">#define IFX_SE_ALG_AEAD_EQUAL(aead_alg_1, aead_alg_2)</div><div class="ttdoc">Check if two AEAD algorithm identifiers refer to the same AEAD algorithm regardless of the tag length...</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:2711</div></div>
<div class="ttc" id="agroup__crypto__algs_html_gaeaa61ee886223cc4106538f0b06b2f8f"><div class="ttname"><a href="group__crypto__algs.html#gaeaa61ee886223cc4106538f0b06b2f8f">IFX_SE_ALG_CHACHA20_POLY1305</a></div><div class="ttdeci">#define IFX_SE_ALG_CHACHA20_POLY1305</div><div class="ttdoc">The Chacha20-Poly1305 AEAD algorithm.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:1280</div></div>
<div class="ttc" id="agroup__crypto__algs_html_gaef4bc3a3ca5a54a081f925b7d77a372c"><div class="ttname"><a href="group__crypto__algs.html#gaef4bc3a3ca5a54a081f925b7d77a372c">IFX_SE_ALG_GCM</a></div><div class="ttdeci">#define IFX_SE_ALG_GCM</div><div class="ttdoc">The GCM authenticated encryption algorithm.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:1269</div></div>
<div class="ttc" id="agroup__crypto__types_html_ga5fa33b7f1f4836aae298084436bafaa9"><div class="ttname"><a href="group__crypto__types.html#ga5fa33b7f1f4836aae298084436bafaa9">IFX_SE_KEY_TYPE_CHACHA20</a></div><div class="ttdeci">#define IFX_SE_KEY_TYPE_CHACHA20</div><div class="ttdoc">Key for the ChaCha20 stream cipher or the Chacha20-Poly1305 AEAD algorithm.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:514</div></div>
</div><!-- fragment -->
<p>The default nonce size for an AEAD algorithm, in bytes. </p>
<p >This macro can be used to allocate a buffer of sufficient size to store the nonce output from <a class="el" href="group__aead__operations.html#ga0a287eee559d61c1abdd01bb7eff22d2" title="Generate a random nonce for an authenticated encryption operation.">ifx_se_aead_generate_nonce()</a>.</p>
<p >See also <a class="el" href="group__constants__sizes.html#ga52b03a104ec896af5607d1a2be56e9a5" title="The maximum default nonce size among all supported pairs of key types and AEAD algorithms,...">IFX_SE_AEAD_NONCE_MAX_SIZE</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This is not the maximum size of nonce supported as input to <a class="el" href="group__aead__operations.html#ga296bb7b4e6c3dc86f64115fd6a8f713c" title="Set the nonce for an authenticated encryption or decryption operation.">ifx_se_aead_set_nonce()</a>, <a class="el" href="group__aead__operations.html#gafd13261ad6f7c90c49a2d8fc7ad43cf0" title="Process an authenticated encryption operation.">ifx_se_aead_encrypt()</a> or <a class="el" href="group__aead__operations.html#gad2df9a6ff46e11fdc3b2102052102ca7" title="Process an authenticated decryption operation.">ifx_se_aead_decrypt()</a>, just the default size that is generated by <a class="el" href="group__aead__operations.html#ga0a287eee559d61c1abdd01bb7eff22d2" title="Generate a random nonce for an authenticated encryption operation.">ifx_se_aead_generate_nonce()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro may evaluate its arguments multiple times or zero times, so you should not pass arguments that contain side effects.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A symmetric key type that is compatible with algorithm <code>alg</code>.</td></tr>
    <tr><td class="paramname">alg</td><td>An AEAD algorithm (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#gad2180b8e6448f4b12f28b9a066ab21c3" title="Whether the specified algorithm is an authenticated encryption with associated data (AEAD) algorithm.">IFX_SE_ALG_IS_AEAD</a>(<code>alg</code>) is true).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The default nonce size for the specified key type and algorithm. If the key type or AEAD algorithm is not recognized, or the parameters are incompatible, return 0. </dd></dl>

</div>
</div>
<a id="ga52b03a104ec896af5607d1a2be56e9a5" name="ga52b03a104ec896af5607d1a2be56e9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52b03a104ec896af5607d1a2be56e9a5">&#9670;&nbsp;</a></span>IFX_SE_AEAD_NONCE_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_NONCE_MAX_SIZE&#160;&#160;&#160;13u</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum default nonce size among all supported pairs of key types and AEAD algorithms, in bytes. </p>
<p >This is equal to or greater than any value that <a class="el" href="group__constants__sizes.html#ga43719e5e58b2600aea95d1d9f46accfc" title="The default nonce size for an AEAD algorithm, in bytes.">IFX_SE_AEAD_NONCE_LENGTH()</a> may return.</p>
<dl class="section note"><dt>Note</dt><dd>This is not the maximum size of nonce supported as input to <a class="el" href="group__aead__operations.html#ga296bb7b4e6c3dc86f64115fd6a8f713c" title="Set the nonce for an authenticated encryption or decryption operation.">ifx_se_aead_set_nonce()</a>, <a class="el" href="group__aead__operations.html#gafd13261ad6f7c90c49a2d8fc7ad43cf0" title="Process an authenticated encryption operation.">ifx_se_aead_encrypt()</a> or <a class="el" href="group__aead__operations.html#gad2df9a6ff46e11fdc3b2102052102ca7" title="Process an authenticated decryption operation.">ifx_se_aead_decrypt()</a>, just the largest size that may be generated by <a class="el" href="group__aead__operations.html#ga0a287eee559d61c1abdd01bb7eff22d2" title="Generate a random nonce for an authenticated encryption operation.">ifx_se_aead_generate_nonce()</a>. </dd></dl>

</div>
</div>
<a id="gab8f8444c61884d0b1e6f210abecd2b22" name="gab8f8444c61884d0b1e6f210abecd2b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8f8444c61884d0b1e6f210abecd2b22">&#9670;&nbsp;</a></span>IFX_SE_AEAD_UPDATE_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_UPDATE_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input_length&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__constants__sizes.html#ga43719e5e58b2600aea95d1d9f46accfc">IFX_SE_AEAD_NONCE_LENGTH</a>(key_type, alg) != 0 ?                                            \</div>
<div class="line">     IFX_SE_ALG_IS_AEAD_ON_BLOCK_CIPHER(alg) ?                                                 \</div>
<div class="line">     IFX_SE_ROUND_UP_TO_MULTIPLE(<a class="code hl_define" href="group__crypto__types.html#ga249c8f65fc5e3a56a2d22981987bdfb2">IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH</a>(key_type), (input_length)) : \</div>
<div class="line">     (input_length) : \</div>
<div class="line">     0u)</div>
</div><!-- fragment -->
<p>A sufficient output buffer size for <a class="el" href="group__aead__operations.html#ga088505209fac640f5de807198d4f16bd" title="Encrypt or decrypt a message fragment in an active AEAD operation.">ifx_se_aead_update()</a>. </p>
<p >If the size of the output buffer is at least this large, it is guaranteed that <a class="el" href="group__aead__operations.html#ga088505209fac640f5de807198d4f16bd" title="Encrypt or decrypt a message fragment in an active AEAD operation.">ifx_se_aead_update()</a> will not fail due to an insufficient buffer size. The actual size of the output may be smaller in any given call.</p>
<p >See also <a class="el" href="group__constants__sizes.html#gadce84030bb402e16e2abec0f5da32f3b" title="A sufficient output buffer size for ifx_se_aead_update(), for any of the supported key types and AEAD...">IFX_SE_AEAD_UPDATE_OUTPUT_MAX_SIZE</a>(<code>input_length</code>).</p>
<dl class="section warning"><dt>Warning</dt><dd>This macro may evaluate its arguments multiple times or zero times, so you should not pass arguments that contain side effects.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A symmetric key type that is compatible with algorithm <code>alg</code>. </td></tr>
    <tr><td class="paramname">alg</td><td>An AEAD algorithm (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#gad2180b8e6448f4b12f28b9a066ab21c3" title="Whether the specified algorithm is an authenticated encryption with associated data (AEAD) algorithm.">IFX_SE_ALG_IS_AEAD</a>(<code>alg</code>) is true). </td></tr>
    <tr><td class="paramname">input_length</td><td>Size of the input in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sufficient output buffer size for the specified algorithm. If the key type or AEAD algorithm is not recognized, or the parameters are incompatible, return 0. </dd></dl>

</div>
</div>
<a id="gadce84030bb402e16e2abec0f5da32f3b" name="gadce84030bb402e16e2abec0f5da32f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadce84030bb402e16e2abec0f5da32f3b">&#9670;&nbsp;</a></span>IFX_SE_AEAD_UPDATE_OUTPUT_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_UPDATE_OUTPUT_MAX_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input_length</td><td>)</td>
          <td>&#160;&#160;&#160;    (IFX_SE_ROUND_UP_TO_MULTIPLE(<a class="el" href="group__constants__sizes.html#ga45af326ee82009b61b2d48dbd1048757">IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</a>, (input_length)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sufficient output buffer size for <a class="el" href="group__aead__operations.html#ga088505209fac640f5de807198d4f16bd" title="Encrypt or decrypt a message fragment in an active AEAD operation.">ifx_se_aead_update()</a>, for any of the supported key types and AEAD algorithms. </p>
<p >If the size of the output buffer is at least this large, it is guaranteed that <a class="el" href="group__aead__operations.html#ga088505209fac640f5de807198d4f16bd" title="Encrypt or decrypt a message fragment in an active AEAD operation.">ifx_se_aead_update()</a> will not fail due to an insufficient buffer size.</p>
<p >See also <a class="el" href="group__constants__sizes.html#gab8f8444c61884d0b1e6f210abecd2b22" title="A sufficient output buffer size for ifx_se_aead_update().">IFX_SE_AEAD_UPDATE_OUTPUT_SIZE</a>(<code>key_type</code>, <code>alg</code>, <code>input_length</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_length</td><td>Size of the input in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0dcccf0e8f57e2b61636da7531347b96" name="ga0dcccf0e8f57e2b61636da7531347b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dcccf0e8f57e2b61636da7531347b96">&#9670;&nbsp;</a></span>IFX_SE_AEAD_FINISH_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_FINISH_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__constants__sizes.html#ga43719e5e58b2600aea95d1d9f46accfc">IFX_SE_AEAD_NONCE_LENGTH</a>(key_type, alg) != 0 &amp;&amp;  \</div>
<div class="line">     IFX_SE_ALG_IS_AEAD_ON_BLOCK_CIPHER(alg) ?    \</div>
<div class="line">     IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH(key_type) : \</div>
<div class="line">     0u)</div>
</div><!-- fragment -->
<p>A sufficient ciphertext buffer size for <a class="el" href="group__aead__operations.html#gacadd06a79d3016fbbe49c624f6de41b9" title="Finish encrypting a message in an AEAD operation.">ifx_se_aead_finish()</a>. </p>
<p >If the size of the ciphertext buffer is at least this large, it is guaranteed that <a class="el" href="group__aead__operations.html#gacadd06a79d3016fbbe49c624f6de41b9" title="Finish encrypting a message in an AEAD operation.">ifx_se_aead_finish()</a> will not fail due to an insufficient ciphertext buffer size. The actual size of the output may be smaller in any given call.</p>
<p >See also <a class="el" href="group__constants__sizes.html#ga28978e87d066f8157038215f2a3d7245" title="A sufficient ciphertext buffer size for ifx_se_aead_finish(), for any of the supported key types and ...">IFX_SE_AEAD_FINISH_OUTPUT_MAX_SIZE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A symmetric key type that is compatible with algorithm <code>alg</code>. </td></tr>
    <tr><td class="paramname">alg</td><td>An AEAD algorithm (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#gad2180b8e6448f4b12f28b9a066ab21c3" title="Whether the specified algorithm is an authenticated encryption with associated data (AEAD) algorithm.">IFX_SE_ALG_IS_AEAD</a>(<code>alg</code>) is true).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sufficient ciphertext buffer size for the specified algorithm. If the key type or AEAD algorithm is not recognized, or the parameters are incompatible, return 0. </dd></dl>

</div>
</div>
<a id="ga28978e87d066f8157038215f2a3d7245" name="ga28978e87d066f8157038215f2a3d7245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28978e87d066f8157038215f2a3d7245">&#9670;&nbsp;</a></span>IFX_SE_AEAD_FINISH_OUTPUT_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_FINISH_OUTPUT_MAX_SIZE&#160;&#160;&#160;(<a class="el" href="group__constants__sizes.html#ga45af326ee82009b61b2d48dbd1048757">IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sufficient ciphertext buffer size for <a class="el" href="group__aead__operations.html#gacadd06a79d3016fbbe49c624f6de41b9" title="Finish encrypting a message in an AEAD operation.">ifx_se_aead_finish()</a>, for any of the supported key types and AEAD algorithms. </p>
<p >See also <a class="el" href="group__constants__sizes.html#ga0dcccf0e8f57e2b61636da7531347b96" title="A sufficient ciphertext buffer size for ifx_se_aead_finish().">IFX_SE_AEAD_FINISH_OUTPUT_SIZE</a>(<code>key_type</code>, <code>alg</code>). </p>

</div>
</div>
<a id="gaf4eecf0f99f3eff7a55191a2a3637e70" name="gaf4eecf0f99f3eff7a55191a2a3637e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4eecf0f99f3eff7a55191a2a3637e70">&#9670;&nbsp;</a></span>IFX_SE_AEAD_VERIFY_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_VERIFY_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__constants__sizes.html#ga43719e5e58b2600aea95d1d9f46accfc">IFX_SE_AEAD_NONCE_LENGTH</a>(key_type, alg) != 0 &amp;&amp;  \</div>
<div class="line">     IFX_SE_ALG_IS_AEAD_ON_BLOCK_CIPHER(alg) ?    \</div>
<div class="line">     IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH(key_type) : \</div>
<div class="line">     0u)</div>
</div><!-- fragment -->
<p>A sufficient plaintext buffer size for <a class="el" href="group__aead__operations.html#ga2709dc768af62670cbfc7b0259b6f82c" title="Finish authenticating and decrypting a message in an AEAD operation.">ifx_se_aead_verify()</a>. </p>
<p >If the size of the plaintext buffer is at least this large, it is guaranteed that <a class="el" href="group__aead__operations.html#ga2709dc768af62670cbfc7b0259b6f82c" title="Finish authenticating and decrypting a message in an AEAD operation.">ifx_se_aead_verify()</a> will not fail due to an insufficient plaintext buffer size. The actual size of the output may be smaller in any given call.</p>
<p >See also <a class="el" href="group__constants__sizes.html#ga3cce514238c203a25cfacdc468a744a0" title="A sufficient plaintext buffer size for ifx_se_aead_verify(), for any of the supported key types and A...">IFX_SE_AEAD_VERIFY_OUTPUT_MAX_SIZE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A symmetric key type that is compatible with algorithm <code>alg</code>. </td></tr>
    <tr><td class="paramname">alg</td><td>An AEAD algorithm (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#gad2180b8e6448f4b12f28b9a066ab21c3" title="Whether the specified algorithm is an authenticated encryption with associated data (AEAD) algorithm.">IFX_SE_ALG_IS_AEAD</a>(<code>alg</code>) is true).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sufficient plaintext buffer size for the specified algorithm. If the key type or AEAD algorithm is not recognized, or the parameters are incompatible, return 0. </dd></dl>

</div>
</div>
<a id="ga3cce514238c203a25cfacdc468a744a0" name="ga3cce514238c203a25cfacdc468a744a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cce514238c203a25cfacdc468a744a0">&#9670;&nbsp;</a></span>IFX_SE_AEAD_VERIFY_OUTPUT_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_AEAD_VERIFY_OUTPUT_MAX_SIZE&#160;&#160;&#160;(<a class="el" href="group__constants__sizes.html#ga45af326ee82009b61b2d48dbd1048757">IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sufficient plaintext buffer size for <a class="el" href="group__aead__operations.html#ga2709dc768af62670cbfc7b0259b6f82c" title="Finish authenticating and decrypting a message in an AEAD operation.">ifx_se_aead_verify()</a>, for any of the supported key types and AEAD algorithms. </p>
<p >See also <a class="el" href="group__constants__sizes.html#gaf4eecf0f99f3eff7a55191a2a3637e70" title="A sufficient plaintext buffer size for ifx_se_aead_verify().">IFX_SE_AEAD_VERIFY_OUTPUT_SIZE</a>(<code>key_type</code>, <code>alg</code>). </p>

</div>
</div>
<a id="gab15d9c8f7f362a839301c8187eae78c5" name="gab15d9c8f7f362a839301c8187eae78c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab15d9c8f7f362a839301c8187eae78c5">&#9670;&nbsp;</a></span>IFX_SE_ECDSA_SIGNATURE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_ECDSA_SIGNATURE_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">curve_bits</td><td>)</td>
          <td>&#160;&#160;&#160;    (IFX_SE_BITS_TO_BYTES(curve_bits) * 2u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDSA signature size for a given curve bit size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve_bits</td><td>Curve size in bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signature size in bytes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This macro returns a compile-time constant if its argument is one. </dd></dl>

</div>
</div>
<a id="ga5f947bd48cf391becc3d49d1a16a9813" name="ga5f947bd48cf391becc3d49d1a16a9813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f947bd48cf391becc3d49d1a16a9813">&#9670;&nbsp;</a></span>IFX_SE_SIGN_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_SIGN_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_bits, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">     (<a class="code hl_define" href="group__crypto__types.html#ga349860252b95eba5f703d28359501f37">IFX_SE_KEY_TYPE_IS_ECC</a>(key_type) ? <a class="code hl_define" href="group__constants__sizes.html#gab15d9c8f7f362a839301c8187eae78c5">IFX_SE_ECDSA_SIGNATURE_SIZE</a>(key_bits) : \</div>
<div class="line">     ((void)alg, 0u))</div>
<div class="ttc" id="agroup__constants__sizes_html_gab15d9c8f7f362a839301c8187eae78c5"><div class="ttname"><a href="group__constants__sizes.html#gab15d9c8f7f362a839301c8187eae78c5">IFX_SE_ECDSA_SIGNATURE_SIZE</a></div><div class="ttdeci">#define IFX_SE_ECDSA_SIGNATURE_SIZE(curve_bits)</div><div class="ttdoc">ECDSA signature size for a given curve bit size.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_sizes.h:528</div></div>
<div class="ttc" id="agroup__crypto__types_html_ga349860252b95eba5f703d28359501f37"><div class="ttname"><a href="group__crypto__types.html#ga349860252b95eba5f703d28359501f37">IFX_SE_KEY_TYPE_IS_ECC</a></div><div class="ttdeci">#define IFX_SE_KEY_TYPE_IS_ECC(type)</div><div class="ttdoc">Whether a key type is an elliptic curve key (pair or public-only).</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:560</div></div>
</div><!-- fragment -->
<p>Sufficient signature buffer size for <a class="el" href="group__async__operations.html#ga9a357621153662289ed7ad1eef7fff1d" title="Sign a hash or short message with a private key.">ifx_se_sign_hash()</a>. </p>
<p >This macro returns a sufficient buffer size for a signature using a key of the specified type and size, with the specified algorithm. Note that the actual size of the signature may be smaller (some algorithms produce a variable-size signature).</p>
<dl class="section warning"><dt>Warning</dt><dd>This function may call its arguments multiple times or zero times, so you should not pass arguments that contain side effects.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>An asymmetric key type (this may indifferently be a key pair type or a public key type). </td></tr>
    <tr><td class="paramname">key_bits</td><td>The size of the key in bits. </td></tr>
    <tr><td class="paramname">alg</td><td>The signature algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the parameters are valid and supported, return a buffer size in bytes that guarantees that <a class="el" href="group__async__operations.html#ga9a357621153662289ed7ad1eef7fff1d" title="Sign a hash or short message with a private key.">ifx_se_sign_hash()</a> will not fail with <a class="el" href="group__psacrypto__error.html#ga9deeddae437b2f7a9ebf6f030fe00522" title="An output buffer is too small.">IFX_SE_ERROR_BUFFER_TOO_SMALL</a>. If the parameters are a valid combination that is not supported, return either a sensible size or 0. If the parameters are not valid, the return value is unspecified. </dd></dl>

</div>
</div>
<a id="gac3320dec942ac856b711debc88579b1d" name="gac3320dec942ac856b711debc88579b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3320dec942ac856b711debc88579b1d">&#9670;&nbsp;</a></span>IFX_SE_SIGNATURE_MAX_SIZE <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_SIGNATURE_MAX_SIZE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size of an asymmetric signature. </p>
<p >This macro expands to a compile-time constant integer. This value is the maximum size of a signature in bytes. </p>

</div>
</div>
<a id="gac3320dec942ac856b711debc88579b1d" name="gac3320dec942ac856b711debc88579b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3320dec942ac856b711debc88579b1d">&#9670;&nbsp;</a></span>IFX_SE_SIGNATURE_MAX_SIZE <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_SIGNATURE_MAX_SIZE&#160;&#160;&#160;IFX_SE_BITS_TO_BYTES(<a class="el" href="group__constants__sizes.html#ga210e5a934a8c404fa528fc32330b748d">IFX_SE_VENDOR_RSA_MAX_KEY_BITS</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size of an asymmetric signature. </p>
<p >This macro expands to a compile-time constant integer. This value is the maximum size of a signature in bytes. </p>

</div>
</div>
<a id="ga69cd9eb2a526db33495fd9e97db6c988" name="ga69cd9eb2a526db33495fd9e97db6c988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69cd9eb2a526db33495fd9e97db6c988">&#9670;&nbsp;</a></span>IFX_SE_KEY_EXPORT_ECC_PUBLIC_KEY_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_KEY_EXPORT_ECC_PUBLIC_KEY_MAX_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_bits</td><td>)</td>
          <td>&#160;&#160;&#160;    (2u * IFX_SE_BITS_TO_BYTES(key_bits) + 1u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size of the export encoding of an ECC public key. </p>
<p >The representation of an ECC public key is:</p><ul>
<li>The byte 0x04;</li>
<li><code>x_P</code> as a <code>ceiling(m/8)</code>-byte string, big-endian;</li>
<li><code>y_P</code> as a <code>ceiling(m/8)</code>-byte string, big-endian;</li>
<li>where m is the bit size associated with the curve.</li>
</ul>
<p >-&gt; 1 byte + 2 * point size. </p>

</div>
</div>
<a id="ga9de7c6911ef3cb793268d442d7520c26" name="ga9de7c6911ef3cb793268d442d7520c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9de7c6911ef3cb793268d442d7520c26">&#9670;&nbsp;</a></span>IFX_SE_KEY_EXPORT_ECC_KEY_PAIR_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_KEY_EXPORT_ECC_KEY_PAIR_MAX_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_bits</td><td>)</td>
          <td>&#160;&#160;&#160;    (IFX_SE_BITS_TO_BYTES(key_bits))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size of the export encoding of an ECC key pair. </p>
<p >An ECC key pair is represented by the secret value. </p>

</div>
</div>
<a id="ga1222750b6bc259514a3f784cffd01165" name="ga1222750b6bc259514a3f784cffd01165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1222750b6bc259514a3f784cffd01165">&#9670;&nbsp;</a></span>IFX_SE_EXPORT_KEY_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_EXPORT_KEY_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_bits&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__crypto__types.html#ga89517d9a8c7be38808bd601c8ac50b0b">IFX_SE_KEY_TYPE_IS_UNSTRUCTURED</a>(key_type) ? IFX_SE_BITS_TO_BYTES(key_bits) :                         \</div>
<div class="line">     <a class="code hl_define" href="group__crypto__types.html#ga650a6f4b2d282b7fc02c3d7417e47af2">IFX_SE_KEY_TYPE_IS_ECC_KEY_PAIR</a>(key_type) ? <a class="code hl_define" href="group__constants__sizes.html#ga9de7c6911ef3cb793268d442d7520c26">IFX_SE_KEY_EXPORT_ECC_KEY_PAIR_MAX_SIZE</a>(key_bits) :      \</div>
<div class="line">     <a class="code hl_define" href="group__crypto__types.html#gacd657912d25fc3d0d0649789670088df">IFX_SE_KEY_TYPE_IS_ECC_PUBLIC_KEY</a>(key_type) ? <a class="code hl_define" href="group__constants__sizes.html#ga69cd9eb2a526db33495fd9e97db6c988">IFX_SE_KEY_EXPORT_ECC_PUBLIC_KEY_MAX_SIZE</a>(key_bits) :  \</div>
<div class="line">     0u)</div>
<div class="ttc" id="agroup__constants__sizes_html_ga69cd9eb2a526db33495fd9e97db6c988"><div class="ttname"><a href="group__constants__sizes.html#ga69cd9eb2a526db33495fd9e97db6c988">IFX_SE_KEY_EXPORT_ECC_PUBLIC_KEY_MAX_SIZE</a></div><div class="ttdeci">#define IFX_SE_KEY_EXPORT_ECC_PUBLIC_KEY_MAX_SIZE(key_bits)</div><div class="ttdoc">Maximum size of the export encoding of an ECC public key.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_sizes.h:593</div></div>
<div class="ttc" id="agroup__constants__sizes_html_ga9de7c6911ef3cb793268d442d7520c26"><div class="ttname"><a href="group__constants__sizes.html#ga9de7c6911ef3cb793268d442d7520c26">IFX_SE_KEY_EXPORT_ECC_KEY_PAIR_MAX_SIZE</a></div><div class="ttdeci">#define IFX_SE_KEY_EXPORT_ECC_KEY_PAIR_MAX_SIZE(key_bits)</div><div class="ttdoc">Maximum size of the export encoding of an ECC key pair.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_sizes.h:600</div></div>
<div class="ttc" id="agroup__crypto__types_html_ga650a6f4b2d282b7fc02c3d7417e47af2"><div class="ttname"><a href="group__crypto__types.html#ga650a6f4b2d282b7fc02c3d7417e47af2">IFX_SE_KEY_TYPE_IS_ECC_KEY_PAIR</a></div><div class="ttdeci">#define IFX_SE_KEY_TYPE_IS_ECC_KEY_PAIR(type)</div><div class="ttdoc">Whether a key type is an elliptic curve key pair.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:564</div></div>
<div class="ttc" id="agroup__crypto__types_html_ga89517d9a8c7be38808bd601c8ac50b0b"><div class="ttname"><a href="group__crypto__types.html#ga89517d9a8c7be38808bd601c8ac50b0b">IFX_SE_KEY_TYPE_IS_UNSTRUCTURED</a></div><div class="ttdeci">#define IFX_SE_KEY_TYPE_IS_UNSTRUCTURED(type)</div><div class="ttdoc">Whether a key type is an unstructured array of bytes.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:369</div></div>
<div class="ttc" id="agroup__crypto__types_html_gacd657912d25fc3d0d0649789670088df"><div class="ttname"><a href="group__crypto__types.html#gacd657912d25fc3d0d0649789670088df">IFX_SE_KEY_TYPE_IS_ECC_PUBLIC_KEY</a></div><div class="ttdeci">#define IFX_SE_KEY_TYPE_IS_ECC_PUBLIC_KEY(type)</div><div class="ttdoc">Whether a key type is an elliptic curve public key.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:568</div></div>
</div><!-- fragment -->
<p>Sufficient output buffer size for <a class="el" href="group__import__export.html#ga4a53bdb503a45522b6555cc255364759" title="Export a key in binary format.">ifx_se_export_key()</a> or <a class="el" href="group__import__export.html#ga120a3d6cb22b2a2d438edf1cdebc560f" title="Export a public key or the public part of a key pair in binary format.">ifx_se_export_public_key()</a>. </p>
<p >This macro returns a compile-time constant if its arguments are compile-time constants.</p>
<dl class="section warning"><dt>Warning</dt><dd>This macro may evaluate its arguments multiple times or zero times, so you should not pass arguments that contain side effects.</dd></dl>
<p>The following code illustrates how to allocate enough memory to export a key by querying the key type and size at runtime. </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__key__attributes.html#gad1ded78e935cd08ba08a5a27c003d7b3">ifx_se_key_attributes_t</a> attributes = <a class="code hl_define" href="group__key__attributes.html#ga5ad00c2092aaa27fc2a8fee1dedfadbc">IFX_SE_KEY_ATTRIBUTES_INIT</a>;</div>
<div class="line"><a class="code hl_struct" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a> status;</div>
<div class="line">status = <a class="code hl_function" href="group__key__attributes.html#ga9b1284c5dad22b4bd35ace36e03e3266">ifx_se_get_key_attributes</a>(key, &amp;attributes);</div>
<div class="line"><span class="keywordflow">if</span> (status != <a class="code hl_define" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47">IFX_SE_SUCCESS</a>) handle_error(...);</div>
<div class="line"><a class="code hl_typedef" href="group__crypto__types.html#ga562d12a9de8d6a287d98020515c6d438">ifx_se_key_type_t</a> key_type = <a class="code hl_function" href="group__crypto__types.html#gad6653f24190c92b3b744c7ce2aae9807">ifx_se_get_key_type</a>(&amp;attributes);</div>
<div class="line"><span class="keywordtype">size_t</span> key_bits = <a class="code hl_function" href="group__crypto__types.html#gaa7e96b37591bdfc95685da0c786ae5ed">ifx_se_get_key_bits</a>(&amp;attributes);</div>
<div class="line"><span class="keywordtype">size_t</span> buffer_size = <a class="code hl_define" href="group__constants__sizes.html#ga1222750b6bc259514a3f784cffd01165">IFX_SE_EXPORT_KEY_OUTPUT_SIZE</a>(key_type, key_bits);</div>
<div class="line"><a class="code hl_function" href="group__key__attributes.html#ga196181551fdce352b8d81d76ec144c1c">ifx_se_reset_key_attributes</a>(&amp;attributes);</div>
<div class="line">uint8_t *buffer = malloc(buffer_size);</div>
<div class="line"><span class="keywordflow">if</span> (buffer == NULL) handle_error(...);</div>
<div class="line"><span class="keywordtype">size_t</span> buffer_length;</div>
<div class="line">status = <a class="code hl_function" href="group__import__export.html#ga4a53bdb503a45522b6555cc255364759">ifx_se_export_key</a>(key, buffer, buffer_size, &amp;buffer_length);</div>
<div class="line"><span class="keywordflow">if</span> (status != <a class="code hl_define" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47">IFX_SE_SUCCESS</a>) handle_error(...);</div>
<div class="ttc" id="agroup__constants__sizes_html_ga1222750b6bc259514a3f784cffd01165"><div class="ttname"><a href="group__constants__sizes.html#ga1222750b6bc259514a3f784cffd01165">IFX_SE_EXPORT_KEY_OUTPUT_SIZE</a></div><div class="ttdeci">#define IFX_SE_EXPORT_KEY_OUTPUT_SIZE(key_type, key_bits)</div><div class="ttdoc">Sufficient output buffer size for ifx_se_export_key() or ifx_se_export_public_key().</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_sizes.h:642</div></div>
<div class="ttc" id="agroup__crypto__types_html_ga562d12a9de8d6a287d98020515c6d438"><div class="ttname"><a href="group__crypto__types.html#ga562d12a9de8d6a287d98020515c6d438">ifx_se_key_type_t</a></div><div class="ttdeci">uint16_t ifx_se_key_type_t</div><div class="ttdoc">Encoding of a key type.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_types.h:132</div></div>
<div class="ttc" id="agroup__crypto__types_html_gaa7e96b37591bdfc95685da0c786ae5ed"><div class="ttname"><a href="group__crypto__types.html#gaa7e96b37591bdfc95685da0c786ae5ed">ifx_se_get_key_bits</a></div><div class="ttdeci">static size_t ifx_se_get_key_bits(const ifx_se_key_attributes_t *attributes)</div><div class="ttdoc">Gets key length in bits from key attributes structure.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_struct.h:483</div></div>
<div class="ttc" id="agroup__crypto__types_html_gad6653f24190c92b3b744c7ce2aae9807"><div class="ttname"><a href="group__crypto__types.html#gad6653f24190c92b3b744c7ce2aae9807">ifx_se_get_key_type</a></div><div class="ttdeci">static ifx_se_key_type_t ifx_se_get_key_type(const ifx_se_key_attributes_t *attributes)</div><div class="ttdoc">Gets key type from key attributes structure.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_struct.h:454</div></div>
<div class="ttc" id="agroup__fih_html_structifx__se__fih__uint"><div class="ttname"><a href="group__fih.html#structifx__se__fih__uint">ifx_se_fih_uint</a></div><div class="ttdoc">All ints are replaced with two int - the normal one and a backup which is XORed with the mask.</div><div class="ttdef"><b>Definition:</b> ifx_se_fih.h:112</div></div>
<div class="ttc" id="agroup__import__export_html_ga4a53bdb503a45522b6555cc255364759"><div class="ttname"><a href="group__import__export.html#ga4a53bdb503a45522b6555cc255364759">ifx_se_export_key</a></div><div class="ttdeci">ifx_se_status_t ifx_se_export_key(ifx_se_key_id_fih_t key, ifx_se_fih_ptr_t data, ifx_se_fih_t data_size, ifx_se_fih_ptr_t data_length, void *ctx)</div><div class="ttdoc">Export a key in binary format.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto.c:1025</div></div>
<div class="ttc" id="agroup__key__attributes_html_ga196181551fdce352b8d81d76ec144c1c"><div class="ttname"><a href="group__key__attributes.html#ga196181551fdce352b8d81d76ec144c1c">ifx_se_reset_key_attributes</a></div><div class="ttdeci">void ifx_se_reset_key_attributes(ifx_se_key_attributes_t *attributes)</div><div class="ttdoc">Reset a key attribute structure to a freshly initialized state.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto.c:1534</div></div>
<div class="ttc" id="agroup__key__attributes_html_ga5ad00c2092aaa27fc2a8fee1dedfadbc"><div class="ttname"><a href="group__key__attributes.html#ga5ad00c2092aaa27fc2a8fee1dedfadbc">IFX_SE_KEY_ATTRIBUTES_INIT</a></div><div class="ttdeci">#define IFX_SE_KEY_ATTRIBUTES_INIT</div><div class="ttdoc">The initial value of the key attributes.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_struct.h:239</div></div>
<div class="ttc" id="agroup__key__attributes_html_ga9b1284c5dad22b4bd35ace36e03e3266"><div class="ttname"><a href="group__key__attributes.html#ga9b1284c5dad22b4bd35ace36e03e3266">ifx_se_get_key_attributes</a></div><div class="ttdeci">ifx_se_status_t ifx_se_get_key_attributes(ifx_se_key_id_fih_t key, ifx_se_key_attributes_t *attributes, void *ctx)</div><div class="ttdoc">Retrieve the attributes of a key.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto.c:1539</div></div>
<div class="ttc" id="agroup__key__attributes_html_gad1ded78e935cd08ba08a5a27c003d7b3"><div class="ttname"><a href="group__key__attributes.html#gad1ded78e935cd08ba08a5a27c003d7b3">ifx_se_key_attributes_t</a></div><div class="ttdeci">struct ifx_se_key_attributes_s ifx_se_key_attributes_t</div><div class="ttdoc">The type of a structure containing key attributes.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_types.h:465</div></div>
<div class="ttc" id="agroup__syscall__errors_html_ga9369eb56a5688c73fd213d7b740f9a47"><div class="ttname"><a href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47">IFX_SE_SUCCESS</a></div><div class="ttdeci">#define IFX_SE_SUCCESS</div><div class="ttdoc">Success operation.</div><div class="ttdef"><b>Definition:</b> ifx_se_syscall.h:201</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A supported key type. </td></tr>
    <tr><td class="paramname">key_bits</td><td>The size of the key in bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the parameters are valid and supported, return a buffer size in bytes that guarantees that <a class="el" href="group__import__export.html#ga4a53bdb503a45522b6555cc255364759" title="Export a key in binary format.">ifx_se_export_key()</a> or <a class="el" href="group__import__export.html#ga120a3d6cb22b2a2d438edf1cdebc560f" title="Export a public key or the public part of a key pair in binary format.">ifx_se_export_public_key()</a> will not fail with <a class="el" href="group__psacrypto__error.html#ga9deeddae437b2f7a9ebf6f030fe00522" title="An output buffer is too small.">IFX_SE_ERROR_BUFFER_TOO_SMALL</a>. If the parameters are a valid combination that is not supported, return either a sensible size or 0. If the parameters are not valid, the return value is unspecified. </dd></dl>

</div>
</div>
<a id="gaece8655cb723c849956466f8474f10f9" name="gaece8655cb723c849956466f8474f10f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaece8655cb723c849956466f8474f10f9">&#9670;&nbsp;</a></span>IFX_SE_EXPORT_PUBLIC_KEY_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_EXPORT_PUBLIC_KEY_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_bits&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">     (<a class="code hl_define" href="group__crypto__types.html#ga349860252b95eba5f703d28359501f37">IFX_SE_KEY_TYPE_IS_ECC</a>(key_type) ? <a class="code hl_define" href="group__constants__sizes.html#ga69cd9eb2a526db33495fd9e97db6c988">IFX_SE_KEY_EXPORT_ECC_PUBLIC_KEY_MAX_SIZE</a>(key_bits) : \</div>
<div class="line">     0u)</div>
</div><!-- fragment -->
<p>Sufficient output buffer size for <a class="el" href="group__import__export.html#ga120a3d6cb22b2a2d438edf1cdebc560f" title="Export a public key or the public part of a key pair in binary format.">ifx_se_export_public_key()</a>. </p>
<p >This macro returns a compile-time constant if its arguments are compile-time constants.</p>
<dl class="section warning"><dt>Warning</dt><dd>This macro may evaluate its arguments multiple times or zero times, so you should not pass arguments that contain side effects.</dd></dl>
<p>The following code illustrates how to allocate enough memory to export a public key by querying the key type and size at runtime. </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__key__attributes.html#gad1ded78e935cd08ba08a5a27c003d7b3">ifx_se_key_attributes_t</a> attributes = <a class="code hl_define" href="group__key__attributes.html#ga5ad00c2092aaa27fc2a8fee1dedfadbc">IFX_SE_KEY_ATTRIBUTES_INIT</a>;</div>
<div class="line"><a class="code hl_struct" href="group__fih.html#structifx__se__fih__uint">ifx_se_status_t</a> status;</div>
<div class="line">status = <a class="code hl_function" href="group__key__attributes.html#ga9b1284c5dad22b4bd35ace36e03e3266">ifx_se_get_key_attributes</a>(key, &amp;attributes);</div>
<div class="line"><span class="keywordflow">if</span> (status != <a class="code hl_define" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47">IFX_SE_SUCCESS</a>) handle_error(...);</div>
<div class="line"><a class="code hl_typedef" href="group__crypto__types.html#ga562d12a9de8d6a287d98020515c6d438">ifx_se_key_type_t</a> key_type = <a class="code hl_function" href="group__crypto__types.html#gad6653f24190c92b3b744c7ce2aae9807">ifx_se_get_key_type</a>(&amp;attributes);</div>
<div class="line"><span class="keywordtype">size_t</span> key_bits = <a class="code hl_function" href="group__crypto__types.html#gaa7e96b37591bdfc95685da0c786ae5ed">ifx_se_get_key_bits</a>(&amp;attributes);</div>
<div class="line"><span class="keywordtype">size_t</span> buffer_size = <a class="code hl_define" href="group__constants__sizes.html#gaece8655cb723c849956466f8474f10f9">IFX_SE_EXPORT_PUBLIC_KEY_OUTPUT_SIZE</a>(key_type, key_bits);</div>
<div class="line"><a class="code hl_function" href="group__key__attributes.html#ga196181551fdce352b8d81d76ec144c1c">ifx_se_reset_key_attributes</a>(&amp;attributes);</div>
<div class="line">uint8_t *buffer = malloc(buffer_size);</div>
<div class="line"><span class="keywordflow">if</span> (buffer == NULL) handle_error(...);</div>
<div class="line"><span class="keywordtype">size_t</span> buffer_length;</div>
<div class="line">status = <a class="code hl_function" href="group__import__export.html#ga120a3d6cb22b2a2d438edf1cdebc560f">ifx_se_export_public_key</a>(key, buffer, buffer_size, &amp;buffer_length);</div>
<div class="line"><span class="keywordflow">if</span> (status != <a class="code hl_define" href="group__syscall__errors.html#ga9369eb56a5688c73fd213d7b740f9a47">IFX_SE_SUCCESS</a>) handle_error(...);</div>
<div class="ttc" id="agroup__constants__sizes_html_gaece8655cb723c849956466f8474f10f9"><div class="ttname"><a href="group__constants__sizes.html#gaece8655cb723c849956466f8474f10f9">IFX_SE_EXPORT_PUBLIC_KEY_OUTPUT_SIZE</a></div><div class="ttdeci">#define IFX_SE_EXPORT_PUBLIC_KEY_OUTPUT_SIZE(key_type, key_bits)</div><div class="ttdoc">Sufficient output buffer size for ifx_se_export_public_key().</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_sizes.h:693</div></div>
<div class="ttc" id="agroup__import__export_html_ga120a3d6cb22b2a2d438edf1cdebc560f"><div class="ttname"><a href="group__import__export.html#ga120a3d6cb22b2a2d438edf1cdebc560f">ifx_se_export_public_key</a></div><div class="ttdeci">ifx_se_status_t ifx_se_export_public_key(ifx_se_key_id_fih_t key, ifx_se_fih_ptr_t data, ifx_se_fih_t data_size, ifx_se_fih_ptr_t data_length, void *ctx)</div><div class="ttdoc">Export a public key or the public part of a key pair in binary format.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto.c:1052</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A public key or key pair key type. </td></tr>
    <tr><td class="paramname">key_bits</td><td>The size of the key in bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the parameters are valid and supported, return a buffer size in bytes that guarantees that <a class="el" href="group__import__export.html#ga120a3d6cb22b2a2d438edf1cdebc560f" title="Export a public key or the public part of a key pair in binary format.">ifx_se_export_public_key()</a> will not fail with <a class="el" href="group__psacrypto__error.html#ga9deeddae437b2f7a9ebf6f030fe00522" title="An output buffer is too small.">IFX_SE_ERROR_BUFFER_TOO_SMALL</a>. If the parameters are a valid combination that is not supported, return either a sensible size or 0. If the parameters are not valid, the return value is unspecified.</dd></dl>
<p>If the parameters are valid and supported, return the same result as <a class="el" href="group__constants__sizes.html#ga1222750b6bc259514a3f784cffd01165" title="Sufficient output buffer size for ifx_se_export_key() or ifx_se_export_public_key().">IFX_SE_EXPORT_KEY_OUTPUT_SIZE</a>( <code><a class="el" href="group__crypto__types.html#ga65880407522cd23a3398423fc81c46d2" title="The public key type corresponding to a key pair type.">IFX_SE_KEY_TYPE_PUBLIC_KEY_OF_KEY_PAIR</a></code>(<code>key_type</code>), <code>key_bits</code>). </p>

</div>
</div>
<a id="ga35e41b3adbcd1ee53ae335c978012d7d" name="ga35e41b3adbcd1ee53ae335c978012d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35e41b3adbcd1ee53ae335c978012d7d">&#9670;&nbsp;</a></span>IFX_SE_EXPORT_KEY_PAIR_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_EXPORT_KEY_PAIR_MAX_SIZE&#160;&#160;&#160;     <a class="el" href="group__constants__sizes.html#ga9de7c6911ef3cb793268d442d7520c26">IFX_SE_KEY_EXPORT_ECC_KEY_PAIR_MAX_SIZE</a>(<a class="el" href="group__constants__sizes.html#ga39f5e5fdc4276b750e9e446ffc86d09c">IFX_SE_VENDOR_ECC_MAX_CURVE_BITS</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sufficient buffer size for exporting any asymmetric key pair. </p>
<p >This macro expands to a compile-time constant integer. This value is a sufficient buffer size when calling <a class="el" href="group__import__export.html#ga4a53bdb503a45522b6555cc255364759" title="Export a key in binary format.">ifx_se_export_key()</a> to export any asymmetric key pair, regardless of the exact key type and key size.</p>
<p >See also <a class="el" href="group__constants__sizes.html#ga1222750b6bc259514a3f784cffd01165" title="Sufficient output buffer size for ifx_se_export_key() or ifx_se_export_public_key().">IFX_SE_EXPORT_KEY_OUTPUT_SIZE</a>(<code>key_type</code>, <code>key_bits</code>). </p>

</div>
</div>
<a id="ga14163c233baafff5514fd7a3a3e3e4b6" name="ga14163c233baafff5514fd7a3a3e3e4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14163c233baafff5514fd7a3a3e3e4b6">&#9670;&nbsp;</a></span>IFX_SE_EXPORT_PUBLIC_KEY_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_EXPORT_PUBLIC_KEY_MAX_SIZE&#160;&#160;&#160;     <a class="el" href="group__constants__sizes.html#ga69cd9eb2a526db33495fd9e97db6c988">IFX_SE_KEY_EXPORT_ECC_PUBLIC_KEY_MAX_SIZE</a>(<a class="el" href="group__constants__sizes.html#ga39f5e5fdc4276b750e9e446ffc86d09c">IFX_SE_VENDOR_ECC_MAX_CURVE_BITS</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sufficient buffer size for exporting any asymmetric public key. </p>
<p >This macro expands to a compile-time constant integer. This value is a sufficient buffer size when calling <a class="el" href="group__import__export.html#ga4a53bdb503a45522b6555cc255364759" title="Export a key in binary format.">ifx_se_export_key()</a> or <a class="el" href="group__import__export.html#ga120a3d6cb22b2a2d438edf1cdebc560f" title="Export a public key or the public part of a key pair in binary format.">ifx_se_export_public_key()</a> to export any asymmetric public key, regardless of the exact key type and key size.</p>
<p >See also <a class="el" href="group__constants__sizes.html#gaece8655cb723c849956466f8474f10f9" title="Sufficient output buffer size for ifx_se_export_public_key().">IFX_SE_EXPORT_PUBLIC_KEY_OUTPUT_SIZE</a>(<code>key_type</code>, <code>key_bits</code>). </p>

</div>
</div>
<a id="gad7d96d626f91d48517605ecbe0a585ce" name="gad7d96d626f91d48517605ecbe0a585ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7d96d626f91d48517605ecbe0a585ce">&#9670;&nbsp;</a></span>IFX_SE_RAW_KEY_AGREEMENT_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_RAW_KEY_AGREEMENT_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_bits&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__crypto__types.html#ga650a6f4b2d282b7fc02c3d7417e47af2">IFX_SE_KEY_TYPE_IS_ECC_KEY_PAIR</a>(key_type) ?                   \</div>
<div class="line">     IFX_SE_BITS_TO_BYTES(key_bits) :                              \</div>
<div class="line">     0u)</div>
</div><!-- fragment -->
<p>Sufficient output buffer size for <a class="el" href="group__key__derivation.html#gaad36f8eff1151d8ae5b9a9e204cd32c3" title="Perform a key agreement and return the raw shared secret.">ifx_se_raw_key_agreement()</a>. </p>
<p >This macro returns a compile-time constant if its arguments are compile-time constants.</p>
<dl class="section warning"><dt>Warning</dt><dd>This macro may evaluate its arguments multiple times or zero times, so you should not pass arguments that contain side effects.</dd></dl>
<p>See also <a class="el" href="group__constants__sizes.html#ga829bcbdc55e2d936296dae2e0ccc8a0f" title="Maximum size of the output from ifx_se_raw_key_agreement().">IFX_SE_RAW_KEY_AGREEMENT_OUTPUT_MAX_SIZE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A supported key type. </td></tr>
    <tr><td class="paramname">key_bits</td><td>The size of the key in bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the parameters are valid and supported, return a buffer size in bytes that guarantees that <a class="el" href="group__key__derivation.html#gaad36f8eff1151d8ae5b9a9e204cd32c3" title="Perform a key agreement and return the raw shared secret.">ifx_se_raw_key_agreement()</a> will not fail with <a class="el" href="group__psacrypto__error.html#ga9deeddae437b2f7a9ebf6f030fe00522" title="An output buffer is too small.">IFX_SE_ERROR_BUFFER_TOO_SMALL</a>. If the parameters are a valid combination that is not supported, return either a sensible size or 0. If the parameters are not valid, the return value is unspecified. </dd></dl>

</div>
</div>
<a id="ga829bcbdc55e2d936296dae2e0ccc8a0f" name="ga829bcbdc55e2d936296dae2e0ccc8a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829bcbdc55e2d936296dae2e0ccc8a0f">&#9670;&nbsp;</a></span>IFX_SE_RAW_KEY_AGREEMENT_OUTPUT_MAX_SIZE <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_RAW_KEY_AGREEMENT_OUTPUT_MAX_SIZE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size of the output from <a class="el" href="group__key__derivation.html#gaad36f8eff1151d8ae5b9a9e204cd32c3" title="Perform a key agreement and return the raw shared secret.">ifx_se_raw_key_agreement()</a>. </p>
<p >This macro expands to a compile-time constant integer. This value is the maximum size of the output any raw key agreement algorithm, in bytes.</p>
<p >See also <a class="el" href="group__constants__sizes.html#gad7d96d626f91d48517605ecbe0a585ce" title="Sufficient output buffer size for ifx_se_raw_key_agreement().">IFX_SE_RAW_KEY_AGREEMENT_OUTPUT_SIZE</a>(<code>key_type</code>, <code>key_bits</code>). </p>

</div>
</div>
<a id="ga829bcbdc55e2d936296dae2e0ccc8a0f" name="ga829bcbdc55e2d936296dae2e0ccc8a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829bcbdc55e2d936296dae2e0ccc8a0f">&#9670;&nbsp;</a></span>IFX_SE_RAW_KEY_AGREEMENT_OUTPUT_MAX_SIZE <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_RAW_KEY_AGREEMENT_OUTPUT_MAX_SIZE&#160;&#160;&#160;IFX_SE_BITS_TO_BYTES(<a class="el" href="group__constants__sizes.html#ga39f5e5fdc4276b750e9e446ffc86d09c">IFX_SE_VENDOR_ECC_MAX_CURVE_BITS</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size of the output from <a class="el" href="group__key__derivation.html#gaad36f8eff1151d8ae5b9a9e204cd32c3" title="Perform a key agreement and return the raw shared secret.">ifx_se_raw_key_agreement()</a>. </p>
<p >This macro expands to a compile-time constant integer. This value is the maximum size of the output any raw key agreement algorithm, in bytes.</p>
<p >See also <a class="el" href="group__constants__sizes.html#gad7d96d626f91d48517605ecbe0a585ce" title="Sufficient output buffer size for ifx_se_raw_key_agreement().">IFX_SE_RAW_KEY_AGREEMENT_OUTPUT_SIZE</a>(<code>key_type</code>, <code>key_bits</code>). </p>

</div>
</div>
<a id="ga46a6ebbb4b75aa5f3f03318786cc120f" name="ga46a6ebbb4b75aa5f3f03318786cc120f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46a6ebbb4b75aa5f3f03318786cc120f">&#9670;&nbsp;</a></span>IFX_SE_CIPHER_IV_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_CIPHER_IV_LENGTH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__crypto__types.html#ga249c8f65fc5e3a56a2d22981987bdfb2">IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH</a>(key_type) &gt; 1 &amp;&amp; \</div>
<div class="line">        ((alg) == <a class="code hl_define" href="group__crypto__algs.html#ga4856146efb9703cadad995db7c4f61bb">IFX_SE_ALG_CTR</a> || \</div>
<div class="line">         (alg) == <a class="code hl_define" href="group__crypto__algs.html#gae2393aa83af9bcdf8b1800cd3889e871">IFX_SE_ALG_CBC_NO_PADDING</a> || \</div>
<div class="line">         (alg) == <a class="code hl_define" href="group__crypto__algs.html#gaabc7e5acd2c39c3fdb7f1d9126f72568">IFX_SE_ALG_CBC_PKCS7</a>) ? <a class="code hl_define" href="group__crypto__types.html#ga249c8f65fc5e3a56a2d22981987bdfb2">IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH</a>(key_type) : \</div>
<div class="line">         0u)</div>
<div class="ttc" id="agroup__crypto__algs_html_ga4856146efb9703cadad995db7c4f61bb"><div class="ttname"><a href="group__crypto__algs.html#ga4856146efb9703cadad995db7c4f61bb">IFX_SE_ALG_CTR</a></div><div class="ttdeci">#define IFX_SE_ALG_CTR</div><div class="ttdoc">The CTR stream cipher mode.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:1171</div></div>
<div class="ttc" id="agroup__crypto__algs_html_gaabc7e5acd2c39c3fdb7f1d9126f72568"><div class="ttname"><a href="group__crypto__algs.html#gaabc7e5acd2c39c3fdb7f1d9126f72568">IFX_SE_ALG_CBC_PKCS7</a></div><div class="ttdeci">#define IFX_SE_ALG_CBC_PKCS7</div><div class="ttdoc">The CBC block cipher chaining mode with PKCS#7 padding.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:1228</div></div>
<div class="ttc" id="agroup__crypto__algs_html_gae2393aa83af9bcdf8b1800cd3889e871"><div class="ttname"><a href="group__crypto__algs.html#gae2393aa83af9bcdf8b1800cd3889e871">IFX_SE_ALG_CBC_NO_PADDING</a></div><div class="ttdeci">#define IFX_SE_ALG_CBC_NO_PADDING</div><div class="ttdoc">The CBC block cipher chaining mode, with no padding.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:1220</div></div>
</div><!-- fragment -->
<p>The default IV size for a cipher algorithm, in bytes. </p>
<p >The IV that is generated as part of a call to <a class="el" href="group__cipher__operations.html#gaeee781aa1fb49cd63e4ae965236b50e3" title="Encrypt a message using a symmetric cipher with provided IV.">ifx_se_cipher_encrypt()</a> is always the default IV length for the algorithm.</p>
<p >This macro can be used to allocate a buffer of sufficient size to store the IV output from <a class="el" href="group__cipher__operations.html#ga3e3dc6498c391fd414fa189037d1a327" title="Generate an IV for a symmetric encryption operation.">ifx_se_cipher_generate_iv()</a> when using a multi-part cipher operation.</p>
<p >See also <a class="el" href="group__constants__sizes.html#ga932d510c0ff49d175395c01acb03c62d" title="The maximum IV size for all supported cipher algorithms, in bytes.">IFX_SE_CIPHER_IV_MAX_SIZE</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This macro may evaluate its arguments multiple times or zero times, so you should not pass arguments that contain side effects.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A symmetric key type that is compatible with algorithm <code>alg</code>.</td></tr>
    <tr><td class="paramname">alg</td><td>A cipher algorithm (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#ga96bb00aabcb689991a0552849b2b1111" title="Whether the specified algorithm is a symmetric cipher algorithm.">IFX_SE_ALG_IS_CIPHER</a>(<code>alg</code>) is true).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The default IV size for the specified key type and algorithm. If the algorithm does not use an IV, return 0. If the key type or cipher algorithm is not recognized, or the parameters are incompatible, return 0. </dd></dl>

</div>
</div>
<a id="ga932d510c0ff49d175395c01acb03c62d" name="ga932d510c0ff49d175395c01acb03c62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga932d510c0ff49d175395c01acb03c62d">&#9670;&nbsp;</a></span>IFX_SE_CIPHER_IV_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_CIPHER_IV_MAX_SIZE&#160;&#160;&#160;16u</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum IV size for all supported cipher algorithms, in bytes. </p>
<p >See also <a class="el" href="group__constants__sizes.html#ga46a6ebbb4b75aa5f3f03318786cc120f" title="The default IV size for a cipher algorithm, in bytes.">IFX_SE_CIPHER_IV_LENGTH()</a>. </p>

</div>
</div>
<a id="ga5fe733f9c479459aef5e84608c2e6250" name="ga5fe733f9c479459aef5e84608c2e6250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fe733f9c479459aef5e84608c2e6250">&#9670;&nbsp;</a></span>IFX_SE_CIPHER_ENCRYPT_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_CIPHER_ENCRYPT_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input_length&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (alg == <a class="code hl_define" href="group__crypto__algs.html#gaabc7e5acd2c39c3fdb7f1d9126f72568">IFX_SE_ALG_CBC_PKCS7</a> ?                                                 \</div>
<div class="line">     (<a class="code hl_define" href="group__crypto__types.html#ga249c8f65fc5e3a56a2d22981987bdfb2">IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH</a>(key_type) != 0 ?                            \</div>
<div class="line">     IFX_SE_ROUND_UP_TO_MULTIPLE(<a class="code hl_define" href="group__crypto__types.html#ga249c8f65fc5e3a56a2d22981987bdfb2">IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH</a>(key_type),          \</div>
<div class="line">                              (input_length) + 1u) +                             \</div>
<div class="line">     IFX_SE_CIPHER_IV_LENGTH((key_type), (alg)) : 0u) :                             \</div>
<div class="line">     (<a class="code hl_define" href="group__crypto__algs.html#ga96bb00aabcb689991a0552849b2b1111">IFX_SE_ALG_IS_CIPHER</a>(alg) ?                                                  \</div>
<div class="line">      (input_length) + <a class="code hl_define" href="group__constants__sizes.html#ga46a6ebbb4b75aa5f3f03318786cc120f">IFX_SE_CIPHER_IV_LENGTH</a>((key_type), (alg)) :                \</div>
<div class="line">     0u))</div>
<div class="ttc" id="agroup__constants__sizes_html_ga46a6ebbb4b75aa5f3f03318786cc120f"><div class="ttname"><a href="group__constants__sizes.html#ga46a6ebbb4b75aa5f3f03318786cc120f">IFX_SE_CIPHER_IV_LENGTH</a></div><div class="ttdeci">#define IFX_SE_CIPHER_IV_LENGTH(key_type, alg)</div><div class="ttdoc">The default IV size for a cipher algorithm, in bytes.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_sizes.h:787</div></div>
<div class="ttc" id="agroup__crypto__algs_html_ga96bb00aabcb689991a0552849b2b1111"><div class="ttname"><a href="group__crypto__algs.html#ga96bb00aabcb689991a0552849b2b1111">IFX_SE_ALG_IS_CIPHER</a></div><div class="ttdeci">#define IFX_SE_ALG_IS_CIPHER(alg)</div><div class="ttdoc">Whether the specified algorithm is a symmetric cipher algorithm.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:812</div></div>
</div><!-- fragment -->
<p>The maximum size of the output of <a class="el" href="group__cipher__operations.html#gaeee781aa1fb49cd63e4ae965236b50e3" title="Encrypt a message using a symmetric cipher with provided IV.">ifx_se_cipher_encrypt()</a>, in bytes. </p>
<p >If the size of the output buffer is at least this large, it is guaranteed that <a class="el" href="group__cipher__operations.html#gaeee781aa1fb49cd63e4ae965236b50e3" title="Encrypt a message using a symmetric cipher with provided IV.">ifx_se_cipher_encrypt()</a> will not fail due to an insufficient buffer size. Depending on the algorithm, the actual size of the output might be smaller.</p>
<p >See also <a class="el" href="group__constants__sizes.html#ga4af584fa9db0035c29faa9e97610cd4f" title="A sufficient output buffer size for ifx_se_cipher_encrypt(), for any of the supported key types and c...">IFX_SE_CIPHER_ENCRYPT_OUTPUT_MAX_SIZE</a>(<code>input_length</code>).</p>
<dl class="section warning"><dt>Warning</dt><dd>This macro may evaluate its arguments multiple times or zero times, so you should not pass arguments that contain side effects.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A symmetric key type that is compatible with algorithm alg. </td></tr>
    <tr><td class="paramname">alg</td><td>A cipher algorithm (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#ga96bb00aabcb689991a0552849b2b1111" title="Whether the specified algorithm is a symmetric cipher algorithm.">IFX_SE_ALG_IS_CIPHER</a>(<code>alg</code>) is true). </td></tr>
    <tr><td class="paramname">input_length</td><td>Size of the input in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sufficient output size for the specified key type and algorithm. If the key type or cipher algorithm is not recognized, or the parameters are incompatible, return 0. </dd></dl>

</div>
</div>
<a id="ga4af584fa9db0035c29faa9e97610cd4f" name="ga4af584fa9db0035c29faa9e97610cd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4af584fa9db0035c29faa9e97610cd4f">&#9670;&nbsp;</a></span>IFX_SE_CIPHER_ENCRYPT_OUTPUT_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_CIPHER_ENCRYPT_OUTPUT_MAX_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input_length</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (IFX_SE_ROUND_UP_TO_MULTIPLE(<a class="code hl_define" href="group__constants__sizes.html#ga45af326ee82009b61b2d48dbd1048757">IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</a>,                  \</div>
<div class="line">                              (input_length) + 1u) +                             \</div>
<div class="line">     IFX_SE_CIPHER_IV_MAX_SIZE)</div>
<div class="ttc" id="agroup__constants__sizes_html_ga45af326ee82009b61b2d48dbd1048757"><div class="ttname"><a href="group__constants__sizes.html#ga45af326ee82009b61b2d48dbd1048757">IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</a></div><div class="ttdeci">#define IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</div><div class="ttdoc">The maximum size of a block cipher.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_sizes.h:220</div></div>
</div><!-- fragment -->
<p>A sufficient output buffer size for <a class="el" href="group__cipher__operations.html#gaeee781aa1fb49cd63e4ae965236b50e3" title="Encrypt a message using a symmetric cipher with provided IV.">ifx_se_cipher_encrypt()</a>, for any of the supported key types and cipher algorithms. </p>
<p >If the size of the output buffer is at least this large, it is guaranteed that <a class="el" href="group__cipher__operations.html#gaeee781aa1fb49cd63e4ae965236b50e3" title="Encrypt a message using a symmetric cipher with provided IV.">ifx_se_cipher_encrypt()</a> will not fail due to an insufficient buffer size.</p>
<p >See also <a class="el" href="group__constants__sizes.html#ga5fe733f9c479459aef5e84608c2e6250" title="The maximum size of the output of ifx_se_cipher_encrypt(), in bytes.">IFX_SE_CIPHER_ENCRYPT_OUTPUT_SIZE</a>(<code>key_type</code>, <code>alg</code>, <code>input_length</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_length</td><td>Size of the input in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2ea52a825d5762baa0d2b4227c2c852" name="gaf2ea52a825d5762baa0d2b4227c2c852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ea52a825d5762baa0d2b4227c2c852">&#9670;&nbsp;</a></span>IFX_SE_CIPHER_DECRYPT_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_CIPHER_DECRYPT_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input_length&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__crypto__algs.html#ga96bb00aabcb689991a0552849b2b1111">IFX_SE_ALG_IS_CIPHER</a>(alg) &amp;&amp;                                                      \</div>
<div class="line">     ((key_type) &amp; IFX_SE_KEY_TYPE_CATEGORY_MASK) == IFX_SE_KEY_TYPE_CATEGORY_SYMMETRIC ? \</div>
<div class="line">     (input_length) :                                                               \</div>
<div class="line">     0u)</div>
</div><!-- fragment -->
<p>The maximum size of the output of <a class="el" href="group__cipher__operations.html#gac7bee80fdabbfdcdf6f7b63589da4f1e" title="Decrypt a message using a symmetric cipher.">ifx_se_cipher_decrypt()</a>, in bytes. </p>
<p >If the size of the output buffer is at least this large, it is guaranteed that <a class="el" href="group__cipher__operations.html#gac7bee80fdabbfdcdf6f7b63589da4f1e" title="Decrypt a message using a symmetric cipher.">ifx_se_cipher_decrypt()</a> will not fail due to an insufficient buffer size. Depending on the algorithm, the actual size of the output might be smaller.</p>
<p >See also <a class="el" href="group__constants__sizes.html#gaaadeef370df21730b4a379b64c57add0" title="A sufficient output buffer size for ifx_se_cipher_decrypt(), for any of the supported key types and c...">IFX_SE_CIPHER_DECRYPT_OUTPUT_MAX_SIZE</a>(<code>input_length</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A symmetric key type that is compatible with algorithm alg. </td></tr>
    <tr><td class="paramname">alg</td><td>A cipher algorithm (<code>IFX_SE_ALG_XXX</code> value such that <a class="el" href="group__crypto__algs.html#ga96bb00aabcb689991a0552849b2b1111" title="Whether the specified algorithm is a symmetric cipher algorithm.">IFX_SE_ALG_IS_CIPHER</a>(<code>alg</code>) is true). </td></tr>
    <tr><td class="paramname">input_length</td><td>Size of the input in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sufficient output size for the specified key type and algorithm. If the key type or cipher algorithm is not recognized, or the parameters are incompatible, return 0. </dd></dl>

</div>
</div>
<a id="gaaadeef370df21730b4a379b64c57add0" name="gaaadeef370df21730b4a379b64c57add0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaadeef370df21730b4a379b64c57add0">&#9670;&nbsp;</a></span>IFX_SE_CIPHER_DECRYPT_OUTPUT_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_CIPHER_DECRYPT_OUTPUT_MAX_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input_length</td><td>)</td>
          <td>&#160;&#160;&#160;    (input_length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sufficient output buffer size for <a class="el" href="group__cipher__operations.html#gac7bee80fdabbfdcdf6f7b63589da4f1e" title="Decrypt a message using a symmetric cipher.">ifx_se_cipher_decrypt()</a>, for any of the supported key types and cipher algorithms. </p>
<p >If the size of the output buffer is at least this large, it is guaranteed that <a class="el" href="group__cipher__operations.html#gac7bee80fdabbfdcdf6f7b63589da4f1e" title="Decrypt a message using a symmetric cipher.">ifx_se_cipher_decrypt()</a> will not fail due to an insufficient buffer size.</p>
<p >See also <a class="el" href="group__constants__sizes.html#gaf2ea52a825d5762baa0d2b4227c2c852" title="The maximum size of the output of ifx_se_cipher_decrypt(), in bytes.">IFX_SE_CIPHER_DECRYPT_OUTPUT_SIZE</a>(<code>key_type</code>, <code>alg</code>, <code>input_length</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_length</td><td>Size of the input in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa948930db4125ccca73ca9b5f260bdb1" name="gaa948930db4125ccca73ca9b5f260bdb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa948930db4125ccca73ca9b5f260bdb1">&#9670;&nbsp;</a></span>IFX_SE_CIPHER_UPDATE_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_CIPHER_UPDATE_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input_length&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__crypto__algs.html#ga96bb00aabcb689991a0552849b2b1111">IFX_SE_ALG_IS_CIPHER</a>(alg) ?                                                   \</div>
<div class="line">    (<a class="code hl_define" href="group__crypto__types.html#ga249c8f65fc5e3a56a2d22981987bdfb2">IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH</a>(key_type) != 0 ?                             \</div>
<div class="line">     (((alg) == <a class="code hl_define" href="group__crypto__algs.html#gaabc7e5acd2c39c3fdb7f1d9126f72568">IFX_SE_ALG_CBC_PKCS7</a>      ||                                       \</div>
<div class="line">       (alg) == <a class="code hl_define" href="group__crypto__algs.html#gae2393aa83af9bcdf8b1800cd3889e871">IFX_SE_ALG_CBC_NO_PADDING</a> ||                                       \</div>
<div class="line">       (alg) == <a class="code hl_define" href="group__crypto__algs.html#ga0e46eee46f79a2b74d55c02882456e8f">IFX_SE_ALG_ECB_NO_PADDING</a>) ?                                       \</div>
<div class="line">      IFX_SE_ROUND_UP_TO_MULTIPLE(<a class="code hl_define" href="group__crypto__types.html#ga249c8f65fc5e3a56a2d22981987bdfb2">IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH</a>(key_type),         \</div>
<div class="line">                                input_length) :                                 \</div>
<div class="line">      (input_length)) : 0u) :                                                    \</div>
<div class="line">     0u)</div>
<div class="ttc" id="agroup__crypto__algs_html_ga0e46eee46f79a2b74d55c02882456e8f"><div class="ttname"><a href="group__crypto__algs.html#ga0e46eee46f79a2b74d55c02882456e8f">IFX_SE_ALG_ECB_NO_PADDING</a></div><div class="ttdeci">#define IFX_SE_ALG_ECB_NO_PADDING</div><div class="ttdoc">The Electronic Code Book (ECB) mode of a block cipher, with no padding.</div><div class="ttdef"><b>Definition:</b> ifx_se_psacrypto_values.h:1211</div></div>
</div><!-- fragment -->
<p>A sufficient output buffer size for <a class="el" href="group__cipher__operations.html#ga7b8d71cf584073e170643dbcfb3b65e1" title="Encrypt or decrypt a message fragment in an active cipher operation.">ifx_se_cipher_update()</a>. </p>
<p >If the size of the output buffer is at least this large, it is guaranteed that <a class="el" href="group__cipher__operations.html#ga7b8d71cf584073e170643dbcfb3b65e1" title="Encrypt or decrypt a message fragment in an active cipher operation.">ifx_se_cipher_update()</a> will not fail due to an insufficient buffer size. The actual size of the output might be smaller in any given call.</p>
<p >See also <a class="el" href="group__constants__sizes.html#gae039b00e80973aedad17435d6e7272d5" title="A sufficient output buffer size for ifx_se_cipher_update(), for any of the supported key types and ci...">IFX_SE_CIPHER_UPDATE_OUTPUT_MAX_SIZE</a>(<code>input_length</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A symmetric key type that is compatible with algorithm alg. </td></tr>
    <tr><td class="paramname">alg</td><td>A cipher algorithm (IFX_SE_ALG_XXX value such that <a class="el" href="group__crypto__algs.html#ga96bb00aabcb689991a0552849b2b1111" title="Whether the specified algorithm is a symmetric cipher algorithm.">IFX_SE_ALG_IS_CIPHER</a>(<code>alg</code>) is true). </td></tr>
    <tr><td class="paramname">input_length</td><td>Size of the input in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sufficient output size for the specified key type and algorithm. If the key type or cipher algorithm is not recognized, or the parameters are incompatible, return 0. </dd></dl>

</div>
</div>
<a id="gae039b00e80973aedad17435d6e7272d5" name="gae039b00e80973aedad17435d6e7272d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae039b00e80973aedad17435d6e7272d5">&#9670;&nbsp;</a></span>IFX_SE_CIPHER_UPDATE_OUTPUT_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_CIPHER_UPDATE_OUTPUT_MAX_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input_length</td><td>)</td>
          <td>&#160;&#160;&#160;    (IFX_SE_ROUND_UP_TO_MULTIPLE(<a class="el" href="group__constants__sizes.html#ga45af326ee82009b61b2d48dbd1048757">IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</a>, input_length))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sufficient output buffer size for <a class="el" href="group__cipher__operations.html#ga7b8d71cf584073e170643dbcfb3b65e1" title="Encrypt or decrypt a message fragment in an active cipher operation.">ifx_se_cipher_update()</a>, for any of the supported key types and cipher algorithms. </p>
<p >If the size of the output buffer is at least this large, it is guaranteed that <a class="el" href="group__cipher__operations.html#ga7b8d71cf584073e170643dbcfb3b65e1" title="Encrypt or decrypt a message fragment in an active cipher operation.">ifx_se_cipher_update()</a> will not fail due to an insufficient buffer size.</p>
<p >See also <a class="el" href="group__constants__sizes.html#gaa948930db4125ccca73ca9b5f260bdb1" title="A sufficient output buffer size for ifx_se_cipher_update().">IFX_SE_CIPHER_UPDATE_OUTPUT_SIZE</a>(<code>key_type</code>, <code>alg</code>, <code>input_length</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_length</td><td>Size of the input in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f23e81bf35448d7aad3e29ee11a8a33" name="ga6f23e81bf35448d7aad3e29ee11a8a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f23e81bf35448d7aad3e29ee11a8a33">&#9670;&nbsp;</a></span>IFX_SE_CIPHER_FINISH_OUTPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_CIPHER_FINISH_OUTPUT_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code hl_define" href="group__crypto__algs.html#ga96bb00aabcb689991a0552849b2b1111">IFX_SE_ALG_IS_CIPHER</a>(alg) ?                           \</div>
<div class="line">     (alg == <a class="code hl_define" href="group__crypto__algs.html#gaabc7e5acd2c39c3fdb7f1d9126f72568">IFX_SE_ALG_CBC_PKCS7</a> ?                        \</div>
<div class="line">      IFX_SE_BLOCK_CIPHER_BLOCK_LENGTH(key_type) :         \</div>
<div class="line">      0u) :                                              \</div>
<div class="line">     0u)</div>
</div><!-- fragment -->
<p>A sufficient ciphertext buffer size for <a class="el" href="group__cipher__operations.html#ga966417e3efb26f0453f3c1d93b3b4403" title="Finish encrypting or decrypting a message in a cipher operation.">ifx_se_cipher_finish()</a>. </p>
<p >If the size of the ciphertext buffer is at least this large, it is guaranteed that <a class="el" href="group__cipher__operations.html#ga966417e3efb26f0453f3c1d93b3b4403" title="Finish encrypting or decrypting a message in a cipher operation.">ifx_se_cipher_finish()</a> will not fail due to an insufficient ciphertext buffer size. The actual size of the output might be smaller in any given call.</p>
<p >See also <a class="el" href="group__constants__sizes.html#ga099608392403a28feb1516835c3ff64f" title="A sufficient ciphertext buffer size for ifx_se_cipher_finish(), for any of the supported key types an...">IFX_SE_CIPHER_FINISH_OUTPUT_MAX_SIZE()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_type</td><td>A symmetric key type that is compatible with algorithm alg. </td></tr>
    <tr><td class="paramname">alg</td><td>A cipher algorithm (IFX_SE_ALG_XXX value such that <a class="el" href="group__crypto__algs.html#ga96bb00aabcb689991a0552849b2b1111" title="Whether the specified algorithm is a symmetric cipher algorithm.">IFX_SE_ALG_IS_CIPHER</a>(<code>alg</code>) is true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sufficient output size for the specified key type and algorithm. If the key type or cipher algorithm is not recognized, or the parameters are incompatible, return 0. </dd></dl>

</div>
</div>
<a id="ga099608392403a28feb1516835c3ff64f" name="ga099608392403a28feb1516835c3ff64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga099608392403a28feb1516835c3ff64f">&#9670;&nbsp;</a></span>IFX_SE_CIPHER_FINISH_OUTPUT_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SE_CIPHER_FINISH_OUTPUT_MAX_SIZE&#160;&#160;&#160;    (<a class="el" href="group__constants__sizes.html#ga45af326ee82009b61b2d48dbd1048757">IFX_SE_BLOCK_CIPHER_BLOCK_MAX_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sufficient ciphertext buffer size for <a class="el" href="group__cipher__operations.html#ga966417e3efb26f0453f3c1d93b3b4403" title="Finish encrypting or decrypting a message in a cipher operation.">ifx_se_cipher_finish()</a>, for any of the supported key types and cipher algorithms. </p>
<p >See also <a class="el" href="group__constants__sizes.html#ga6f23e81bf35448d7aad3e29ee11a8a33" title="A sufficient ciphertext buffer size for ifx_se_cipher_finish().">IFX_SE_CIPHER_FINISH_OUTPUT_SIZE</a>(<code>key_type</code>, <code>alg</code>). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>SE RT Services Utilities library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
