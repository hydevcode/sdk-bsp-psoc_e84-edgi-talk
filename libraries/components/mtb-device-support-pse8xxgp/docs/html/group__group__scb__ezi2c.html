<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSOC E8XXGP Device Support Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSOC E8XXGP Device Support Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__scb__ezi2c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle"><div class="title">EZI2C (SCB)<div class="ingroups"><a class="el" href="group__group__pdl__top.html">PDL API Reference</a> &raquo; <a class="el" href="group__group__scb.html">SCB          (Serial Communication Block)</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p >Driver API for EZI2C Slave Peripheral. </p>
<p >The functions and other declarations used in this part of the driver are in cy_scb_ezi2c.h. You can also include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<p >I2C - The Inter-Integrated Circuit (I2C) bus is an industry-standard.</p>
<p >The EZI2C slave peripheral driver provides an API to implement the I2C slave device based on the SCB hardware block. This slave device emulates a common I2C EEPROM interface that acts like dual-port memory between the external master and your code. I2C devices based on the SCB hardware are compatible with the I2C Standard mode, Fast mode, and Fast mode Plus specifications, as defined in the I2C bus specification.</p>
<p >EZI2C slave is a special implementation of the I2C that handles all communication between the master and slave through ISR (interrupt service routine) and requires no interaction with the main program flow from the slave side. The EZI2C should be used when a shared memory model between the I2C master and I2C slave is needed.</p>
<p >Features:</p><ul>
<li>An industry-standard I2C bus interface</li>
<li>Supports standard data rates of 100/400/1000 kbps</li>
<li>Emulates a common I2C EEPROM Interface</li>
<li>Acts like dual-port memory between the external master and your code</li>
<li>Supports Hardware Address Match</li>
<li>Supports two hardware addresses with separate buffers</li>
<li>On deep sleep-capable SCB, it supports wake from deep sleep on address match</li>
<li>Simple to set up and use; does not require calling EZI2C API at run time.</li>
</ul>
<h1><a class="anchor" id="group_scb_ezi2c_configuration"></a>
Configuration Considerations</h1>
<p >The EZI2C slave driver configuration can be divided to number of sequential steps listed below:</p><ul>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_config">Configure EZI2C slave</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_pins">Assign and Configure Pins</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_clock">Assign Clock Divider</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_data_rate">Configure Data Rate</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_intr">Configure Interrupt</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_enable">Enable EZI2C slave</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>EZI2C slave driver is built on top of the SCB hardware block. The SCB3 instance is used as an example for all code snippets. Modify the code to match your design.</dd></dl>
<h2><a class="anchor" id="group_scb_ezi2c_config"></a>
Configure EZI2C slave</h2>
<p >To set up the EZI2C slave driver, provide the configuration parameters in the <a class="el" href="group__group__scb__ezi2c__data__structures.html#structcy__stc__scb__ezi2c__config__t">cy_stc_scb_ezi2c_config_t</a> structure. The primary slave address slaveAddress1 must be provided. The other parameters are optional for operation. To initialize the driver, call <a class="el" href="group__group__scb__ezi2c__general__functions.html#gaafe61aa4c2931975a8698afa46717b97">Cy_SCB_EZI2C_Init</a> function providing a pointer to the populated <a class="el" href="group__group__scb__ezi2c__data__structures.html#structcy__stc__scb__ezi2c__config__t">cy_stc_scb_ezi2c_config_t</a> structure and the allocated <a class="el" href="group__group__scb__ezi2c__data__structures.html#structcy__stc__scb__ezi2c__context__t">cy_stc_scb_ezi2c_context_t</a> structure.</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate context for EZI2C operation */</span></div>
<div class="line"><a class="code hl_struct" href="group__group__scb__ezi2c__data__structures.html#structcy__stc__scb__ezi2c__context__t">cy_stc_scb_ezi2c_context_t</a> ezI2cContext;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Populate configuration structure */</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="group__group__scb__ezi2c__data__structures.html#structcy__stc__scb__ezi2c__config__t">cy_stc_scb_ezi2c_config_t</a> ezI2cConfig =</div>
<div class="line">{</div>
<div class="line">    .<a class="code hl_variable" href="group__group__scb__ezi2c__data__structures.html#aa3405d940eb60a40f7de1580eb391c71">numberOfAddresses</a> = <a class="code hl_enumvalue" href="group__group__scb__ezi2c__enums.html#gga5e20e1c00a75b3467305aa839271697aa88d5060e586a93a7e1c77885dee8c5cf">CY_SCB_EZI2C_ONE_ADDRESS</a>,</div>
<div class="line">    .slaveAddress1     = 0x08U,</div>
<div class="line">    .slaveAddress2     = 0x00U,</div>
<div class="line">    .subAddressSize    = <a class="code hl_enumvalue" href="group__group__scb__ezi2c__enums.html#gga2a4845448404203987f881e2e907feffa313bce9b46a4ce11f0d2891842e98ee6">CY_SCB_EZI2C_SUB_ADDR8_BITS</a>,</div>
<div class="line">    .enableWakeFromSleep = <span class="keyword">false</span>,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Configure EZI2C slave */</span></div>
<div class="line">(void) <a class="code hl_function" href="group__group__scb__ezi2c__general__functions.html#gaafe61aa4c2931975a8698afa46717b97">Cy_SCB_EZI2C_Init</a>(SCB3, &amp;ezI2cConfig, &amp;ezI2cContext);</div>
<div class="ttc" id="agroup__group__scb__ezi2c__data__structures_html_aa3405d940eb60a40f7de1580eb391c71"><div class="ttname"><a href="group__group__scb__ezi2c__data__structures.html#aa3405d940eb60a40f7de1580eb391c71">cy_stc_scb_ezi2c_config_t::numberOfAddresses</a></div><div class="ttdeci">cy_en_scb_ezi2c_num_of_addr_t numberOfAddresses</div><div class="ttdoc">The number of supported addresses either.</div><div class="ttdef"><b>Definition:</b> cy_scb_ezi2c.h:314</div></div>
<div class="ttc" id="agroup__group__scb__ezi2c__data__structures_html_structcy__stc__scb__ezi2c__config__t"><div class="ttname"><a href="group__group__scb__ezi2c__data__structures.html#structcy__stc__scb__ezi2c__config__t">cy_stc_scb_ezi2c_config_t</a></div><div class="ttdoc">EZI2C slave configuration structure.</div><div class="ttdef"><b>Definition:</b> cy_scb_ezi2c.h:312</div></div>
<div class="ttc" id="agroup__group__scb__ezi2c__data__structures_html_structcy__stc__scb__ezi2c__context__t"><div class="ttname"><a href="group__group__scb__ezi2c__data__structures.html#structcy__stc__scb__ezi2c__context__t">cy_stc_scb_ezi2c_context_t</a></div><div class="ttdoc">EZI2C slave context structure.</div><div class="ttdef"><b>Definition:</b> cy_scb_ezi2c.h:341</div></div>
<div class="ttc" id="agroup__group__scb__ezi2c__enums_html_gga2a4845448404203987f881e2e907feffa313bce9b46a4ce11f0d2891842e98ee6"><div class="ttname"><a href="group__group__scb__ezi2c__enums.html#gga2a4845448404203987f881e2e907feffa313bce9b46a4ce11f0d2891842e98ee6">CY_SCB_EZI2C_SUB_ADDR8_BITS</a></div><div class="ttdeci">@ CY_SCB_EZI2C_SUB_ADDR8_BITS</div><div class="ttdoc">Sub-address is 8 bits</div><div class="ttdef"><b>Definition:</b> cy_scb_ezi2c.h:281</div></div>
<div class="ttc" id="agroup__group__scb__ezi2c__enums_html_gga5e20e1c00a75b3467305aa839271697aa88d5060e586a93a7e1c77885dee8c5cf"><div class="ttname"><a href="group__group__scb__ezi2c__enums.html#gga5e20e1c00a75b3467305aa839271697aa88d5060e586a93a7e1c77885dee8c5cf">CY_SCB_EZI2C_ONE_ADDRESS</a></div><div class="ttdeci">@ CY_SCB_EZI2C_ONE_ADDRESS</div><div class="ttdoc">Only one address.</div><div class="ttdef"><b>Definition:</b> cy_scb_ezi2c.h:274</div></div>
<div class="ttc" id="agroup__group__scb__ezi2c__general__functions_html_gaafe61aa4c2931975a8698afa46717b97"><div class="ttname"><a href="group__group__scb__ezi2c__general__functions.html#gaafe61aa4c2931975a8698afa46717b97">Cy_SCB_EZI2C_Init</a></div><div class="ttdeci">cy_en_scb_ezi2c_status_t Cy_SCB_EZI2C_Init(CySCB_Type *base, cy_stc_scb_ezi2c_config_t const *config, cy_stc_scb_ezi2c_context_t *context)</div><div class="ttdoc">Initializes the SCB for the EZI2C operation.</div><div class="ttdef"><b>Definition:</b> cy_scb_ezi2c.c:74</div></div>
</div><!-- fragment --><p >Set up the EZI2C slave buffer before enabling its operation by using <a class="el" href="group__group__scb__ezi2c__slave__functions.html#ga37de7020a41bff6ee0ad54af0a8be36e">Cy_SCB_EZI2C_SetBuffer1</a> for the primary slave address and <a class="el" href="group__group__scb__ezi2c__slave__functions.html#ga2435d7a2b8e0d069e6ae1f2686e64be8">Cy_SCB_EZI2C_SetBuffer2</a> for the secondary (if the secondary is enabled).</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate buffer for EZI2C operation */</span></div>
<div class="line"><span class="preprocessor">#define BUFFER_SIZE (128UL)</span></div>
<div class="line">uint8_t bufferAddr1[BUFFER_SIZE];</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Configure buffer for communication with master */</span></div>
<div class="line"><a class="code hl_function" href="group__group__scb__ezi2c__slave__functions.html#ga37de7020a41bff6ee0ad54af0a8be36e">Cy_SCB_EZI2C_SetBuffer1</a>(SCB3, bufferAddr1, BUFFER_SIZE, BUFFER_SIZE, &amp;ezI2cContext);</div>
<div class="ttc" id="agroup__group__scb__ezi2c__slave__functions_html_ga37de7020a41bff6ee0ad54af0a8be36e"><div class="ttname"><a href="group__group__scb__ezi2c__slave__functions.html#ga37de7020a41bff6ee0ad54af0a8be36e">Cy_SCB_EZI2C_SetBuffer1</a></div><div class="ttdeci">void Cy_SCB_EZI2C_SetBuffer1(CySCB_Type const *base, uint8_t *buffer, uint32_t size, uint32_t rwBoundary, cy_stc_scb_ezi2c_context_t *context)</div><div class="ttdoc">Sets up the data buffer to be exposed to the I2C master on the primary slave address request.</div><div class="ttdef"><b>Definition:</b> cy_scb_ezi2c.c:619</div></div>
</div><!-- fragment --><h2><a class="anchor" id="group_scb_ezi2c_pins"></a>
Assign and Configure Pins</h2>
<p >Only dedicated SCB pins can be used for I2C operation. The HSIOM register must be configured to connect dedicated SCB I2C pins to the SCB block. Also the I2C pins must be configured in Open-Drain, Drives Low mode (this pin configuration implies usage of external pull-up resistors):</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign pins for EZI2C on SCB0: P8[0] and P8[1] */</span></div>
<div class="line"><span class="preprocessor">#define EZI2C_PORT      (P8_0_PORT)</span></div>
<div class="line"><span class="preprocessor">#define EZI2C_SCL_NUM   (P8_0_NUM)</span></div>
<div class="line"><span class="preprocessor">#define EZI2C_SDA_NUM   (P8_1_NUM)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Connect SCB0 I2C function to pins */</span></div>
<div class="line"><a class="code hl_function" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(EZI2C_PORT, EZI2C_SCL_NUM, P8_0_SCB0_I2C_SCL);</div>
<div class="line"><a class="code hl_function" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(EZI2C_PORT, EZI2C_SDA_NUM, P8_1_SCB0_I2C_SDA);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Configure pins for I2C operation */</span></div>
<div class="line"><a class="code hl_function" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(EZI2C_PORT, EZI2C_SCL_NUM, <a class="code hl_define" href="group__group__gpio__driveModes.html#ga4c713a8cb3c1e444153829c5ea94b34f">CY_GPIO_DM_OD_DRIVESLOW</a>);</div>
<div class="line"><a class="code hl_function" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(EZI2C_PORT, EZI2C_SDA_NUM, <a class="code hl_define" href="group__group__gpio__driveModes.html#ga4c713a8cb3c1e444153829c5ea94b34f">CY_GPIO_DM_OD_DRIVESLOW</a>);</div>
<div class="ttc" id="agroup__group__gpio__driveModes_html_ga4c713a8cb3c1e444153829c5ea94b34f"><div class="ttname"><a href="group__group__gpio__driveModes.html#ga4c713a8cb3c1e444153829c5ea94b34f">CY_GPIO_DM_OD_DRIVESLOW</a></div><div class="ttdeci">#define CY_GPIO_DM_OD_DRIVESLOW</div><div class="ttdoc">Open Drain, Drives Low.</div><div class="ttdef"><b>Definition:</b> cy_gpio.h:518</div></div>
<div class="ttc" id="agroup__group__gpio__functions__gpio_html_ga97e64dc8c45e7cd73e3012100d03b1fd"><div class="ttname"><a href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a></div><div class="ttdeci">__STATIC_INLINE void Cy_GPIO_SetDrivemode(GPIO_PRT_Type *base, uint32_t pinNum, uint32_t value)</div><div class="ttdoc">Configures the pin output buffer drive mode and input buffer enable.</div><div class="ttdef"><b>Definition:</b> cy_gpio.h:1284</div></div>
<div class="ttc" id="agroup__group__gpio__functions__init_html_ga83a06264feed0e1042671a74339ea155"><div class="ttname"><a href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a></div><div class="ttdeci">__STATIC_INLINE void Cy_GPIO_SetHSIOM(GPIO_PRT_Type *base, uint32_t pinNum, en_hsiom_sel_t value)</div><div class="ttdoc">Configures the HSIOM connection to the pin.</div><div class="ttdef"><b>Definition:</b> cy_gpio.h:923</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The alternative pins configuration is Resistive Pull-ups which implies usage internal pull-up resistors. This configuration is not recommended because resistor value is fixed and cannot be used for all supported data rates. Refer to device datasheet parameter RPULLUP for resistor value specifications.</dd></dl>
<h2><a class="anchor" id="group_scb_ezi2c_clock"></a>
Assign Clock Divider</h2>
<p >A clock source must be connected to the SCB block to oversample input and output signals, in this document this clock will be referred as clk_scb. You must use one of the 8-bit or 16-bit dividers. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign divider type and number for EZI2C */</span></div>
<div class="line"><span class="preprocessor">#define EZI2C_CLK_DIV_TYPE  (CY_SYSCLK_DIV_8_BIT)</span></div>
<div class="line"><span class="preprocessor">#define EZI2C_CLK_DIV_NUMBER   (0UL)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Connect assigned divider to be a clock source for EZI2C */</span></div>
<div class="line"><a class="code hl_function" href="group__group__sysclk__clk__peripheral__funcs.html#ga2f480c53ecec720ceed823b2692f1698">Cy_SysClk_PeriphAssignDivider</a>(PCLK_SCB3_CLOCK_SCB_EN, EZI2C_CLK_DIV_TYPE, EZI2C_CLK_DIV_NUMBER);</div>
<div class="ttc" id="agroup__group__sysclk__clk__peripheral__funcs_html_ga2f480c53ecec720ceed823b2692f1698"><div class="ttname"><a href="group__group__sysclk__clk__peripheral__funcs.html#ga2f480c53ecec720ceed823b2692f1698">Cy_SysClk_PeriphAssignDivider</a></div><div class="ttdeci">cy_en_sysclk_status_t Cy_SysClk_PeriphAssignDivider(en_clk_dst_t ipBlock, cy_en_divider_types_t dividerType, uint32_t dividerNum)</div><div class="ttdoc">Assigns a programmable divider to a selected IP block, such as a TCPWM or SCB.</div><div class="ttdef"><b>Definition:</b> cy_sysclk_v2.c:2175</div></div>
</div><!-- fragment --><h2><a class="anchor" id="group_scb_ezi2c_data_rate"></a>
Configure Data Rate</h2>
<p >To get EZI2C slave to operate at the desired data rate, the clk_scb must be fast enough to provide sufficient oversampling. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<p ><b>Refer to the technical reference manual (TRM) section I2C sub-section Oversampling and Bit Rate to get information about how to configure the I2C to run at the desired data rate</b>.</p>
<div class="fragment"><div class="line"><span class="comment">/* EZI2C slave desired data rate is 400 kbps.</span></div>
<div class="line"><span class="comment">* To support this data rate the clk_scb frequency must be in range 7.82 â€“ 15.38 MHz.</span></div>
<div class="line"><span class="comment">* Find clk_scb valid ranges in TRM section I2C sub-section Oversampling and Bit Rate.</span></div>
<div class="line"><span class="comment">* For clk_peri = 50 MHz, select divider value 4 and get clk_scb = (50 MHz / 4) = 12.5 MHz.</span></div>
<div class="line"><span class="comment">* This clock frequency meets requirements above.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><a class="code hl_function" href="group__group__sysclk__clk__peripheral__funcs.html#gae7042898b1b6835673182e462be6976e">Cy_SysClk_PeriphSetDivider</a>   (EZI2C_CLK_DIV_TYPE, EZI2C_CLK_DIV_NUMBER, 3u);</div>
<div class="line"><a class="code hl_function" href="group__group__sysclk__clk__peripheral__funcs.html#ga0725e2b222edc601b7d3f56d86d4ff75">Cy_SysClk_PeriphEnableDivider</a>(EZI2C_CLK_DIV_TYPE, EZI2C_CLK_DIV_NUMBER);</div>
<div class="ttc" id="agroup__group__sysclk__clk__peripheral__funcs_html_ga0725e2b222edc601b7d3f56d86d4ff75"><div class="ttname"><a href="group__group__sysclk__clk__peripheral__funcs.html#ga0725e2b222edc601b7d3f56d86d4ff75">Cy_SysClk_PeriphEnableDivider</a></div><div class="ttdeci">cy_en_sysclk_status_t Cy_SysClk_PeriphEnableDivider(cy_en_divider_types_t dividerType, uint32_t dividerNum)</div><div class="ttdoc">Enables the selected divider.</div><div class="ttdef"><b>Definition:</b> cy_sysclk_v2.c:2189</div></div>
<div class="ttc" id="agroup__group__sysclk__clk__peripheral__funcs_html_gae7042898b1b6835673182e462be6976e"><div class="ttname"><a href="group__group__sysclk__clk__peripheral__funcs.html#gae7042898b1b6835673182e462be6976e">Cy_SysClk_PeriphSetDivider</a></div><div class="ttdeci">cy_en_sysclk_status_t Cy_SysClk_PeriphSetDivider(cy_en_divider_types_t dividerType, uint32_t dividerNum, uint32_t dividerValue)</div><div class="ttdoc">Sets one of the programmable clock dividers.</div><div class="ttdef"><b>Definition:</b> cy_sysclk_v2.c:2142</div></div>
</div><!-- fragment --><h2><a class="anchor" id="group_scb_ezi2c_intr"></a>
Configure Interrupt</h2>
<p >The interrupt is mandatory for the EZI2C slave operation. The <a class="el" href="group__group__scb__ezi2c__slave__functions.html#ga5e811e428ecb264dddb284066d6ff956">Cy_SCB_EZI2C_Interrupt</a> function must be called in the interrupt handler for the selected SCB instance. Also, this interrupt must be enabled in the NVIC or it will not work.</p>
<div class="fragment"><div class="line"><span class="comment">/* Implement ISR for EZI2C */</span></div>
<div class="line"><span class="keywordtype">void</span> EZI2C_Isr(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="group__group__scb__ezi2c__slave__functions.html#ga5e811e428ecb264dddb284066d6ff956">Cy_SCB_EZI2C_Interrupt</a>(SCB3, &amp;ezI2cContext);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__scb__ezi2c__slave__functions_html_ga5e811e428ecb264dddb284066d6ff956"><div class="ttname"><a href="group__group__scb__ezi2c__slave__functions.html#ga5e811e428ecb264dddb284066d6ff956">Cy_SCB_EZI2C_Interrupt</a></div><div class="ttdeci">void Cy_SCB_EZI2C_Interrupt(CySCB_Type *base, cy_stc_scb_ezi2c_context_t *context)</div><div class="ttdoc">This is the interrupt function for the SCB configured in the EZI2C mode.</div><div class="ttdef"><b>Definition:</b> cy_scb_ezi2c.c:772</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/* Assign EZI2C interrupt number and priority */</span></div>
<div class="line"><span class="preprocessor">#define EZI2C_INTR_NUM        scb_3_interrupt_IRQn</span></div>
<div class="line"><span class="preprocessor">#define EZI2C_INTR_PRIORITY   (7UL)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Populate configuration structure (code specific for CM4) */</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="group__group__sysint__data__structures.html#structcy__stc__sysint__t">cy_stc_sysint_t</a> ezI2cIntrConfig =</div>
<div class="line">{</div>
<div class="line">    .<a class="code hl_variable" href="group__group__sysint__data__structures.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>      = EZI2C_INTR_NUM,</div>
<div class="line">    .intrPriority = EZI2C_INTR_PRIORITY,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Hook interrupt service routine and enable interrupt */</span></div>
<div class="line">(void) <a class="code hl_function" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;ezI2cIntrConfig, &amp;EZI2C_Isr);</div>
<div class="line">NVIC_EnableIRQ(EZI2C_INTR_NUM);</div>
<div class="ttc" id="agroup__group__sysint__data__structures_html_a6da08d81da65a7f93d3e4c46a4b8d950"><div class="ttname"><a href="group__group__sysint__data__structures.html#a6da08d81da65a7f93d3e4c46a4b8d950">cy_stc_sysint_t::intrSrc</a></div><div class="ttdeci">IRQn_Type intrSrc</div><div class="ttdoc">Interrupt source.</div><div class="ttdef"><b>Definition:</b> cy_sysint.h:227</div></div>
<div class="ttc" id="agroup__group__sysint__data__structures_html_structcy__stc__sysint__t"><div class="ttname"><a href="group__group__sysint__data__structures.html#structcy__stc__sysint__t">cy_stc_sysint_t</a></div><div class="ttdoc">Initialization configuration structure for a single interrupt channel.</div><div class="ttdef"><b>Definition:</b> cy_sysint.h:225</div></div>
<div class="ttc" id="agroup__group__sysint__functions_html_gab2ff6820a898e9af3f780000054eea5d"><div class="ttname"><a href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a></div><div class="ttdeci">cy_en_sysint_status_t Cy_SysInt_Init(const cy_stc_sysint_t *config, cy_israddress userIsr)</div><div class="ttdoc">Initializes the referenced interrupt by setting the priority and the interrupt vector.</div><div class="ttdef"><b>Definition:</b> cy_sysint_v2.c:80</div></div>
</div><!-- fragment --><h2><a class="anchor" id="group_scb_ezi2c_enable"></a>
Enable EZI2C slave</h2>
<p >Finally, enable the EZI2C slave operation by calling <a class="el" href="group__group__scb__ezi2c__general__functions.html#gae5c13ff7a89e0a75fbe83bd5dfc4fc95">Cy_SCB_EZI2C_Enable</a>. Now the I2C device responds to the assigned address. </p><div class="fragment"><div class="line"><span class="comment">/* Enable EZI2C to operate */</span></div>
<div class="line"><a class="code hl_function" href="group__group__scb__ezi2c__general__functions.html#gae5c13ff7a89e0a75fbe83bd5dfc4fc95">Cy_SCB_EZI2C_Enable</a>(SCB3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Enable global interrupts */</span></div>
<div class="line">__enable_irq();</div>
<div class="ttc" id="agroup__group__scb__ezi2c__general__functions_html_gae5c13ff7a89e0a75fbe83bd5dfc4fc95"><div class="ttname"><a href="group__group__scb__ezi2c__general__functions.html#gae5c13ff7a89e0a75fbe83bd5dfc4fc95">Cy_SCB_EZI2C_Enable</a></div><div class="ttdeci">__STATIC_INLINE void Cy_SCB_EZI2C_Enable(CySCB_Type *base)</div><div class="ttdoc">Enables the SCB block for the EZI2C operation.</div><div class="ttdef"><b>Definition:</b> cy_scb_ezi2c.h:547</div></div>
</div><!-- fragment --><h1><a class="anchor" id="group_scb_ezi2c_use_cases"></a>
Common Use Cases</h1>
<p >The EZI2C slave operation might not require calling any EZI2C slave function because the I2C master is able to access the slave buffer. The application can directly access it as well. Note that this is an application-level task to ensure the buffer content integrity.</p>
<h2><a class="anchor" id="group_scb_ezi2c_master_wr"></a>
Master Write operation</h2>
<p >This operation starts with sending a base address that is one or two bytes, depending on the sub-address size configuration. This base address is retained and will be used for later read operations. Following the base address, there is a sequence of bytes written into the buffer starting from the base address location. The buffer index is incremented for each written byte, but this does not affect the base address that is retained. The length of a write operation is limited by the maximum buffer read/write region size.<br  />
When a master attempts to write outside the read/write region or past the end of the buffer, the last byte is NACKed.</p>
<div class="image">
<img src="scb_ezi2c_write.png" alt=""/>
</div>
<h2><a class="anchor" id="group_scb_ezi2c_master_rd"></a>
Master Read operation</h2>
<p >This operation always starts from the base address set by the most recent write operation. The buffer index is incremented for each read byte. Two sequential read operations start from the same base address no matter how many bytes are read. The length of a read operation is not limited by the maximum size of the data buffer. The EZI2C slave returns 0xFF bytes if the read operation passes the end of the buffer.<br  />
Typically, a read operation requires the base address to be updated before starting the read. In this case, the write and read operations must be combined together.</p>
<div class="image">
<img src="scb_ezi2c_read.png" alt=""/>
</div>
<p >The I2C master may use the ReStart or Stop/Start conditions to combine the operations. The write operation sets only the base address and the following read operation will start from the new base address. In cases where the base address remains the same, there is no need for a write operation. </p><div class="image">
<img src="scb_ezi2c_set_ba_read.png" alt=""/>
</div>
<h1><a class="anchor" id="group_scb_ezi2c_lp"></a>
Low Power Support</h1>
<p >The EZI2C slave provides the callback functions to handle power mode transition. The callback <a class="el" href="group__group__scb__ezi2c__low__power__functions.html#ga5875cdcf148b37407ee8360b79580426">Cy_SCB_EZI2C_DeepSleepCallback</a> must be called during execution of Cy_SysPm_CpuEnterDeepSleep; <a class="el" href="group__group__scb__ezi2c__low__power__functions.html#ga0c0f0f4191ec10d04b0b3a8363e7caf4">Cy_SCB_EZI2C_HibernateCallback</a> must be called during execution of Cy_SysPm_SystemEnterHibernate. To trigger the callback execution, the callback must be registered before calling the power mode transition function. Refer to <a class="el" href="group__group__syspm.html">SysPm (System Power Management)</a> driver for more information about power mode transitions and callback registration.</p>
<p >The EZI2C configured to support two addresses can wakeup the device on address match to NACK not supported address. This happens because the hardware address-match-logic uses address bit masking to support to two addresses. The address mask defines which bits in the address are treated as non-significant while performing an address match. One non-significant bit results in two matching addresses; two bits will match 4 and so on. If the two addresses differ by more than a single bit, then the extra addresses that will pass the hardware match and wakeup the device from Deep Sleep mode. Then firmware address matching will to generate a NAK. Due to this reason, it is preferable to select a secondary address that is different from the primary by one bit. The address mask in this case makes one bit non-significant. For example:</p><ul>
<li>Primary address = 0x24 and secondary address = 0x34, only one bit differs. Only the two addresses are treated as matching by the hardware.</li>
<li>Primary address = 0x24 and secondary address = 0x30, two bits differ. Four addresses are treated as matching by the hardware: 0x24, 0x34, 0x20 and 0x30. Firmware is required to ACK only the primary and secondary addresses 0x24 and 0x30 and NAK all others 0x20 and 0x34. </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__scb__ezi2c__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSOC E8XXGP Device Support Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
