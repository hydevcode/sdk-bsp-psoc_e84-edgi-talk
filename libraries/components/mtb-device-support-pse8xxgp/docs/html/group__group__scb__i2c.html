<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSOC E8XXGP Device Support Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSOC E8XXGP Device Support Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__scb__i2c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle"><div class="title">I2C (SCB)<div class="ingroups"><a class="el" href="group__group__pdl__top.html">PDL API Reference</a> &raquo; <a class="el" href="group__group__scb.html">SCB          (Serial Communication Block)</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p >Driver API for I2C Bus Peripheral. </p>
<p >I2C - The Inter-Integrated Circuit (I2C) bus is an industry-standard.</p>
<p >The functions and other declarations used in this part of the driver are in cy_scb_i2c.h. You can also include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<p >The I2C peripheral driver provides an API to implement I2C slave, master, or master-slave devices based on the SCB hardware block. I2C devices based on SCB hardware are compatible with I2C Standard-mode, Fast-mode, and Fast-mode Plus specifications as defined in the I2C-bus specification.</p>
<p >Features:</p><ul>
<li>An industry-standard I2C bus interface</li>
<li>Supports slave, master, and master-slave operation</li>
<li>Supports standard data rates of 100/400/1000 kbps</li>
<li>Hardware Address Match, multiple addresses</li>
<li>Wake from Deep Sleep on Address Match</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>I2C supports clock stretching. This occurs when a slave device is not capable of processing data, it holds the SCL line by driving a '0'. The master device monitors the SCL line and detects it when it cannot generate a positive clock pulse ('1') on the SCL line. It then reacts by delaying the generation of a positive edge on the SCL line, effectively synchronizing with the slave device that is stretching the clock. Clock stretching can occur in the case of externally clocked address matching until the internally clocked logic takes over. The largest reason for clock stretching is when the master tries to write to the slave and the slave's RX FIFO is full, the slave will then clock stretch until the FIFO is no longer full. For more information on FIFO size and clock stretching see the architecture TRM.</dd></dl>
<h1><a class="anchor" id="group_scb_i2c_configuration"></a>
Configuration Considerations</h1>
<p >The I2C driver configuration can be divided to number of sequential steps listed below:</p><ul>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_config">Configure I2C</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_pins">Assign and Configure Pins</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_clock">Assign Clock Divider</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_data_rate">Configure Data Rate</a><ul>
<li>group_scb_i2c_mclk_sync</li>
</ul>
</li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_intr">Configure Interrupt</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_enable">Enable I2C</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>I2C driver is built on top of the SCB hardware block. The SCB3 instance is used as an example for all code snippets. Modify the code to match your design.</dd></dl>
<h2><a class="anchor" id="group_scb_i2c_config"></a>
Configure I2C</h2>
<p >To set up the I2C driver, provide the configuration parameters in the <a class="el" href="group__group__scb__i2c__data__structures.html#structcy__stc__scb__i2c__config__t">cy_stc_scb_i2c_config_t</a> structure. Provide i2cMode to the select operation mode slave, master or master-slave. The useRxFifo and useTxFifo parameters specify if RX and TX FIFO is used during operation. Typically, both FIFOs should be enabled to reduce possibility of clock stretching. However, using RX FIFO has side effects that needs to be taken into account (see useRxFifo field description in <a class="el" href="group__group__scb__i2c__data__structures.html#structcy__stc__scb__i2c__config__t">cy_stc_scb_i2c_config_t</a> structure). For master modes, parameters lowPhaseDutyCycle, highPhaseDutyCycle and enableDigitalFilter can be used to define output data rate (refer to section <a class="el" href="group__group__scb__i2c.html#group_scb_i2c_data_rate">Configure Data Rate</a> for more information). For slave mode, provide the slaveAddress and slaveAddressMask. The other parameters are optional for operation.<br  />
To initialize the driver, call <a class="el" href="group__group__scb__i2c__general__functions.html#ga91fbfb16a78c014fd88681b83544c2f7">Cy_SCB_I2C_Init</a> function providing a pointer to the populated <a class="el" href="group__group__scb__i2c__data__structures.html#structcy__stc__scb__i2c__config__t">cy_stc_scb_i2c_config_t</a> structure and the allocated <a class="el" href="group__group__scb__i2c__data__structures.html#structcy__stc__scb__i2c__context__t">cy_stc_scb_i2c_context_t</a> structure.</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate context for I2C operation */</span></div>
<div class="line"><a class="code hl_struct" href="group__group__scb__i2c__data__structures.html#structcy__stc__scb__i2c__context__t">cy_stc_scb_i2c_context_t</a> i2cContext;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Populate configuration structure */</span></div>
<div class="line"><span class="preprocessor">#if (USE_I2C_SLAVE)</span></div>
<div class="line">    <span class="comment">/* Slave configuration */</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="group__group__scb__i2c__data__structures.html#structcy__stc__scb__i2c__config__t">cy_stc_scb_i2c_config_t</a> i2cConfig =</div>
<div class="line">    {</div>
<div class="line">        .<a class="code hl_variable" href="group__group__scb__i2c__data__structures.html#ab317c1252433320bfd76d2b8629dac23">i2cMode</a>   = <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#gga848386100a4d9700bf5bb790b3db3ed2a9ceefa04abbb537720c9924350b5e179">CY_SCB_I2C_SLAVE</a>,</div>
<div class="line">        .useRxFifo = <span class="keyword">false</span>,</div>
<div class="line">        .useTxFifo = <span class="keyword">true</span>,</div>
<div class="line">        .slaveAddress     = 0x08U,</div>
<div class="line">        .slaveAddressMask = 0xFEU,</div>
<div class="line">        .acceptAddrInFifo = <span class="keyword">false</span>,</div>
<div class="line">        .ackGeneralAddr   = <span class="keyword">false</span>,</div>
<div class="line">        .enableWakeFromSleep = <span class="keyword">false</span>,</div>
<div class="line">        .enableDigitalFilter = <span class="keyword">false</span>,</div>
<div class="line">        .lowPhaseDutyCycle = 0U,</div>
<div class="line">        .highPhaseDutyCycle = 0U,</div>
<div class="line">    };</div>
<div class="line"><span class="preprocessor">#else </span><span class="comment">/* USE_I2C_MASTER */</span><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">/* Master  configuration */</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="group__group__scb__i2c__data__structures.html#structcy__stc__scb__i2c__config__t">cy_stc_scb_i2c_config_t</a> i2cConfig =</div>
<div class="line">    {</div>
<div class="line">        .<a class="code hl_variable" href="group__group__scb__i2c__data__structures.html#ab317c1252433320bfd76d2b8629dac23">i2cMode</a>   = <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#gga848386100a4d9700bf5bb790b3db3ed2ac1dc09a53d6852a737909498356978c6">CY_SCB_I2C_MASTER</a>,</div>
<div class="line">        .useRxFifo = <span class="keyword">false</span>,</div>
<div class="line">        .useTxFifo = <span class="keyword">true</span>,</div>
<div class="line">        .slaveAddress     = 0U,</div>
<div class="line">        .slaveAddressMask = 0U,</div>
<div class="line">        .acceptAddrInFifo = <span class="keyword">false</span>,</div>
<div class="line">        .ackGeneralAddr   = <span class="keyword">false</span>,</div>
<div class="line">        .enableWakeFromSleep = <span class="keyword">false</span>,</div>
<div class="line">        .enableDigitalFilter = <span class="keyword">false</span>,</div>
<div class="line">        .lowPhaseDutyCycle = 8U,</div>
<div class="line">        .highPhaseDutyCycle = 8U,</div>
<div class="line">    };</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Configure I2C to operate */</span></div>
<div class="line">(void) <a class="code hl_function" href="group__group__scb__i2c__general__functions.html#ga91fbfb16a78c014fd88681b83544c2f7">Cy_SCB_I2C_Init</a>(SCB3, &amp;i2cConfig, &amp;i2cContext);</div>
<div class="ttc" id="agroup__group__scb__i2c__data__structures_html_ab317c1252433320bfd76d2b8629dac23"><div class="ttname"><a href="group__group__scb__i2c__data__structures.html#ab317c1252433320bfd76d2b8629dac23">cy_stc_scb_i2c_config_t::i2cMode</a></div><div class="ttdeci">cy_en_scb_i2c_mode_t i2cMode</div><div class="ttdoc">Specifies the mode of operation.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:439</div></div>
<div class="ttc" id="agroup__group__scb__i2c__data__structures_html_structcy__stc__scb__i2c__config__t"><div class="ttname"><a href="group__group__scb__i2c__data__structures.html#structcy__stc__scb__i2c__config__t">cy_stc_scb_i2c_config_t</a></div><div class="ttdoc">I2C configuration structure.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:437</div></div>
<div class="ttc" id="agroup__group__scb__i2c__data__structures_html_structcy__stc__scb__i2c__context__t"><div class="ttname"><a href="group__group__scb__i2c__data__structures.html#structcy__stc__scb__i2c__context__t">cy_stc_scb_i2c_context_t</a></div><div class="ttdoc">I2C context structure.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:562</div></div>
<div class="ttc" id="agroup__group__scb__i2c__enums_html_gga848386100a4d9700bf5bb790b3db3ed2a9ceefa04abbb537720c9924350b5e179"><div class="ttname"><a href="group__group__scb__i2c__enums.html#gga848386100a4d9700bf5bb790b3db3ed2a9ceefa04abbb537720c9924350b5e179">CY_SCB_I2C_SLAVE</a></div><div class="ttdeci">@ CY_SCB_I2C_SLAVE</div><div class="ttdoc">Configures SCB for I2C Slave operation.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:387</div></div>
<div class="ttc" id="agroup__group__scb__i2c__enums_html_gga848386100a4d9700bf5bb790b3db3ed2ac1dc09a53d6852a737909498356978c6"><div class="ttname"><a href="group__group__scb__i2c__enums.html#gga848386100a4d9700bf5bb790b3db3ed2ac1dc09a53d6852a737909498356978c6">CY_SCB_I2C_MASTER</a></div><div class="ttdeci">@ CY_SCB_I2C_MASTER</div><div class="ttdoc">Configures SCB for I2C Master operation.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:388</div></div>
<div class="ttc" id="agroup__group__scb__i2c__general__functions_html_ga91fbfb16a78c014fd88681b83544c2f7"><div class="ttname"><a href="group__group__scb__i2c__general__functions.html#ga91fbfb16a78c014fd88681b83544c2f7">Cy_SCB_I2C_Init</a></div><div class="ttdeci">cy_en_scb_i2c_status_t Cy_SCB_I2C_Init(CySCB_Type *base, cy_stc_scb_i2c_config_t const *config, cy_stc_scb_i2c_context_t *context)</div><div class="ttdoc">Initializes the SCB for the I2C operation.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:80</div></div>
</div><!-- fragment --><p >Set up I2C slave read and write buffer before enabling its operation using <a class="el" href="group__group__scb__i2c__slave__functions.html#ga179b4495d7255567bb8b166e16e5a073">Cy_SCB_I2C_SlaveConfigReadBuf</a> and <a class="el" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a> appropriately. Note that the master reads data from the slave read buffer and writes data into the slave write buffer.</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate buffers for I2C slave operation */</span></div>
<div class="line"><span class="preprocessor">#define BUFFER_SIZE (128UL)</span></div>
<div class="line">uint8_t i2cReadBuffer[BUFFER_SIZE];</div>
<div class="line">uint8_t i2cWriteBuffer[BUFFER_SIZE];</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Configure write and read buffers for communication with master */</span></div>
<div class="line"><a class="code hl_function" href="group__group__scb__i2c__slave__functions.html#ga179b4495d7255567bb8b166e16e5a073">Cy_SCB_I2C_SlaveConfigReadBuf</a> (SCB3, i2cReadBuffer,  BUFFER_SIZE, &amp;i2cContext);</div>
<div class="line"><a class="code hl_function" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a>(SCB3, i2cWriteBuffer, BUFFER_SIZE, &amp;i2cContext);</div>
<div class="ttc" id="agroup__group__scb__i2c__slave__functions_html_ga179b4495d7255567bb8b166e16e5a073"><div class="ttname"><a href="group__group__scb__i2c__slave__functions.html#ga179b4495d7255567bb8b166e16e5a073">Cy_SCB_I2C_SlaveConfigReadBuf</a></div><div class="ttdeci">void Cy_SCB_I2C_SlaveConfigReadBuf(CySCB_Type const *base, uint8_t *buffer, uint32_t size, cy_stc_scb_i2c_context_t *context)</div><div class="ttdoc">Configures the buffer pointer and the read buffer size.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:840</div></div>
<div class="ttc" id="agroup__group__scb__i2c__slave__functions_html_gaaf2d216e9cb246dd2256521cb7f50170"><div class="ttname"><a href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a></div><div class="ttdeci">void Cy_SCB_I2C_SlaveConfigWriteBuf(CySCB_Type const *base, uint8_t *buffer, uint32_t size, cy_stc_scb_i2c_context_t *context)</div><div class="ttdoc">Configures the buffer pointer and size of the write buffer.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:1019</div></div>
</div><!-- fragment --><h2><a class="anchor" id="group_scb_i2c_pins"></a>
Assign and Configure Pins</h2>
<p >Only dedicated SCB pins can be used for I2C operation. The HSIOM register must be configured to connect dedicated SCB I2C pins to the SCB block. Also the I2C pins must be configured in Open-Drain, Drives Low mode (this pins configuration implies usage of external pull-up resistors):</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign pins for I2C on SCB0: P8[0] and P8[1] */</span></div>
<div class="line"><span class="preprocessor">#define I2C_PORT      (P8_0_PORT)</span></div>
<div class="line"><span class="preprocessor">#define I2C_SCL_NUM   (P8_0_NUM)</span></div>
<div class="line"><span class="preprocessor">#define I2C_SDA_NUM   (P8_1_NUM)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Connect SCB0 I2C function to pins */</span></div>
<div class="line"><a class="code hl_function" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(I2C_PORT, I2C_SCL_NUM, P8_0_SCB0_I2C_SCL);</div>
<div class="line"><a class="code hl_function" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(I2C_PORT, I2C_SDA_NUM, P8_1_SCB0_I2C_SDA);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Configure pins for I2C operation */</span></div>
<div class="line"><a class="code hl_function" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(I2C_PORT, I2C_SCL_NUM, <a class="code hl_define" href="group__group__gpio__driveModes.html#ga4c713a8cb3c1e444153829c5ea94b34f">CY_GPIO_DM_OD_DRIVESLOW</a>);</div>
<div class="line"><a class="code hl_function" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(I2C_PORT, I2C_SDA_NUM, <a class="code hl_define" href="group__group__gpio__driveModes.html#ga4c713a8cb3c1e444153829c5ea94b34f">CY_GPIO_DM_OD_DRIVESLOW</a>);</div>
<div class="ttc" id="agroup__group__gpio__driveModes_html_ga4c713a8cb3c1e444153829c5ea94b34f"><div class="ttname"><a href="group__group__gpio__driveModes.html#ga4c713a8cb3c1e444153829c5ea94b34f">CY_GPIO_DM_OD_DRIVESLOW</a></div><div class="ttdeci">#define CY_GPIO_DM_OD_DRIVESLOW</div><div class="ttdoc">Open Drain, Drives Low.</div><div class="ttdef"><b>Definition:</b> cy_gpio.h:518</div></div>
<div class="ttc" id="agroup__group__gpio__functions__gpio_html_ga97e64dc8c45e7cd73e3012100d03b1fd"><div class="ttname"><a href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a></div><div class="ttdeci">__STATIC_INLINE void Cy_GPIO_SetDrivemode(GPIO_PRT_Type *base, uint32_t pinNum, uint32_t value)</div><div class="ttdoc">Configures the pin output buffer drive mode and input buffer enable.</div><div class="ttdef"><b>Definition:</b> cy_gpio.h:1284</div></div>
<div class="ttc" id="agroup__group__gpio__functions__init_html_ga83a06264feed0e1042671a74339ea155"><div class="ttname"><a href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a></div><div class="ttdeci">__STATIC_INLINE void Cy_GPIO_SetHSIOM(GPIO_PRT_Type *base, uint32_t pinNum, en_hsiom_sel_t value)</div><div class="ttdoc">Configures the HSIOM connection to the pin.</div><div class="ttdef"><b>Definition:</b> cy_gpio.h:923</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The alternative pins configuration is Resistive Pull-ups which implies usage internal pull-up resistors. This configuration is not recommended because resistor value is fixed and cannot be used for all supported data rates. Refer to the device datasheet parameter RPULLUP for resistor value specifications.</dd></dl>
<h2><a class="anchor" id="group_scb_i2c_clock"></a>
Assign Clock Divider</h2>
<p >A clock source must be connected to the SCB block to oversample input and output signals, in this document this clock will be referred as clk_scb. You must use one of the 8-bit or 16-bit dividers. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign divider type and number for I2C */</span></div>
<div class="line"><span class="preprocessor">#define I2C_CLK_DIV_TYPE  (CY_SYSCLK_DIV_8_BIT)</span></div>
<div class="line"><span class="preprocessor">#define I2C_CLK_DIV_NUMBER  (0U)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Connect assigned divider to be a clock source for I2C */</span></div>
<div class="line"><a class="code hl_function" href="group__group__sysclk__clk__peripheral__funcs.html#ga2f480c53ecec720ceed823b2692f1698">Cy_SysClk_PeriphAssignDivider</a>(PCLK_SCB3_CLOCK_SCB_EN, I2C_CLK_DIV_TYPE, I2C_CLK_DIV_NUMBER);</div>
<div class="ttc" id="agroup__group__sysclk__clk__peripheral__funcs_html_ga2f480c53ecec720ceed823b2692f1698"><div class="ttname"><a href="group__group__sysclk__clk__peripheral__funcs.html#ga2f480c53ecec720ceed823b2692f1698">Cy_SysClk_PeriphAssignDivider</a></div><div class="ttdeci">cy_en_sysclk_status_t Cy_SysClk_PeriphAssignDivider(en_clk_dst_t ipBlock, cy_en_divider_types_t dividerType, uint32_t dividerNum)</div><div class="ttdoc">Assigns a programmable divider to a selected IP block, such as a TCPWM or SCB.</div><div class="ttdef"><b>Definition:</b> cy_sysclk_v2.c:2175</div></div>
</div><!-- fragment --><h2><a class="anchor" id="group_scb_i2c_data_rate"></a>
Configure Data Rate</h2>
<p >To get I2C slave operation with the desired data rate, the clk_scb must be fast enough to provide sufficient oversampling. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<div class="fragment"><div class="line"><span class="comment">/* I2C slave desired data rate is 400 kbps.</span></div>
<div class="line"><span class="comment">* To support this data rate the clk_scb frequency must be in range 7.82 – 15.38 MHz.</span></div>
<div class="line"><span class="comment">* Find clk_scb valid ranges in TRM section I2C sub-section Oversampling and Bit Rate.</span></div>
<div class="line"><span class="comment">* For clk_peri = 50 MHz, select divider value 4 and get clk_scb = (50 MHz / 4) = 12.5 MHz.</span></div>
<div class="line"><span class="comment">* This clock frequency meets requirements above.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><a class="code hl_function" href="group__group__sysclk__clk__peripheral__funcs.html#gae7042898b1b6835673182e462be6976e">Cy_SysClk_PeriphSetDivider</a>   (I2C_CLK_DIV_TYPE, I2C_CLK_DIV_NUMBER, 3u);</div>
<div class="line"><a class="code hl_function" href="group__group__sysclk__clk__peripheral__funcs.html#ga0725e2b222edc601b7d3f56d86d4ff75">Cy_SysClk_PeriphEnableDivider</a>(I2C_CLK_DIV_TYPE, I2C_CLK_DIV_NUMBER);</div>
<div class="ttc" id="agroup__group__sysclk__clk__peripheral__funcs_html_ga0725e2b222edc601b7d3f56d86d4ff75"><div class="ttname"><a href="group__group__sysclk__clk__peripheral__funcs.html#ga0725e2b222edc601b7d3f56d86d4ff75">Cy_SysClk_PeriphEnableDivider</a></div><div class="ttdeci">cy_en_sysclk_status_t Cy_SysClk_PeriphEnableDivider(cy_en_divider_types_t dividerType, uint32_t dividerNum)</div><div class="ttdoc">Enables the selected divider.</div><div class="ttdef"><b>Definition:</b> cy_sysclk_v2.c:2189</div></div>
<div class="ttc" id="agroup__group__sysclk__clk__peripheral__funcs_html_gae7042898b1b6835673182e462be6976e"><div class="ttname"><a href="group__group__sysclk__clk__peripheral__funcs.html#gae7042898b1b6835673182e462be6976e">Cy_SysClk_PeriphSetDivider</a></div><div class="ttdeci">cy_en_sysclk_status_t Cy_SysClk_PeriphSetDivider(cy_en_divider_types_t dividerType, uint32_t dividerNum, uint32_t dividerValue)</div><div class="ttdoc">Sets one of the programmable clock dividers.</div><div class="ttdef"><b>Definition:</b> cy_sysclk_v2.c:2142</div></div>
</div><!-- fragment --><p >To get I2C master operation with the desired data rate, the source clock frequency and SCL low and high phase duration must be configured. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to configure source clock frequency. Then call <a class="el" href="group__group__scb__i2c__general__functions.html#gae9d71372b84c9c799b55283fc475f223">Cy_SCB_I2C_SetDataRate</a> to set the SCL low, high phase duration and digital filter. This function sets SCL low and high phase settings based on source clock frequency.</p>
<div class="fragment"><div class="line">uint32_t dataRate;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* I2C master desired data rate in Hz */</span></div>
<div class="line"><span class="preprocessor">#define I2C_DESIRED_DATA_RATE_HZ    (100000U)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* I2C master desired data rate is 100 kbps.</span></div>
<div class="line"><span class="comment">* To support this data rate the clk_scb frequency must be in range 1.55 – 3.2 MHz.</span></div>
<div class="line"><span class="comment">* Find clk_scb valid ranges in TRM section I2C sub-section Oversampling and Bit Rate.</span></div>
<div class="line"><span class="comment">* For clk_peri = 50 MHz, select divider value 32 and get clk_scb = (50 MHz / 32) = 1.563 MHz.</span></div>
<div class="line"><span class="comment">* This clock frequency meets requirements above.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><a class="code hl_function" href="group__group__sysclk__clk__peripheral__funcs.html#gae7042898b1b6835673182e462be6976e">Cy_SysClk_PeriphSetDivider</a>   (I2C_CLK_DIV_TYPE, I2C_CLK_DIV_NUMBER, 31u);</div>
<div class="line"><a class="code hl_function" href="group__group__sysclk__clk__peripheral__funcs.html#ga0725e2b222edc601b7d3f56d86d4ff75">Cy_SysClk_PeriphEnableDivider</a>(I2C_CLK_DIV_TYPE, I2C_CLK_DIV_NUMBER);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Configure master to operate with desired data rate */</span></div>
<div class="line">dataRate = <a class="code hl_function" href="group__group__scb__i2c__general__functions.html#gae9d71372b84c9c799b55283fc475f223">Cy_SCB_I2C_SetDataRate</a>(SCB3, I2C_DESIRED_DATA_RATE_HZ, <a class="code hl_function" href="group__group__sysclk__clk__peripheral__funcs.html#ga366428a7c17da00f7a7ae025aeda2e23">Cy_SysClk_PeriphGetFrequency</a>(I2C_CLK_DIV_TYPE, I2C_CLK_DIV_NUMBER));</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> ((dataRate &gt; I2C_DESIRED_DATA_RATE_HZ) || (dataRate == 0U))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Can not reach desired data rate */</span></div>
<div class="line">    CY_ASSERT(0U);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__scb__i2c__general__functions_html_gae9d71372b84c9c799b55283fc475f223"><div class="ttname"><a href="group__group__scb__i2c__general__functions.html#gae9d71372b84c9c799b55283fc475f223">Cy_SCB_I2C_SetDataRate</a></div><div class="ttdeci">uint32_t Cy_SCB_I2C_SetDataRate(CySCB_Type *base, uint32_t dataRateHz, uint32_t scbClockHz)</div><div class="ttdoc">Configures the SCB to work at the desired data rate.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:541</div></div>
<div class="ttc" id="agroup__group__sysclk__clk__peripheral__funcs_html_ga366428a7c17da00f7a7ae025aeda2e23"><div class="ttname"><a href="group__group__sysclk__clk__peripheral__funcs.html#ga366428a7c17da00f7a7ae025aeda2e23">Cy_SysClk_PeriphGetFrequency</a></div><div class="ttdeci">uint32_t Cy_SysClk_PeriphGetFrequency(cy_en_divider_types_t dividerType, uint32_t dividerNum)</div><div class="ttdoc">Reports the frequency of the output of a given peripheral divider.</div><div class="ttdef"><b>Definition:</b> cy_sysclk_v2.c:2132</div></div>
</div><!-- fragment --><p >Alternatively, the low, high phase and digital filter can be set directly using configuration structure <a class="el" href="group__group__scb__i2c__data__structures.html#structcy__stc__scb__i2c__config__t">cy_stc_scb_i2c_config_t</a> fields lowPhaseDutyCycle, highPhaseDutyCycle and enableDigitalFilter appropriately.<br  />
<b>Refer to the technical reference manual (TRM) section I2C sub-section Oversampling and Bit Rate to get information how to configure I2C to run with the desired data rate.</b></p>
<dl class="section note"><dt>Note</dt><dd>For I2C slave, the analog filter is used for all supported data rates. <br  />
For I2C master, the analog filter is used for Standard and Fast modes and the digital filter for Fast Plus mode.</dd></dl>
<h2><a class="anchor" id="group_scb_i2c_intr"></a>
Configure Interrupt</h2>
<p >The interrupt is mandatory for I2C operation. The exception is the when only the <a class="el" href="group__group__scb__i2c__master__low__level__functions.html">Master Low-Level</a> functions are used. The driver provides three interrupt functions: <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a>, <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga87512a96b0ae32bb624a5a960d64d23f">Cy_SCB_I2C_SlaveInterrupt</a>, and <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga3133d46624010df1c57a0800797aab01">Cy_SCB_I2C_MasterInterrupt</a>. One of these functions must be called in the interrupt handler for the selected SCB instance. Call <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga87512a96b0ae32bb624a5a960d64d23f">Cy_SCB_I2C_SlaveInterrupt</a> when I2C is configured to operate as a slave, <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga3133d46624010df1c57a0800797aab01">Cy_SCB_I2C_MasterInterrupt</a> when I2C is configured to operate as a master and <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a> when I2C is configured to operate as master and slave. Using the slave- or master-specific interrupt function allows reducing the flash consumed by the I2C driver. Also this interrupt must be enabled in the NVIC otherwise it will not work. </p><dl class="section note"><dt>Note</dt><dd>The I2C driver documentation refers to the <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a> function when interrupt processing is mandatory for the operation. This is done to simplify the readability of the driver's documentation. The application should call the slave- or master-specific interrupt functions <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga87512a96b0ae32bb624a5a960d64d23f">Cy_SCB_I2C_SlaveInterrupt</a> or <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga3133d46624010df1c57a0800797aab01">Cy_SCB_I2C_MasterInterrupt</a>, when appropriate.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> I2C_Isr(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a>(SCB3, &amp;i2cContext);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__scb__i2c__interrupt__functions_html_ga729b2fa4de4d44ea2e8995d7ca6a0c24"><div class="ttname"><a href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a></div><div class="ttdeci">void Cy_SCB_I2C_Interrupt(CySCB_Type *base, cy_stc_scb_i2c_context_t *context)</div><div class="ttdoc">This is the interrupt function for the SCB configured in the I2C mode.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:2161</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/* Assign I2C interrupt number and priority */</span></div>
<div class="line"><span class="preprocessor">#define I2C_INTR_NUM        scb_3_interrupt_IRQn</span></div>
<div class="line"><span class="preprocessor">#define I2C_INTR_PRIORITY   (7UL)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Populate configuration structure (code specific for CM4) */</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="group__group__sysint__data__structures.html#structcy__stc__sysint__t">cy_stc_sysint_t</a> i2cIntrConfig =</div>
<div class="line">{</div>
<div class="line">    .<a class="code hl_variable" href="group__group__sysint__data__structures.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>      = I2C_INTR_NUM,</div>
<div class="line">    .intrPriority = I2C_INTR_PRIORITY,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Hook interrupt service routine and enable interrupt */</span></div>
<div class="line">(void) <a class="code hl_function" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;i2cIntrConfig, &amp;I2C_Isr);</div>
<div class="line">NVIC_EnableIRQ(I2C_INTR_NUM);</div>
<div class="ttc" id="agroup__group__sysint__data__structures_html_a6da08d81da65a7f93d3e4c46a4b8d950"><div class="ttname"><a href="group__group__sysint__data__structures.html#a6da08d81da65a7f93d3e4c46a4b8d950">cy_stc_sysint_t::intrSrc</a></div><div class="ttdeci">IRQn_Type intrSrc</div><div class="ttdoc">Interrupt source.</div><div class="ttdef"><b>Definition:</b> cy_sysint.h:227</div></div>
<div class="ttc" id="agroup__group__sysint__data__structures_html_structcy__stc__sysint__t"><div class="ttname"><a href="group__group__sysint__data__structures.html#structcy__stc__sysint__t">cy_stc_sysint_t</a></div><div class="ttdoc">Initialization configuration structure for a single interrupt channel.</div><div class="ttdef"><b>Definition:</b> cy_sysint.h:225</div></div>
<div class="ttc" id="agroup__group__sysint__functions_html_gab2ff6820a898e9af3f780000054eea5d"><div class="ttname"><a href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a></div><div class="ttdeci">cy_en_sysint_status_t Cy_SysInt_Init(const cy_stc_sysint_t *config, cy_israddress userIsr)</div><div class="ttdoc">Initializes the referenced interrupt by setting the priority and the interrupt vector.</div><div class="ttdef"><b>Definition:</b> cy_sysint_v2.c:80</div></div>
</div><!-- fragment --><h2><a class="anchor" id="group_scb_i2c_enable"></a>
Enable I2C</h2>
<p >Finally, enable the I2C operation by calling <a class="el" href="group__group__scb__i2c__general__functions.html#gad14d83faab69d2ac96feede664df3687">Cy_SCB_I2C_Enable</a>. Then I2C slave starts respond to the assigned address and I2C master ready to execute transfers.</p>
<div class="fragment"><div class="line"><span class="comment">/* Enable I2C to operate */</span></div>
<div class="line"><a class="code hl_function" href="group__group__scb__i2c__general__functions.html#gad14d83faab69d2ac96feede664df3687">Cy_SCB_I2C_Enable</a>(SCB3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Enable global interrupts */</span></div>
<div class="line">__enable_irq();</div>
<div class="ttc" id="agroup__group__scb__i2c__general__functions_html_gad14d83faab69d2ac96feede664df3687"><div class="ttname"><a href="group__group__scb__i2c__general__functions.html#gad14d83faab69d2ac96feede664df3687">Cy_SCB_I2C_Enable</a></div><div class="ttdeci">__STATIC_INLINE void Cy_SCB_I2C_Enable(CySCB_Type *base)</div><div class="ttdoc">Enables the SCB block for the I2C operation.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:1139</div></div>
</div><!-- fragment --><h1><a class="anchor" id="group_scb_i2c_use_cases"></a>
Common Use Cases</h1>
<h2><a class="anchor" id="group_scb_i2c_master_mode"></a>
Master Operation</h2>
<p >The master API is divided into two categories: <a class="el" href="group__group__scb__i2c__master__high__level__functions.html">Master High-Level</a> and <a class="el" href="group__group__scb__i2c__master__low__level__functions.html">Master Low-Level</a>. Therefore, there are two methods for initiating I2C master transactions using either <b>Low-Level or High-Level</b> API. These two methods are described below. Only one method should be used at a time. <b>They should not be mixed.</b></p>
<h3><a class="anchor" id="group_scb_i2c_master_hl"></a>
Use High-Level Functions</h3>
<p >Call <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga83185adeefa83640ac09852c9d6cf426">Cy_SCB_I2C_MasterRead</a> or <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga91f7a32d2a20cf3deebe01cef8d9d000">Cy_SCB_I2C_MasterWrite</a> to communicate with the slave. These functions do not block and only start a transaction. After a transaction starts, the <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a> handles further data transaction until its completion (successfully or with error occurring). To monitor the transaction, use <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga652a3b9da6db2424fed62c28c6347ef3">Cy_SCB_I2C_MasterGetStatus</a> or register callback function using <a class="el" href="group__group__scb__i2c__interrupt__functions.html#gac61f7304c304421a40135cf4d61a660c">Cy_SCB_I2C_RegisterEventCallback</a> to be notified about <a class="el" href="group__group__scb__i2c__macros__callback__events.html">I2C Callback Events</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__group__scb__i2c__data__structures.html#structcy__stc__scb__i2c__master__xfer__config__t">cy_stc_scb_i2c_master_xfer_config_t</a> transfer;</div>
<div class="line"> </div>
<div class="line">uint8_t readBuffer [5UL];</div>
<div class="line">uint8_t writeBuffer[2UL] = {0U, 5U};</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Configure write transaction */</span></div>
<div class="line">transfer.<a class="code hl_variable" href="group__group__scb__i2c__data__structures.html#ad593c8662c67ee3d7b766d1bfac64639">slaveAddress</a> = 0x08U;</div>
<div class="line">transfer.<a class="code hl_variable" href="group__group__scb__i2c__data__structures.html#a17fa9b9a817e002381f07c4982abaffa">buffer</a>       = writeBuffer;</div>
<div class="line">transfer.<a class="code hl_variable" href="group__group__scb__i2c__data__structures.html#a4afeea04f622380e0c1113cc4bfbdea6">bufferSize</a>   = <span class="keyword">sizeof</span>(writeBuffer);</div>
<div class="line">transfer.<a class="code hl_variable" href="group__group__scb__i2c__data__structures.html#a2e158df2a2854d193d589021c2128aa4">xferPending</a>  = <span class="keyword">true</span>; <span class="comment">/* Do not generate Stop condition at the end of transaction */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Initiate write transaction.</span></div>
<div class="line"><span class="comment">* The Start condition is generated to begin this transaction.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">(void) <a class="code hl_function" href="group__group__scb__i2c__master__high__level__functions.html#ga91f7a32d2a20cf3deebe01cef8d9d000">Cy_SCB_I2C_MasterWrite</a>(SCB3, &amp;transfer, &amp;i2cContext);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Wait for transaction completion */</span></div>
<div class="line"><span class="keywordflow">while</span> (0UL != (<a class="code hl_define" href="group__group__scb__i2c__macros__master__status.html#ga412fef33336fb22c95f342ccf2485a0a">CY_SCB_I2C_MASTER_BUSY</a> &amp; <a class="code hl_function" href="group__group__scb__i2c__master__high__level__functions.html#ga652a3b9da6db2424fed62c28c6347ef3">Cy_SCB_I2C_MasterGetStatus</a>(SCB3, &amp;i2cContext)))</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Configure read transaction */</span></div>
<div class="line">transfer.<a class="code hl_variable" href="group__group__scb__i2c__data__structures.html#a17fa9b9a817e002381f07c4982abaffa">buffer</a>       = readBuffer;</div>
<div class="line">transfer.<a class="code hl_variable" href="group__group__scb__i2c__data__structures.html#a4afeea04f622380e0c1113cc4bfbdea6">bufferSize</a>   = <span class="keyword">sizeof</span>(readBuffer);</div>
<div class="line">transfer.<a class="code hl_variable" href="group__group__scb__i2c__data__structures.html#a2e158df2a2854d193d589021c2128aa4">xferPending</a>  = <span class="keyword">false</span>; <span class="comment">/* Generate Stop condition the end of transaction */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Initiate read transaction.</span></div>
<div class="line"><span class="comment">* The ReStart condition is generated to begin this transaction because</span></div>
<div class="line"><span class="comment">* previous transaction was completed without Stop.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">(void) <a class="code hl_function" href="group__group__scb__i2c__master__high__level__functions.html#ga83185adeefa83640ac09852c9d6cf426">Cy_SCB_I2C_MasterRead</a>(SCB3, &amp;transfer, &amp;i2cContext);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Wait for transaction completion */</span></div>
<div class="line"><span class="keywordflow">while</span> (0UL != (<a class="code hl_define" href="group__group__scb__i2c__macros__master__status.html#ga412fef33336fb22c95f342ccf2485a0a">CY_SCB_I2C_MASTER_BUSY</a> &amp; <a class="code hl_function" href="group__group__scb__i2c__master__high__level__functions.html#ga652a3b9da6db2424fed62c28c6347ef3">Cy_SCB_I2C_MasterGetStatus</a>(SCB3, &amp;i2cContext)))</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Process received data */</span></div>
<div class="line"> </div>
<div class="ttc" id="agroup__group__scb__i2c__data__structures_html_a17fa9b9a817e002381f07c4982abaffa"><div class="ttname"><a href="group__group__scb__i2c__data__structures.html#a17fa9b9a817e002381f07c4982abaffa">cy_stc_scb_i2c_master_xfer_config_t::buffer</a></div><div class="ttdeci">uint8_t * buffer</div><div class="ttdoc">The pointer to the buffer for data to read from the slave or data to write into the slave.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:616</div></div>
<div class="ttc" id="agroup__group__scb__i2c__data__structures_html_a2e158df2a2854d193d589021c2128aa4"><div class="ttname"><a href="group__group__scb__i2c__data__structures.html#a2e158df2a2854d193d589021c2128aa4">cy_stc_scb_i2c_master_xfer_config_t::xferPending</a></div><div class="ttdeci">bool xferPending</div><div class="ttdoc">The transfer operation is pending - the stop condition will not be generated.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:635</div></div>
<div class="ttc" id="agroup__group__scb__i2c__data__structures_html_a4afeea04f622380e0c1113cc4bfbdea6"><div class="ttname"><a href="group__group__scb__i2c__data__structures.html#a4afeea04f622380e0c1113cc4bfbdea6">cy_stc_scb_i2c_master_xfer_config_t::bufferSize</a></div><div class="ttdeci">uint32_t bufferSize</div><div class="ttdoc">The size of the buffer.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:619</div></div>
<div class="ttc" id="agroup__group__scb__i2c__data__structures_html_ad593c8662c67ee3d7b766d1bfac64639"><div class="ttname"><a href="group__group__scb__i2c__data__structures.html#ad593c8662c67ee3d7b766d1bfac64639">cy_stc_scb_i2c_master_xfer_config_t::slaveAddress</a></div><div class="ttdeci">uint8_t slaveAddress</div><div class="ttdoc">The 7-bit right justified slave address to communicate with.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:610</div></div>
<div class="ttc" id="agroup__group__scb__i2c__data__structures_html_structcy__stc__scb__i2c__master__xfer__config__t"><div class="ttname"><a href="group__group__scb__i2c__data__structures.html#structcy__stc__scb__i2c__master__xfer__config__t">cy_stc_scb_i2c_master_xfer_config_t</a></div><div class="ttdoc">The I2C Master transfer structure.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:608</div></div>
<div class="ttc" id="agroup__group__scb__i2c__macros__master__status_html_ga412fef33336fb22c95f342ccf2485a0a"><div class="ttname"><a href="group__group__scb__i2c__macros__master__status.html#ga412fef33336fb22c95f342ccf2485a0a">CY_SCB_I2C_MASTER_BUSY</a></div><div class="ttdeci">#define CY_SCB_I2C_MASTER_BUSY</div><div class="ttdoc">The master is busy executing operation started by Cy_SCB_I2C_MasterRead or Cy_SCB_I2C_MasterWrite.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:822</div></div>
<div class="ttc" id="agroup__group__scb__i2c__master__high__level__functions_html_ga652a3b9da6db2424fed62c28c6347ef3"><div class="ttname"><a href="group__group__scb__i2c__master__high__level__functions.html#ga652a3b9da6db2424fed62c28c6347ef3">Cy_SCB_I2C_MasterGetStatus</a></div><div class="ttdeci">uint32_t Cy_SCB_I2C_MasterGetStatus(CySCB_Type const *base, cy_stc_scb_i2c_context_t const *context)</div><div class="ttdoc">Returns the current I2C master status.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:1184</div></div>
<div class="ttc" id="agroup__group__scb__i2c__master__high__level__functions_html_ga83185adeefa83640ac09852c9d6cf426"><div class="ttname"><a href="group__group__scb__i2c__master__high__level__functions.html#ga83185adeefa83640ac09852c9d6cf426">Cy_SCB_I2C_MasterRead</a></div><div class="ttdeci">cy_en_scb_i2c_status_t Cy_SCB_I2C_MasterRead(CySCB_Type *base, cy_stc_scb_i2c_master_xfer_config_t *xferConfig, cy_stc_scb_i2c_context_t *context)</div><div class="ttdoc">This function configures the master to automatically read an entire buffer of data from the slave dev...</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:1244</div></div>
<div class="ttc" id="agroup__group__scb__i2c__master__high__level__functions_html_ga91f7a32d2a20cf3deebe01cef8d9d000"><div class="ttname"><a href="group__group__scb__i2c__master__high__level__functions.html#ga91f7a32d2a20cf3deebe01cef8d9d000">Cy_SCB_I2C_MasterWrite</a></div><div class="ttdeci">cy_en_scb_i2c_status_t Cy_SCB_I2C_MasterWrite(CySCB_Type *base, cy_stc_scb_i2c_master_xfer_config_t *xferConfig, cy_stc_scb_i2c_context_t *context)</div><div class="ttdoc">This function configures the master to automatically write an entire buffer of data to a slave device...</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:1472</div></div>
</div><!-- fragment --><h3><a class="anchor" id="group_scb_i2c_master_ll"></a>
Use Low-Level Functions</h3>
<p >Call <a class="el" href="group__group__scb__i2c__master__low__level__functions.html#ga15fa1a79148b846fd348ce39094876f0">Cy_SCB_I2C_MasterSendStart</a> to generate a start, send an address with the Read/Write direction bit, and receive acknowledgment. After the address is ACKed by the slave, the transaction can be continued by calling <a class="el" href="group__group__scb__i2c__master__low__level__functions.html#ga0679a2b27cf3be4d1a6cd20246688fef">Cy_SCB_I2C_MasterReadByte</a> or <a class="el" href="group__group__scb__i2c__master__low__level__functions.html#ga7eb0684e4d362668f0637d1e82405551">Cy_SCB_I2C_MasterWriteByte</a> depending on its direction. These functions handle one byte per call. Therefore, they should be called for each byte in the transaction. Note that for the Read transaction, the last byte must be NAKed. To complete the current transaction, call <a class="el" href="group__group__scb__i2c__master__low__level__functions.html#ga4b098cd781eaa5cd287ae33e05c86a0d">Cy_SCB_I2C_MasterSendStop</a> or call <a class="el" href="group__group__scb__i2c__master__low__level__functions.html#ga2177b4fb74cf33e57e6fa59d04bdfa7a">Cy_SCB_I2C_MasterSendReStart</a> to complete the current transaction and start a new one. Typically, do a restart to change the transaction direction without releasing the bus from the master control. The Low-Level functions are blocking and do not require calling <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a> inside the interrupt handler. Using these functions requires extensive knowledge of the I2C protocol to execute transactions correctly.</p>
<p ><b>Master Write Operation</b> </p><div class="fragment"><div class="line"><a class="code hl_enumeration" href="group__group__scb__i2c__enums.html#gaf621eb0719ad9ad7178d02268575b247">cy_en_scb_i2c_status_t</a> status;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Buffer to write to the slave */</span></div>
<div class="line">uint8_t buffer[] = {0x55, 0x44, 0x33};</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Wait 100 ms until operation completion */</span></div>
<div class="line">uint32_t timeout = 100UL;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Send Start condition, address and receive ACK/NACK response from slave */</span></div>
<div class="line">status = <a class="code hl_function" href="group__group__scb__i2c__master__low__level__functions.html#ga15fa1a79148b846fd348ce39094876f0">Cy_SCB_I2C_MasterSendStart</a>(SCB3, 0x08U, <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#gga6a168a5e662ce781920027bebbab5d8da62791e1d00155a9693ceb8310aff2fee">CY_SCB_I2C_WRITE_XFER</a>, timeout, &amp;i2cContext);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a> == status)</div>
<div class="line">{</div>
<div class="line">    uint32_t cnt = 0UL;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Write data into the slave from the buffer */</span></div>
<div class="line">    <span class="keywordflow">do</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Write byte and receive ACK/NACK response */</span></div>
<div class="line">        status = <a class="code hl_function" href="group__group__scb__i2c__master__low__level__functions.html#ga7eb0684e4d362668f0637d1e82405551">Cy_SCB_I2C_MasterWriteByte</a>(SCB3, buffer[cnt], timeout, &amp;i2cContext);</div>
<div class="line">        ++cnt;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">while</span>((status == <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a>) &amp;&amp; (cnt &lt; <span class="keyword">sizeof</span>(buffer)));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Check status of transaction */</span></div>
<div class="line"><span class="keywordflow">if</span> ((status == <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a>)           ||</div>
<div class="line">    (status == <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247ada7da6531ad390819f7fa40f41c8c8e2">CY_SCB_I2C_MASTER_MANUAL_NAK</a>) ||</div>
<div class="line">    (status == <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a779a11182cb3545ae0a7a615e5f322cb">CY_SCB_I2C_MASTER_MANUAL_ADDR_NAK</a>))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Send Stop condition on the bus */</span></div>
<div class="line">    status = <a class="code hl_function" href="group__group__scb__i2c__master__low__level__functions.html#ga4b098cd781eaa5cd287ae33e05c86a0d">Cy_SCB_I2C_MasterSendStop</a>(SCB3, timeout, &amp;i2cContext);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (status == <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Stop was successfully executed on the bus after a non-acknowledged address,</span></div>
<div class="line"><span class="comment">           a NAK during transfer, or a successful slave transaction */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Other statuses do not require any actions */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="agroup__group__scb__i2c__enums_html_gaf621eb0719ad9ad7178d02268575b247"><div class="ttname"><a href="group__group__scb__i2c__enums.html#gaf621eb0719ad9ad7178d02268575b247">cy_en_scb_i2c_status_t</a></div><div class="ttdeci">cy_en_scb_i2c_status_t</div><div class="ttdoc">I2C status codes.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:332</div></div>
<div class="ttc" id="agroup__group__scb__i2c__enums_html_gga6a168a5e662ce781920027bebbab5d8da62791e1d00155a9693ceb8310aff2fee"><div class="ttname"><a href="group__group__scb__i2c__enums.html#gga6a168a5e662ce781920027bebbab5d8da62791e1d00155a9693ceb8310aff2fee">CY_SCB_I2C_WRITE_XFER</a></div><div class="ttdeci">@ CY_SCB_I2C_WRITE_XFER</div><div class="ttdoc">Current transaction is Write.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:395</div></div>
<div class="ttc" id="agroup__group__scb__i2c__enums_html_ggaf621eb0719ad9ad7178d02268575b247a779a11182cb3545ae0a7a615e5f322cb"><div class="ttname"><a href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a779a11182cb3545ae0a7a615e5f322cb">CY_SCB_I2C_MASTER_MANUAL_ADDR_NAK</a></div><div class="ttdeci">@ CY_SCB_I2C_MASTER_MANUAL_ADDR_NAK</div><div class="ttdoc">The slave NACKed the address.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:355</div></div>
<div class="ttc" id="agroup__group__scb__i2c__enums_html_ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0"><div class="ttname"><a href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a></div><div class="ttdeci">@ CY_SCB_I2C_SUCCESS</div><div class="ttdoc">Operation completed successfully.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:334</div></div>
<div class="ttc" id="agroup__group__scb__i2c__enums_html_ggaf621eb0719ad9ad7178d02268575b247ada7da6531ad390819f7fa40f41c8c8e2"><div class="ttname"><a href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247ada7da6531ad390819f7fa40f41c8c8e2">CY_SCB_I2C_MASTER_MANUAL_NAK</a></div><div class="ttdeci">@ CY_SCB_I2C_MASTER_MANUAL_NAK</div><div class="ttdoc">The slave NACKed the data byte.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:360</div></div>
<div class="ttc" id="agroup__group__scb__i2c__master__low__level__functions_html_ga15fa1a79148b846fd348ce39094876f0"><div class="ttname"><a href="group__group__scb__i2c__master__low__level__functions.html#ga15fa1a79148b846fd348ce39094876f0">Cy_SCB_I2C_MasterSendStart</a></div><div class="ttdeci">cy_en_scb_i2c_status_t Cy_SCB_I2C_MasterSendStart(CySCB_Type *base, uint32_t address, cy_en_scb_i2c_direction_t bitRnW, uint32_t timeoutMs, cy_stc_scb_i2c_context_t *context)</div><div class="ttdoc">Generates a Start condition and sends a slave address with the Read/Write bit.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:1744</div></div>
<div class="ttc" id="agroup__group__scb__i2c__master__low__level__functions_html_ga4b098cd781eaa5cd287ae33e05c86a0d"><div class="ttname"><a href="group__group__scb__i2c__master__low__level__functions.html#ga4b098cd781eaa5cd287ae33e05c86a0d">Cy_SCB_I2C_MasterSendStop</a></div><div class="ttdeci">cy_en_scb_i2c_status_t Cy_SCB_I2C_MasterSendStop(CySCB_Type *base, uint32_t timeoutMs, cy_stc_scb_i2c_context_t *context)</div><div class="ttdoc">Generates a Stop condition to complete the current transaction.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:1942</div></div>
<div class="ttc" id="agroup__group__scb__i2c__master__low__level__functions_html_ga7eb0684e4d362668f0637d1e82405551"><div class="ttname"><a href="group__group__scb__i2c__master__low__level__functions.html#ga7eb0684e4d362668f0637d1e82405551">Cy_SCB_I2C_MasterWriteByte</a></div><div class="ttdeci">cy_en_scb_i2c_status_t Cy_SCB_I2C_MasterWriteByte(CySCB_Type *base, uint8_t byte, uint32_t timeoutMs, cy_stc_scb_i2c_context_t *context)</div><div class="ttdoc">Sends one byte to a slave.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:2108</div></div>
</div><!-- fragment --><p ><b>Master Read Operation</b> </p><div class="fragment"><div class="line"><a class="code hl_enumeration" href="group__group__scb__i2c__enums.html#gaf621eb0719ad9ad7178d02268575b247">cy_en_scb_i2c_status_t</a> status;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Buffer to write to the slave */</span></div>
<div class="line">uint8_t buffer[5U];</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Wait 100 ms until operation completion */</span></div>
<div class="line">uint32_t timeout = 100UL;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Send Start condition, address and receive ACK/NACK response from slave */</span></div>
<div class="line">status = <a class="code hl_function" href="group__group__scb__i2c__master__low__level__functions.html#ga15fa1a79148b846fd348ce39094876f0">Cy_SCB_I2C_MasterSendStart</a>(SCB3, 0x08U, <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#gga6a168a5e662ce781920027bebbab5d8da62791e1d00155a9693ceb8310aff2fee">CY_SCB_I2C_WRITE_XFER</a>, timeout, &amp;i2cContext);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a> == status)</div>
<div class="line">{</div>
<div class="line">    uint32_t cnt = 0UL;</div>
<div class="line">    <a class="code hl_enumeration" href="group__group__scb__i2c__enums.html#ga4600410051f7febf79d167ffbf85d7ef">cy_en_scb_i2c_command_t</a> cmd = <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#gga4600410051f7febf79d167ffbf85d7efadd6046656aba93adef7c4823a25081fd">CY_SCB_I2C_ACK</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Read data from the slave into the buffer */</span></div>
<div class="line">    <span class="keywordflow">do</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (cnt == (<span class="keyword">sizeof</span>(buffer) - 1UL))</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* The last byte must be NACKed */</span></div>
<div class="line">            cmd = <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#gga4600410051f7febf79d167ffbf85d7efa46363791a98697b7b015b3b64441bfc6">CY_SCB_I2C_NAK</a>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Read byte and generate ACK / or prepare for NACK */</span></div>
<div class="line">        status = <a class="code hl_function" href="group__group__scb__i2c__master__low__level__functions.html#ga0679a2b27cf3be4d1a6cd20246688fef">Cy_SCB_I2C_MasterReadByte</a>(SCB3, cmd, &amp;buffer[cnt], timeout, &amp;i2cContext);</div>
<div class="line">        ++cnt;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">while</span>((status == <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a>) &amp;&amp; (cnt &lt; <span class="keyword">sizeof</span>(buffer)));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Check status of transaction */</span></div>
<div class="line"><span class="keywordflow">if</span> ((status == <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a>)           ||</div>
<div class="line">    (status == <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247ada7da6531ad390819f7fa40f41c8c8e2">CY_SCB_I2C_MASTER_MANUAL_NAK</a>) ||</div>
<div class="line">    (status == <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a779a11182cb3545ae0a7a615e5f322cb">CY_SCB_I2C_MASTER_MANUAL_ADDR_NAK</a>))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Send Stop condition on the bus */</span></div>
<div class="line">    status = <a class="code hl_function" href="group__group__scb__i2c__master__low__level__functions.html#ga4b098cd781eaa5cd287ae33e05c86a0d">Cy_SCB_I2C_MasterSendStop</a>(SCB3, timeout, &amp;i2cContext);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (status == <a class="code hl_enumvalue" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Process received data */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Other statuses do not require any actions.</span></div>
<div class="line"><span class="comment">    * The received data should dropped.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__scb__i2c__enums_html_ga4600410051f7febf79d167ffbf85d7ef"><div class="ttname"><a href="group__group__scb__i2c__enums.html#ga4600410051f7febf79d167ffbf85d7ef">cy_en_scb_i2c_command_t</a></div><div class="ttdeci">cy_en_scb_i2c_command_t</div><div class="ttdoc">I2C Command ACK / NAK.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:401</div></div>
<div class="ttc" id="agroup__group__scb__i2c__enums_html_gga4600410051f7febf79d167ffbf85d7efa46363791a98697b7b015b3b64441bfc6"><div class="ttname"><a href="group__group__scb__i2c__enums.html#gga4600410051f7febf79d167ffbf85d7efa46363791a98697b7b015b3b64441bfc6">CY_SCB_I2C_NAK</a></div><div class="ttdeci">@ CY_SCB_I2C_NAK</div><div class="ttdoc">Send NAK to current byte.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:403</div></div>
<div class="ttc" id="agroup__group__scb__i2c__enums_html_gga4600410051f7febf79d167ffbf85d7efadd6046656aba93adef7c4823a25081fd"><div class="ttname"><a href="group__group__scb__i2c__enums.html#gga4600410051f7febf79d167ffbf85d7efadd6046656aba93adef7c4823a25081fd">CY_SCB_I2C_ACK</a></div><div class="ttdeci">@ CY_SCB_I2C_ACK</div><div class="ttdoc">Send ACK to current byte.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:402</div></div>
<div class="ttc" id="agroup__group__scb__i2c__master__low__level__functions_html_ga0679a2b27cf3be4d1a6cd20246688fef"><div class="ttname"><a href="group__group__scb__i2c__master__low__level__functions.html#ga0679a2b27cf3be4d1a6cd20246688fef">Cy_SCB_I2C_MasterReadByte</a></div><div class="ttdeci">cy_en_scb_i2c_status_t Cy_SCB_I2C_MasterReadByte(CySCB_Type *base, cy_en_scb_i2c_command_t ackNack, uint8_t *byte, uint32_t timeoutMs, cy_stc_scb_i2c_context_t *context)</div><div class="ttdoc">Reads one byte from a slave and generates an ACK or prepares to generate a NAK.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:2016</div></div>
</div><!-- fragment --><h2><a class="anchor" id="group_scb_i2c_slave"></a>
Slave Operation</h2>
<p >Slave operation requires the <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a> be called inside the interrupt handler. The read and write buffers must be provided for the slave to enable communication with the master. Use <a class="el" href="group__group__scb__i2c__slave__functions.html#ga179b4495d7255567bb8b166e16e5a073">Cy_SCB_I2C_SlaveConfigReadBuf</a> and <a class="el" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a> for this purpose. Note that after transaction completion the buffer must be configured again. Otherwise, the same buffer is used starting from the point where the master stopped a previous transaction. For example: The read buffer is configured to be 10 bytes and the master reads 8 bytes. If the read buffer is not configured again, the next master read will start from the 9th byte. To monitor the transaction status, use <a class="el" href="group__group__scb__i2c__slave__functions.html#gab3e1c474d6a5c7c5547ea08aa5d59e22">Cy_SCB_I2C_SlaveGetStatus</a> or use <a class="el" href="group__group__scb__i2c__interrupt__functions.html#gac61f7304c304421a40135cf4d61a660c">Cy_SCB_I2C_RegisterEventCallback</a> to register a callback function to be notified about <a class="el" href="group__group__scb__i2c__macros__callback__events.html">I2C Callback Events</a>.</p>
<p ><b>Get Slave Events Notification</b> </p><div class="fragment"><div class="line"><span class="comment">/* Register callback for event notification.</span></div>
<div class="line"><span class="comment">* It is better to do this during initialization before I2C is enabled.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><a class="code hl_function" href="group__group__scb__i2c__interrupt__functions.html#gac61f7304c304421a40135cf4d61a660c">Cy_SCB_I2C_RegisterEventCallback</a>(SCB3, I2C_SlaveEventHandler, &amp;i2cContext);</div>
<div class="ttc" id="agroup__group__scb__i2c__interrupt__functions_html_gac61f7304c304421a40135cf4d61a660c"><div class="ttname"><a href="group__group__scb__i2c__interrupt__functions.html#gac61f7304c304421a40135cf4d61a660c">Cy_SCB_I2C_RegisterEventCallback</a></div><div class="ttdeci">__STATIC_INLINE void Cy_SCB_I2C_RegisterEventCallback(CySCB_Type const *base, cy_cb_scb_i2c_handle_events_t callback, cy_stc_scb_i2c_context_t *context)</div><div class="ttdoc">Registers a callback function that notifies that I2C Callback Events occurred in the Cy_SCB_I2C_Inter...</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:1345</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/* Callback implementation */</span></div>
<div class="line"><span class="keywordtype">void</span> I2C_SlaveEventHandler(uint32_t events)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Slave sent data to master */</span></div>
<div class="line">    <span class="keywordflow">if</span> (0UL != (events &amp; <a class="code hl_define" href="group__group__scb__i2c__macros__callback__events.html#gae44345d38014821cc5d5c918dd074324">CY_SCB_I2C_SLAVE_RD_CMPLT_EVENT</a>))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (0UL == (events &amp; <a class="code hl_define" href="group__group__scb__i2c__macros__callback__events.html#ga88e999437b51f24bdaf50c6dac83d81c">CY_SCB_I2C_SLAVE_ERR_EVENT</a>))</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* Read complete without errors: update buffer content */</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup read buffer for the next read transaction */</span></div>
<div class="line">        <a class="code hl_function" href="group__group__scb__i2c__slave__functions.html#ga179b4495d7255567bb8b166e16e5a073">Cy_SCB_I2C_SlaveConfigReadBuf</a>(SCB3, i2cReadBuffer,  BUFFER_SIZE, &amp;i2cContext);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Slave received data from master */</span></div>
<div class="line">    <span class="keywordflow">if</span> (0UL != (events &amp; <a class="code hl_define" href="group__group__scb__i2c__macros__callback__events.html#gaa509ff3cd20d1b1d31e3c22e7c28871f">CY_SCB_I2C_SLAVE_WR_CMPLT_EVENT</a>))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (0UL == (events &amp; <a class="code hl_define" href="group__group__scb__i2c__macros__callback__events.html#ga88e999437b51f24bdaf50c6dac83d81c">CY_SCB_I2C_SLAVE_ERR_EVENT</a>))</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* Write complete without errors: process received data */</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup buffer for the next write transaction */</span></div>
<div class="line">        <a class="code hl_function" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a>(SCB3, i2cWriteBuffer, BUFFER_SIZE, &amp;i2cContext);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Ignore all other events */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__scb__i2c__macros__callback__events_html_ga88e999437b51f24bdaf50c6dac83d81c"><div class="ttname"><a href="group__group__scb__i2c__macros__callback__events.html#ga88e999437b51f24bdaf50c6dac83d81c">CY_SCB_I2C_SLAVE_ERR_EVENT</a></div><div class="ttdeci">#define CY_SCB_I2C_SLAVE_ERR_EVENT</div><div class="ttdoc">Indicates the I2C hardware detected an error.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:900</div></div>
<div class="ttc" id="agroup__group__scb__i2c__macros__callback__events_html_gaa509ff3cd20d1b1d31e3c22e7c28871f"><div class="ttname"><a href="group__group__scb__i2c__macros__callback__events.html#gaa509ff3cd20d1b1d31e3c22e7c28871f">CY_SCB_I2C_SLAVE_WR_CMPLT_EVENT</a></div><div class="ttdeci">#define CY_SCB_I2C_SLAVE_WR_CMPLT_EVENT</div><div class="ttdoc">Indicates the master completed writing to the slave (set by the master Stop or Restart)</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:894</div></div>
<div class="ttc" id="agroup__group__scb__i2c__macros__callback__events_html_gae44345d38014821cc5d5c918dd074324"><div class="ttname"><a href="group__group__scb__i2c__macros__callback__events.html#gae44345d38014821cc5d5c918dd074324">CY_SCB_I2C_SLAVE_RD_CMPLT_EVENT</a></div><div class="ttdeci">#define CY_SCB_I2C_SLAVE_RD_CMPLT_EVENT</div><div class="ttdoc">Indicates the master completed reading from the slave (set by the master NAK or Stop)</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:888</div></div>
</div><!-- fragment --><p ><b>Polling Slave Completion Events</b> </p><div class="fragment"><div class="line"><span class="comment">/* Disable I2C Interrupt: protect code from interruption */</span></div>
<div class="line">NVIC_DisableIRQ(I2C_INTR_NUM);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Check if write transaction completed */</span></div>
<div class="line"><span class="keywordflow">if</span> (0UL != (<a class="code hl_define" href="group__group__scb__i2c__macros__slave__status.html#ga0e917e7b1f8b297bb97716a0a742a14a">CY_SCB_I2C_SLAVE_WR_CMPLT</a> &amp; <a class="code hl_function" href="group__group__scb__i2c__slave__functions.html#gab3e1c474d6a5c7c5547ea08aa5d59e22">Cy_SCB_I2C_SlaveGetStatus</a>(SCB3, &amp;i2cContext)))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Process received data */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Configure buffer for the next write */</span></div>
<div class="line">    <a class="code hl_function" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a>(SCB3, i2cWriteBuffer, BUFFER_SIZE, &amp;i2cContext);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Clear slave write status to capture following updates */</span></div>
<div class="line">    <a class="code hl_function" href="group__group__scb__i2c__slave__functions.html#ga73636c22f0db8c09d790f387aa35e6be">Cy_SCB_I2C_SlaveClearWriteStatus</a>(SCB3, &amp;i2cContext);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Enable I2C interrupt */</span></div>
<div class="line">NVIC_EnableIRQ(I2C_INTR_NUM);</div>
<div class="ttc" id="agroup__group__scb__i2c__macros__slave__status_html_ga0e917e7b1f8b297bb97716a0a742a14a"><div class="ttname"><a href="group__group__scb__i2c__macros__slave__status.html#ga0e917e7b1f8b297bb97716a0a742a14a">CY_SCB_I2C_SLAVE_WR_CMPLT</a></div><div class="ttdeci">#define CY_SCB_I2C_SLAVE_WR_CMPLT</div><div class="ttdoc">The master has finished writing data into the slave.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.h:791</div></div>
<div class="ttc" id="agroup__group__scb__i2c__slave__functions_html_ga73636c22f0db8c09d790f387aa35e6be"><div class="ttname"><a href="group__group__scb__i2c__slave__functions.html#ga73636c22f0db8c09d790f387aa35e6be">Cy_SCB_I2C_SlaveClearWriteStatus</a></div><div class="ttdeci">uint32_t Cy_SCB_I2C_SlaveClearWriteStatus(CySCB_Type const *base, cy_stc_scb_i2c_context_t *context)</div><div class="ttdoc">Clears the write status flags and error condition flags and returns their values.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:1140</div></div>
<div class="ttc" id="agroup__group__scb__i2c__slave__functions_html_gab3e1c474d6a5c7c5547ea08aa5d59e22"><div class="ttname"><a href="group__group__scb__i2c__slave__functions.html#gab3e1c474d6a5c7c5547ea08aa5d59e22">Cy_SCB_I2C_SlaveGetStatus</a></div><div class="ttdeci">uint32_t Cy_SCB_I2C_SlaveGetStatus(CySCB_Type const *base, cy_stc_scb_i2c_context_t const *context)</div><div class="ttdoc">Returns the current I2C slave status.</div><div class="ttdef"><b>Definition:</b> cy_scb_i2c.c:791</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>All slave API (except <a class="el" href="group__group__scb__i2c__slave__functions.html#ga1c9f6c807f4758016bf90cc8f69f96b3">Cy_SCB_I2C_SlaveAbortRead</a> and <a class="el" href="group__group__scb__i2c__slave__functions.html#ga50157a71ba992433bd4fde948d25d44e">Cy_SCB_I2C_SlaveAbortWrite</a>) <b>are not interrupt-protected</b> and to prevent a race condition, they should be protected from the I2C interruption in the place where they are called. The code snippet Polling Slave Completion Events above shows how to prevent a race condition when detect transfer completion and update I2C slave write buffer. The simple example of race condition is: application updates slave read buffer the I2C master starts read transfer. The I2C interrupts read buffer update and I2C interrupt loads current read buffer content in the TX FIFO . After I2C interrupt returns the application updates remaining part of the read buffer. As a result the mater read partly updated buffer.</dd></dl>
<h1><a class="anchor" id="group_scb_i2c_lp"></a>
Low Power Support</h1>
<p >The I2C driver provides callback functions to handle power mode transition. The callback <a class="el" href="group__group__scb__i2c__low__power__functions.html#gaf2044790a92ba63cb11616f2e80d3d1f">Cy_SCB_I2C_DeepSleepCallback</a> must be called during execution of Cy_SysPm_CpuEnterDeepSleep <a class="el" href="group__group__scb__i2c__low__power__functions.html#gaf480cdce47050c37a3558285d6a1c2a7">Cy_SCB_I2C_HibernateCallback</a> must be called during execution of Cy_SysPm_SystemEnterHibernate. To trigger the callback execution, the callback must be registered before calling the power mode transition function. Refer to <a class="el" href="group__group__syspm.html">SysPm (System Power Management)</a> driver for more information about power mode transitions and callback registration. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__scb__i2c__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSOC E8XXGP Device Support Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
