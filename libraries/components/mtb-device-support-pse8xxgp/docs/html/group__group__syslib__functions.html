<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSOC E8XXGP Device Support Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSOC E8XXGP Device Support Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__syslib__functions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Functions<div class="ingroups"><a class="el" href="group__group__pdl__top.html">PDL API Reference</a> &raquo; <a class="el" href="group__group__syslib.html">SysLib       (System Library)</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaad1c32546fdb0e3c6fa8b46fb95843b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gaad1c32546fdb0e3c6fa8b46fb95843b5">Cy_SysLib_Delay</a> (uint32_t milliseconds)</td></tr>
<tr class="memdesc:gaad1c32546fdb0e3c6fa8b46fb95843b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function delays by the specified number of milliseconds.  <a href="group__group__syslib__functions.html#gaad1c32546fdb0e3c6fa8b46fb95843b5">More...</a><br /></td></tr>
<tr class="separator:gaad1c32546fdb0e3c6fa8b46fb95843b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d2ffe4829c636ad78eaae5043fd6ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga9d2ffe4829c636ad78eaae5043fd6ae6">Cy_SysLib_DelayUs</a> (uint16_t microseconds)</td></tr>
<tr class="memdesc:ga9d2ffe4829c636ad78eaae5043fd6ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function delays by the specified number of microseconds.  <a href="group__group__syslib__functions.html#ga9d2ffe4829c636ad78eaae5043fd6ae6">More...</a><br /></td></tr>
<tr class="separator:ga9d2ffe4829c636ad78eaae5043fd6ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f18ab2d6141a84a2be60279096eca59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga6f18ab2d6141a84a2be60279096eca59">Cy_SysLib_Rtos_Delay</a> (uint32_t milliseconds)</td></tr>
<tr class="memdesc:ga6f18ab2d6141a84a2be60279096eca59"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function is same as <a class="el" href="group__group__syslib__functions.html#gaad1c32546fdb0e3c6fa8b46fb95843b5">Cy_SysLib_Delay</a>.  <a href="group__group__syslib__functions.html#ga6f18ab2d6141a84a2be60279096eca59">More...</a><br /></td></tr>
<tr class="separator:ga6f18ab2d6141a84a2be60279096eca59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2688a50431e6083a707290f3ad91356a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga2688a50431e6083a707290f3ad91356a">Cy_SysLib_Rtos_DelayUs</a> (uint16_t microseconds)</td></tr>
<tr class="memdesc:ga2688a50431e6083a707290f3ad91356a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function is same as <a class="el" href="group__group__syslib__functions.html#ga9d2ffe4829c636ad78eaae5043fd6ae6">Cy_SysLib_DelayUs</a>.  <a href="group__group__syslib__functions.html#ga2688a50431e6083a707290f3ad91356a">More...</a><br /></td></tr>
<tr class="separator:ga2688a50431e6083a707290f3ad91356a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e78e8abc25b8b598fb0b7d50e18c69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga58e78e8abc25b8b598fb0b7d50e18c69">Cy_SysLib_DelayCycles</a> (uint32_t cycles)</td></tr>
<tr class="memdesc:ga58e78e8abc25b8b598fb0b7d50e18c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delays for the specified number of cycles.  <a href="group__group__syslib__functions.html#ga58e78e8abc25b8b598fb0b7d50e18c69">More...</a><br /></td></tr>
<tr class="separator:ga58e78e8abc25b8b598fb0b7d50e18c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5ef74a64fe1abbc195da55e4acf075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gaaf5ef74a64fe1abbc195da55e4acf075">Cy_SysLib_Halt</a> (uint32_t reason)</td></tr>
<tr class="memdesc:gaaf5ef74a64fe1abbc195da55e4acf075"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function halts the CPU but only the CPU which calls the function.  <a href="group__group__syslib__functions.html#gaaf5ef74a64fe1abbc195da55e4acf075">More...</a><br /></td></tr>
<tr class="separator:gaaf5ef74a64fe1abbc195da55e4acf075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe70e0948f5d2b2fb1615b85b0d7d7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga0fe70e0948f5d2b2fb1615b85b0d7d7a">Cy_SysLib_AssertFailed</a> (const char_t *file, uint32_t line)</td></tr>
<tr class="memdesc:ga0fe70e0948f5d2b2fb1615b85b0d7d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stores the ASSERT location of the file name (including path to file) and line number in a non-zero init area for debugging.  <a href="group__group__syslib__functions.html#ga0fe70e0948f5d2b2fb1615b85b0d7d7a">More...</a><br /></td></tr>
<tr class="separator:ga0fe70e0948f5d2b2fb1615b85b0d7d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8fb5b7a16fbdfd60cf44d5d8f2c977"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gaaa8fb5b7a16fbdfd60cf44d5d8f2c977">Cy_SysLib_GetUniqueId</a> (void)</td></tr>
<tr class="memdesc:gaaa8fb5b7a16fbdfd60cf44d5d8f2c977"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the silicon unique ID.  <a href="group__group__syslib__functions.html#gaaa8fb5b7a16fbdfd60cf44d5d8f2c977">More...</a><br /></td></tr>
<tr class="separator:gaaa8fb5b7a16fbdfd60cf44d5d8f2c977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb2c8e123ba3a0376a14871e58230321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syslib__enumerated__types.html#ga97d0b049220b931606e2ae2e144994e1">cy_en_syslib_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gadb2c8e123ba3a0376a14871e58230321">Cy_SysLib_ResetBackupDomain</a> (void)</td></tr>
<tr class="memdesc:gadb2c8e123ba3a0376a14871e58230321"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets the backup domain power to avoid the ILO glitch.  <a href="group__group__syslib__functions.html#gadb2c8e123ba3a0376a14871e58230321">More...</a><br /></td></tr>
<tr class="separator:gadb2c8e123ba3a0376a14871e58230321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8aa61d2f8052886c676f4f592d1693d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gac8aa61d2f8052886c676f4f592d1693d">Cy_SysLib_GetResetReason</a> (void)</td></tr>
<tr class="memdesc:gac8aa61d2f8052886c676f4f592d1693d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the cause for the latest reset(s) that occurred in the system.  <a href="group__group__syslib__functions.html#gac8aa61d2f8052886c676f4f592d1693d">More...</a><br /></td></tr>
<tr class="separator:gac8aa61d2f8052886c676f4f592d1693d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb4e952584f0c428f58f7b4dbd3ceff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gaebb4e952584f0c428f58f7b4dbd3ceff">Cy_SysLib_ClearResetReason</a> (void)</td></tr>
<tr class="memdesc:gaebb4e952584f0c428f58f7b4dbd3ceff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the values of RES_CAUSE_EXTEND, RES_CAUSE and RES_CAUSE2.  <a href="group__group__syslib__functions.html#gaebb4e952584f0c428f58f7b4dbd3ceff">More...</a><br /></td></tr>
<tr class="separator:gaebb4e952584f0c428f58f7b4dbd3ceff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea5b87a95001a0b3b2cf128957c58ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syslib__section__macros.html#ga05d6029120643ca76b079fdf2fd1ea12">CY_SECTION_INIT_CODECOPY_BEGIN</a> __STATIC_INLINE <a class="el" href="group__group__syslib__enumerated__types.html#ga97d0b049220b931606e2ae2e144994e1">cy_en_syslib_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gaaea5b87a95001a0b3b2cf128957c58ea">Cy_SysLib_GetResetStatus</a> (void)</td></tr>
<tr class="memdesc:gaaea5b87a95001a0b3b2cf128957c58ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the BACKUP-&gt;RESET bit value.  <a href="group__group__syslib__functions.html#gaaea5b87a95001a0b3b2cf128957c58ea">More...</a><br /></td></tr>
<tr class="separator:gaaea5b87a95001a0b3b2cf128957c58ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4515de2210eb1371c804f3199ac48a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syslib__section__macros.html#ga10926a1e1ebe0e4c7b2024a80cf93266">CY_SECTION_INIT_CODECOPY_END</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga4515de2210eb1371c804f3199ac48a4b">Cy_SysLib_FaultHandler</a> (uint32_t const *faultStackAddr)</td></tr>
<tr class="memdesc:ga4515de2210eb1371c804f3199ac48a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stores the ARM Cortex registers into a non-zero init area for debugging.  <a href="group__group__syslib__functions.html#ga4515de2210eb1371c804f3199ac48a4b">More...</a><br /></td></tr>
<tr class="separator:ga4515de2210eb1371c804f3199ac48a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0852597c5a10b76413a7063711043fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga0852597c5a10b76413a7063711043fef">Cy_SysLib_ProcessingFault</a> (void)</td></tr>
<tr class="memdesc:ga0852597c5a10b76413a7063711043fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines how to process the current fault state.  <a href="group__group__syslib__functions.html#ga0852597c5a10b76413a7063711043fef">More...</a><br /></td></tr>
<tr class="separator:ga0852597c5a10b76413a7063711043fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b897f8554957f9393f645d5ab1106c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> (bool ulpMode, uint32_t clkHfMHz)</td></tr>
<tr class="memdesc:ga8b897f8554957f9393f645d5ab1106c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of clock cycles the cache will wait for, before it samples data coming back from ROM, SRAM, and Flash.  <a href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">More...</a><br /></td></tr>
<tr class="separator:ga8b897f8554957f9393f645d5ab1106c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae679f15a1702c159c105b596a8801105"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gae679f15a1702c159c105b596a8801105">Cy_SysLib_EnterCriticalSection</a> (void)</td></tr>
<tr class="memdesc:gae679f15a1702c159c105b596a8801105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cy_SysLib_EnterCriticalSection disables interrupts and returns a value indicating whether the interrupts were previously enabled.  <a href="group__group__syslib__functions.html#gae679f15a1702c159c105b596a8801105">More...</a><br /></td></tr>
<tr class="separator:gae679f15a1702c159c105b596a8801105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c16343c075610b2888b0693f972b555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga8c16343c075610b2888b0693f972b555">Cy_SysLib_ExitCriticalSection</a> (uint32_t savedIntrStatus)</td></tr>
<tr class="memdesc:ga8c16343c075610b2888b0693f972b555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-enables the interrupts if they were enabled before <a class="el" href="group__group__syslib__functions.html#gae679f15a1702c159c105b596a8801105" title="Cy_SysLib_EnterCriticalSection disables interrupts and returns a value indicating whether the interru...">Cy_SysLib_EnterCriticalSection()</a> was called.  <a href="group__group__syslib__functions.html#ga8c16343c075610b2888b0693f972b555">More...</a><br /></td></tr>
<tr class="separator:ga8c16343c075610b2888b0693f972b555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb3c0de07c70f0a39aa07a4ebb72f64"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gaebb3c0de07c70f0a39aa07a4ebb72f64">Cy_SysLib_GetDeviceRevision</a> (void)</td></tr>
<tr class="memdesc:gaebb3c0de07c70f0a39aa07a4ebb72f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a device Revision ID.  <a href="group__group__syslib__functions.html#gaebb3c0de07c70f0a39aa07a4ebb72f64">More...</a><br /></td></tr>
<tr class="separator:gaebb3c0de07c70f0a39aa07a4ebb72f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31851d85af687fef11473fa11145030d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga31851d85af687fef11473fa11145030d">Cy_SysLib_GetDevice</a> (void)</td></tr>
<tr class="memdesc:ga31851d85af687fef11473fa11145030d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a device Family ID.  <a href="group__group__syslib__functions.html#ga31851d85af687fef11473fa11145030d">More...</a><br /></td></tr>
<tr class="separator:ga31851d85af687fef11473fa11145030d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e96d4a4aed60c9d7e8c186951147c95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syslib__enumerated__types.html#ga3ff462c7740be4b6a2c2d9fbe4282666">cy_en_syslib_lcs_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga8e96d4a4aed60c9d7e8c186951147c95">Cy_SysLib_GetDeviceLCS</a> (cy_syslib_lcs_data_t *base)</td></tr>
<tr class="memdesc:ga8e96d4a4aed60c9d7e8c186951147c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns LCS of Device.  <a href="group__group__syslib__functions.html#ga8e96d4a4aed60c9d7e8c186951147c95">More...</a><br /></td></tr>
<tr class="separator:ga8e96d4a4aed60c9d7e8c186951147c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc2fac2da2d735bedac2a57d45d53fac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gabc2fac2da2d735bedac2a57d45d53fac">Cy_Syslib_SetWarmBootEntryPoint</a> (uint32_t *entryPoint, bool enable)</td></tr>
<tr class="memdesc:gabc2fac2da2d735bedac2a57d45d53fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set Warm boot entry point address to a location read by BootROM.  <a href="group__group__syslib__functions.html#gabc2fac2da2d735bedac2a57d45d53fac">More...</a><br /></td></tr>
<tr class="separator:gabc2fac2da2d735bedac2a57d45d53fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ef05b9419cbb446a501f4a49e233aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gaf3ef05b9419cbb446a501f4a49e233aa">Cy_SysLib_IsDSRAMWarmBootEntry</a> (void)</td></tr>
<tr class="memdesc:gaf3ef05b9419cbb446a501f4a49e233aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return true if the system woke up(From DS-RAM) through Warm boot, else it will return false.  <a href="group__group__syslib__functions.html#gaf3ef05b9419cbb446a501f4a49e233aa">More...</a><br /></td></tr>
<tr class="separator:gaf3ef05b9419cbb446a501f4a49e233aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac340f219d12ebdccb28c370bc3740c34"><td class="memItemLeft" align="right" valign="top"><a id="gac340f219d12ebdccb28c370bc3740c34" name="gac340f219d12ebdccb28c370bc3740c34"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Cy_SysLib_ClearDSRAMWarmBootEntryStatus</b> (void)</td></tr>
<tr class="memdesc:gac340f219d12ebdccb28c370bc3740c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the Warm Boot entry Status flag. <br /></td></tr>
<tr class="separator:gac340f219d12ebdccb28c370bc3740c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb346d0131659f401e2b9d83ea6864d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gafdb346d0131659f401e2b9d83ea6864d">Cy_Syslib_IsMemCacheable</a> (MPU_Type *mpu, uint32_t addr, uint32_t size)</td></tr>
<tr class="memdesc:gafdb346d0131659f401e2b9d83ea6864d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the memory address and the size passed falls in the non-cacheable region or not.  <a href="group__group__syslib__functions.html#gafdb346d0131659f401e2b9d83ea6864d">More...</a><br /></td></tr>
<tr class="separator:gafdb346d0131659f401e2b9d83ea6864d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaad1c32546fdb0e3c6fa8b46fb95843b5" name="gaad1c32546fdb0e3c6fa8b46fb95843b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad1c32546fdb0e3c6fa8b46fb95843b5">&#9670;&nbsp;</a></span>Cy_SysLib_Delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_Delay </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function delays by the specified number of milliseconds. </p>
<p >By default, the number of cycles to delay is calculated based on the <a class="el" href="group__group__startup__config__globals.html#gaa3cd3e43291e81e795d642b79b6088e6">SystemCoreClock</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to delay.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function calls <a class="el" href="group__group__syslib__functions.html#ga58e78e8abc25b8b598fb0b7d50e18c69">Cy_SysLib_DelayCycles()</a> API to generate a delay. If the function parameter (milliseconds) is bigger than CY_DELAY_MS_OVERFLOW constant, then an additional loop runs to prevent an overflow in parameter passed to <a class="el" href="group__group__syslib__functions.html#ga58e78e8abc25b8b598fb0b7d50e18c69">Cy_SysLib_DelayCycles()</a> API.</dd>
<dd>
The Calibration factor is to correct the delay in cases where CPU's use branch prediction, currently applicable for only devices with a CM7 processor.</dd>
<dd>
The accuracy of the delay functions depends on the value of the global variable <a class="el" href="group__group__startup__config__globals.html#gaa3cd3e43291e81e795d642b79b6088e6">SystemCoreClock</a>. If the system clock configuration is changed at runtime or if the project does not call cycfg_config_init() then you must call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> to refresh the SystemCoreClock variable. Failing to do so may result in incorrect delay durations. </dd></dl>

</div>
</div>
<a id="ga9d2ffe4829c636ad78eaae5043fd6ae6" name="ga9d2ffe4829c636ad78eaae5043fd6ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d2ffe4829c636ad78eaae5043fd6ae6">&#9670;&nbsp;</a></span>Cy_SysLib_DelayUs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_DelayUs </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>microseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function delays by the specified number of microseconds. </p>
<p >By default, the number of cycles to delay is calculated based on the <a class="el" href="group__group__startup__config__globals.html#gaa3cd3e43291e81e795d642b79b6088e6">SystemCoreClock</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">microseconds</td><td>The number of microseconds to delay.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the CPU frequency is a small non-integer number, the actual delay can be up to twice as long as the nominal value. The actual delay cannot be shorter than the nominal one.</dd>
<dd>
The Calibration factor is to correct the delay in cases where CPU's use branch prediction, currently applicable for only devices with a CM7 processor.</dd>
<dd>
The accuracy of the delay functions depends on the value of the global variable <a class="el" href="group__group__startup__config__globals.html#gaa3cd3e43291e81e795d642b79b6088e6">SystemCoreClock</a>. If the system clock configuration is changed at runtime or if the project does not call cycfg_config_init() then you must call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> to refresh the SystemCoreClock variable. Failing to do so may result in incorrect delay durations. </dd></dl>

</div>
</div>
<a id="ga6f18ab2d6141a84a2be60279096eca59" name="ga6f18ab2d6141a84a2be60279096eca59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f18ab2d6141a84a2be60279096eca59">&#9670;&nbsp;</a></span>Cy_SysLib_Rtos_Delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_Rtos_Delay </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function is same as <a class="el" href="group__group__syslib__functions.html#gaad1c32546fdb0e3c6fa8b46fb95843b5">Cy_SysLib_Delay</a>. </p>
<p >However, this API is declared WEAK providing option for user to overwrite the implementation based on target RTOS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to delay. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2688a50431e6083a707290f3ad91356a" name="ga2688a50431e6083a707290f3ad91356a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2688a50431e6083a707290f3ad91356a">&#9670;&nbsp;</a></span>Cy_SysLib_Rtos_DelayUs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_Rtos_DelayUs </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>microseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function is same as <a class="el" href="group__group__syslib__functions.html#ga9d2ffe4829c636ad78eaae5043fd6ae6">Cy_SysLib_DelayUs</a>. </p>
<p >However, this API is declared WEAK providing option for user to overwrite the implementation based on target RTOS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">microseconds</td><td>The number of microseconds to delay. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58e78e8abc25b8b598fb0b7d50e18c69" name="ga58e78e8abc25b8b598fb0b7d50e18c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58e78e8abc25b8b598fb0b7d50e18c69">&#9670;&nbsp;</a></span>Cy_SysLib_DelayCycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_DelayCycles </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cycles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delays for the specified number of cycles. </p>
<p >The function is implemented in the assembler for each supported compiler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycles</td><td>The number of cycles to delay.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>While using for devices with a CM7 CPU, where the CPU supports branch prediction, this API needs to be called as below Cy_SysLib_DelayCycles(cycles * CY_SYSLIB_DELAY_CALIBRATION_FACTOR); For Example:- CY_SYSLIB_DELAY_CALIBRATION_FACTOR = 1 for CM0P, CM33 and CM4. CY_SYSLIB_DELAY_CALIBRATION_FACTOR = 2 for CM7_0 and CM7_1.</dd>
<dd>
The accuracy of the delay functions depends on the value of the global variable <a class="el" href="group__group__startup__config__globals.html#gaa3cd3e43291e81e795d642b79b6088e6">SystemCoreClock</a>. If the system clock configuration is changed at runtime or if the project does not call cycfg_config_init() then you must call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> to refresh the SystemCoreClock variable. Failing to do so may result in incorrect delay durations. </dd></dl>

</div>
</div>
<a id="gaaf5ef74a64fe1abbc195da55e4acf075" name="gaaf5ef74a64fe1abbc195da55e4acf075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf5ef74a64fe1abbc195da55e4acf075">&#9670;&nbsp;</a></span>Cy_SysLib_Halt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_Halt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reason</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function halts the CPU but only the CPU which calls the function. </p>
<p >It doesn't affect other CPUs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>The value to be used during debugging.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function executes the BKPT instruction for halting CPU and is intended to be used for the debug purpose. A regular use case requires Debugger attachment before the function call. The BKPT instruction causes the CPU to enter the Debug state. Debug tools can use this to investigate the system state, when the instruction at a particular address is reached.</dd>
<dd>
Execution of a BKPT instruction without a debugger attached produces a fault. The fault results in the HardFault exception being taken or causes a Lockup state if it occurs in the NMI or HardFault handler. The default HardFault handler make a software reset if the build option is the release mode (NDEBUG). If the build option is the debug mode, the system will stay in the infinite loop of the <a class="el" href="group__group__syslib__functions.html#ga0852597c5a10b76413a7063711043fef">Cy_SysLib_ProcessingFault()</a> function. </dd></dl>

</div>
</div>
<a id="ga0fe70e0948f5d2b2fb1615b85b0d7d7a" name="ga0fe70e0948f5d2b2fb1615b85b0d7d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fe70e0948f5d2b2fb1615b85b0d7d7a">&#9670;&nbsp;</a></span>Cy_SysLib_AssertFailed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_AssertFailed </td>
          <td>(</td>
          <td class="paramtype">const char_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stores the ASSERT location of the file name (including path to file) and line number in a non-zero init area for debugging. </p>
<p >Also it calls the <a class="el" href="group__group__syslib__functions.html#gaaf5ef74a64fe1abbc195da55e4acf075">Cy_SysLib_Halt()</a> function to halt the processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file name of the ASSERT location. </td></tr>
    <tr><td class="paramname">line</td><td>The line number of the ASSERT location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A stored file name and line number could be accessed by cy_assertFileName and cy_assertLine global variables. </dd>
<dd>
This function has the WEAK option, so the user can redefine the function for a custom processing. </dd></dl>

</div>
</div>
<a id="gaaa8fb5b7a16fbdfd60cf44d5d8f2c977" name="gaaa8fb5b7a16fbdfd60cf44d5d8f2c977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8fb5b7a16fbdfd60cf44d5d8f2c977">&#9670;&nbsp;</a></span>Cy_SysLib_GetUniqueId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Cy_SysLib_GetUniqueId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the silicon unique ID. </p>
<p >The ID includes Die lot[3]#, Die Wafer#, Die X, Die Y, Die Sort#, Die Minor and Die Year.</p>
<dl class="section return"><dt>Returns</dt><dd>A combined 64-bit unique ID. [63:57] - DIE_YEAR [56:56] - DIE_MINOR [55:48] - DIE_SORT [47:40] - DIE_Y [39:32] - DIE_X [31:24] - DIE_WAFER [23:16] - DIE_LOT[2] [15: 8] - DIE_LOT[1] [ 7: 0] - DIE_LOT[0]</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for devices having M4CPUSS, CY_IP_M33SYSCPUSS and CY_IP_M55APPCPUSS IP.</dd>
<dd>
For CY_IP_M33SYSCPUSS IP, EFUSE must be in enabled state before calling this API.</dd>
<dd>
For Cores with Security extention, Trust Zone configuration should be done before calling this API. </dd></dl>

</div>
</div>
<a id="gadb2c8e123ba3a0376a14871e58230321" name="gadb2c8e123ba3a0376a14871e58230321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb2c8e123ba3a0376a14871e58230321">&#9670;&nbsp;</a></span>Cy_SysLib_ResetBackupDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syslib__enumerated__types.html#ga97d0b049220b931606e2ae2e144994e1">cy_en_syslib_status_t</a> Cy_SysLib_ResetBackupDomain </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets the backup domain power to avoid the ILO glitch. </p>
<p >The glitch can occur when the device is reset due to POR/BOD/XRES while the backup voltage is supplied into the system.</p>
<dl class="section note"><dt>Note</dt><dd>Writing 1 to BACKUP-&gt;RESET resets the backup logic. Hardware clears it when the reset is complete. After setting the register, this function reads the register immediately for returning the result of the backup domain reset state. The reading register is important because the Read itself takes multiple AHB clock cycles, and the reset is actually finishing during that time. Use <a class="el" href="group__group__syslib__functions.html#gaaea5b87a95001a0b3b2cf128957c58ea">Cy_SysLib_GetResetStatus</a> to check the BACKUP-&gt;RESET before any other BACKUP register write.</dd>
<dd>
This function also resets the WCO trimming value - use the Cy_SysLib_GetWcoTrim and Cy_SysLib_SetWcoTrim to store/restore the WCO trimming value.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>CY_SYSLIB_SUCCESS, if BACKUP-&gt;RESET read-back is 0. Otherwise returns CY_SYSLIB_INVALID_STATE.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to reset backup domain and WCO is used */</span></div>
<div class="line">    uint32_t wcoTrim = Cy_SysLib_GetWcoTrim(); <span class="comment">/* Store the WCO trim value */</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="group__group__syslib__enumerated__types.html#gga97d0b049220b931606e2ae2e144994e1a7d26e21cf3c67f4202b35c3c6bcde534">CY_SYSLIB_SUCCESS</a> != <a class="code hl_function" href="group__group__syslib__functions.html#gadb2c8e123ba3a0376a14871e58230321">Cy_SysLib_ResetBackupDomain</a>())</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_function" href="group__group__syslib__functions.html#ga9d2ffe4829c636ad78eaae5043fd6ae6">Cy_SysLib_DelayUs</a>(1U); <span class="comment">/* 1 us delay should be enough */</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="group__group__syslib__enumerated__types.html#gga97d0b049220b931606e2ae2e144994e1a7d26e21cf3c67f4202b35c3c6bcde534">CY_SYSLIB_SUCCESS</a> != <a class="code hl_function" href="group__group__syslib__functions.html#gaaea5b87a95001a0b3b2cf128957c58ea">Cy_SysLib_GetResetStatus</a>())</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* Reset bit is not cleared too long - check the CLK_BAK */</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    Cy_SysLib_SetWcoTrim(wcoTrim); <span class="comment">/* Restore the WCO trim value */</span></div>
<div class="ttc" id="agroup__group__syslib__enumerated__types_html_gga97d0b049220b931606e2ae2e144994e1a7d26e21cf3c67f4202b35c3c6bcde534"><div class="ttname"><a href="group__group__syslib__enumerated__types.html#gga97d0b049220b931606e2ae2e144994e1a7d26e21cf3c67f4202b35c3c6bcde534">CY_SYSLIB_SUCCESS</a></div><div class="ttdeci">@ CY_SYSLIB_SUCCESS</div><div class="ttdoc">The success status code.</div><div class="ttdef"><b>Definition:</b> cy_syslib.h:236</div></div>
<div class="ttc" id="agroup__group__syslib__functions_html_ga9d2ffe4829c636ad78eaae5043fd6ae6"><div class="ttname"><a href="group__group__syslib__functions.html#ga9d2ffe4829c636ad78eaae5043fd6ae6">Cy_SysLib_DelayUs</a></div><div class="ttdeci">void Cy_SysLib_DelayUs(uint16_t microseconds)</div><div class="ttdoc">The function delays by the specified number of microseconds.</div><div class="ttdef"><b>Definition:</b> cy_syslib.c:119</div></div>
<div class="ttc" id="agroup__group__syslib__functions_html_gaaea5b87a95001a0b3b2cf128957c58ea"><div class="ttname"><a href="group__group__syslib__functions.html#gaaea5b87a95001a0b3b2cf128957c58ea">Cy_SysLib_GetResetStatus</a></div><div class="ttdeci">CY_SECTION_INIT_CODECOPY_BEGIN __STATIC_INLINE cy_en_syslib_status_t Cy_SysLib_GetResetStatus(void)</div><div class="ttdoc">This function returns the BACKUP-&gt;RESET bit value.</div><div class="ttdef"><b>Definition:</b> cy_syslib.h:1154</div></div>
<div class="ttc" id="agroup__group__syslib__functions_html_gadb2c8e123ba3a0376a14871e58230321"><div class="ttname"><a href="group__group__syslib__functions.html#gadb2c8e123ba3a0376a14871e58230321">Cy_SysLib_ResetBackupDomain</a></div><div class="ttdeci">cy_en_syslib_status_t Cy_SysLib_ResetBackupDomain(void)</div><div class="ttdoc">This function resets the backup domain power to avoid the ILO glitch.</div><div class="ttdef"><b>Definition:</b> cy_syslib.c:181</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gac8aa61d2f8052886c676f4f592d1693d" name="gac8aa61d2f8052886c676f4f592d1693d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8aa61d2f8052886c676f4f592d1693d">&#9670;&nbsp;</a></span>Cy_SysLib_GetResetReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SysLib_GetResetReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the cause for the latest reset(s) that occurred in the system. </p>
<p >The reset causes include system faults and device reset on a wakeup from Hibernate mode. For M33SYSCPUSS IP, the reset causes also include an HFCLK error. The return results are consolidated reset causes from reading RES_CAUSE, RES_CAUSE2 and PWR_HIBERNATE token registers.</p>
<dl class="section return"><dt>Returns</dt><dd>The cause of a system reset. Return values to be checked as per the CPUSS IP of the device.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name in M4CPUSS IP   </th><th class="markdownTableHeadNone">Name in M33SYSCPUSS IP   </th><th class="markdownTableHeadNone">Name in M7CPUSS IP   </th><th class="markdownTableHeadNone">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CY_SYSLIB_RESET_HWWDT   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_HWWDT   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_HWWDT   </td><td class="markdownTableBodyNone">0x00001 (bit0)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CY_SYSLIB_RESET_ACT_FAULT   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_ACT_FAULT   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_ACT_FAULT   </td><td class="markdownTableBodyNone">0x00002 (bit1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CY_SYSLIB_RESET_DPSLP_FAULT   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_DPSLP_FAULT   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_DPSLP_FAULT   </td><td class="markdownTableBodyNone">0x00004 (bit2)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CY_SYSLIB_RESET_TC_DBGRESET   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_CSV_WCO_LOSS   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_TC_DBGRESET   </td><td class="markdownTableBodyNone">0x00008 (bit3)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CY_SYSLIB_RESET_SOFT   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_SOFT   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_SOFT   </td><td class="markdownTableBodyNone">0x00010 (bit4)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CY_SYSLIB_RESET_SWWDT0   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_SWWDT0   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_SWWDT0   </td><td class="markdownTableBodyNone">0x00020 (bit5)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CY_SYSLIB_RESET_SWWDT1   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_SWWDT1   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_SWWDT1   </td><td class="markdownTableBodyNone">0x00040 (bit6)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CY_SYSLIB_RESET_SWWDT2   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_SWWDT2   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_SWWDT2   </td><td class="markdownTableBodyNone">0x00080 (bit7)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CY_SYSLIB_RESET_SWWDT3   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_SWWDT3   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_SWWDT3   </td><td class="markdownTableBodyNone">0x00100 (bit8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">0x00200 (bit9)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">0x00400 (bit10)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">0x00800 (bit11)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">0x01000 (bit12)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">0x02000 (bit13)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">0x04000 (bit14)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">0x08000 (bit15)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_HFCLK_LOSS   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_XRES   </td><td class="markdownTableBodyNone">0x10000 (bit16)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_HFCLK_ERR   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_BODVDDD   </td><td class="markdownTableBodyNone">0x20000 (bit17)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_BODVDDA   </td><td class="markdownTableBodyNone">0x40000 (bit18)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_BODVCCD   </td><td class="markdownTableBodyNone">0x80000 (bit19)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_OVDVDDD   </td><td class="markdownTableBodyNone">0x100000 (bit20)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_OVDVDDA   </td><td class="markdownTableBodyNone">0x200000 (bit21)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_OVDVCCD   </td><td class="markdownTableBodyNone">0x400000 (bit22)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_OCD_ACT_LINREG   </td><td class="markdownTableBodyNone">0x800000 (bit23)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_OCD_DPSLP_LINREG   </td><td class="markdownTableBodyNone">0x1000000 (bit24)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_OCD_REGHC   </td><td class="markdownTableBodyNone">0x2000000 (bit25)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_PMIC   </td><td class="markdownTableBodyNone">0x4000000 (bit26)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">0x8000000 (bit27)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_PXRES   </td><td class="markdownTableBodyNone">0x10000000 (bit28)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_STRUCT_XRES   </td><td class="markdownTableBodyNone">0x20000000 (bit29)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_PORVDDD   </td><td class="markdownTableBodyNone">0x40000000 (bit30)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CY_SYSLIB_RESET_HIB_WAKEUP   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_HIB_WAKEUP   </td><td class="markdownTableBodyNone">CY_SYSLIB_RESET_HIB_WAKEUP   </td><td class="markdownTableBodyNone">0x80000000 (bit31)   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This not is available for devices having M33SYSCPUSS IP CY_SYSLIB_RESET_CSV_WCO_LOSS, CY_SYSLIB_RESET_HFCLK_LOSS and CY_SYSLIB_RESET_HFCLK_ERR causes of a system reset available only if WCO CSV present in the device. </dd></dl>

</div>
</div>
<a id="gaebb4e952584f0c428f58f7b4dbd3ceff" name="gaebb4e952584f0c428f58f7b4dbd3ceff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebb4e952584f0c428f58f7b4dbd3ceff">&#9670;&nbsp;</a></span>Cy_SysLib_ClearResetReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_ClearResetReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the values of RES_CAUSE_EXTEND, RES_CAUSE and RES_CAUSE2. </p>
<p >Also it clears PWR_HIBERNATE token, which indicates reset event on waking up from HIBERNATE. </p>

</div>
</div>
<a id="gaaea5b87a95001a0b3b2cf128957c58ea" name="gaaea5b87a95001a0b3b2cf128957c58ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaea5b87a95001a0b3b2cf128957c58ea">&#9670;&nbsp;</a></span>Cy_SysLib_GetResetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syslib__section__macros.html#ga05d6029120643ca76b079fdf2fd1ea12">CY_SECTION_INIT_CODECOPY_BEGIN</a> __STATIC_INLINE <a class="el" href="group__group__syslib__enumerated__types.html#ga97d0b049220b931606e2ae2e144994e1">cy_en_syslib_status_t</a> Cy_SysLib_GetResetStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the BACKUP-&gt;RESET bit value. </p>
<p >It is reused by the <a class="el" href="group__group__syslib__functions.html#gadb2c8e123ba3a0376a14871e58230321">Cy_SysLib_ResetBackupDomain</a> itself and also intended to check for CY_SYSLIB_SUCCESS in loop after the <a class="el" href="group__group__syslib__functions.html#gadb2c8e123ba3a0376a14871e58230321">Cy_SysLib_ResetBackupDomain</a> call.</p>
<dl class="section note"><dt>Note</dt><dd>Writing 1 to BACKUP-&gt;RESET resets the backup logic. Hardware clears it when the reset is complete. After setting the register, this function reads the register immediately for returning the result of the backup domain reset state. The reading register is important because the Read itself takes multiple AHB clock cycles, and the reset is actually finishing during that time.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>CY_SYSLIB_SUCCESS, if BACKUP-&gt;RESET read-back is 0. Otherwise returns CY_SYSLIB_INVALID_STATE.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="group__group__syslib__enumerated__types.html#gga97d0b049220b931606e2ae2e144994e1a7d26e21cf3c67f4202b35c3c6bcde534">CY_SYSLIB_SUCCESS</a> != <a class="code hl_function" href="group__group__syslib__functions.html#gadb2c8e123ba3a0376a14871e58230321">Cy_SysLib_ResetBackupDomain</a>())</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_function" href="group__group__syslib__functions.html#ga9d2ffe4829c636ad78eaae5043fd6ae6">Cy_SysLib_DelayUs</a>(1U); <span class="comment">/* 1 us delay should be enough */</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="group__group__syslib__enumerated__types.html#gga97d0b049220b931606e2ae2e144994e1a7d26e21cf3c67f4202b35c3c6bcde534">CY_SYSLIB_SUCCESS</a> != <a class="code hl_function" href="group__group__syslib__functions.html#gaaea5b87a95001a0b3b2cf128957c58ea">Cy_SysLib_GetResetStatus</a>())</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* Reset bit is not cleared too long - check the CLK_BAK */</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga4515de2210eb1371c804f3199ac48a4b" name="ga4515de2210eb1371c804f3199ac48a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4515de2210eb1371c804f3199ac48a4b">&#9670;&nbsp;</a></span>Cy_SysLib_FaultHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syslib__section__macros.html#ga10926a1e1ebe0e4c7b2024a80cf93266">CY_SECTION_INIT_CODECOPY_END</a> void Cy_SysLib_FaultHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t const *&#160;</td>
          <td class="paramname"><em>faultStackAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stores the ARM Cortex registers into a non-zero init area for debugging. </p>
<p >This function calls <a class="el" href="group__group__syslib__functions.html#ga0852597c5a10b76413a7063711043fef" title="This function determines how to process the current fault state.">Cy_SysLib_ProcessingFault()</a> after storing all information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faultStackAddr</td><td>The address of the stack pointer, indicates the lowest address in the fault stack frame to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function stores the fault stack frame only for the first occurred fault. </dd>
<dd>
The PDL doesn't provide an API to analyze the stored register values. The user has to add additional functions for the analysis, if necessary. </dd>
<dd>
The CY_ARM_FAULT_DEBUG macro defines if the Fault Handler is enabled. By default it is set to CY_ARM_FAULT_DEBUG_ENABLED and enables the Fault Handler. If there is a necessity to save memory or have some specific custom handler, etc. then CY_ARM_FAULT_DEBUG should be redefined as CY_ARM_FAULT_DEBUG_DISABLED. To do this, the following definition should be added to the compiler Command Line (through the project Build Settings): "-D CY_ARM_FAULT_DEBUG=0". </dd></dl>

</div>
</div>
<a id="ga0852597c5a10b76413a7063711043fef" name="ga0852597c5a10b76413a7063711043fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0852597c5a10b76413a7063711043fef">&#9670;&nbsp;</a></span>Cy_SysLib_ProcessingFault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_ProcessingFault </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function determines how to process the current fault state. </p>
<p >By default in case of exception the system will stay in the infinite loop of this function.</p>
<dl class="section note"><dt>Note</dt><dd>This function has the WEAK option, so the user can redefine the function behavior for a custom processing. For example, the function redefinition could be constructed from fault stack processing and NVIC_SystemReset() function call. </dd></dl>

</div>
</div>
<a id="ga8b897f8554957f9393f645d5ab1106c9" name="ga8b897f8554957f9393f645d5ab1106c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b897f8554957f9393f645d5ab1106c9">&#9670;&nbsp;</a></span>Cy_SysLib_SetWaitStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_SetWaitStates </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ulpMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkHfMHz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of clock cycles the cache will wait for, before it samples data coming back from ROM, SRAM, and Flash. </p>
<p >Call this function before increasing the HFClk0 High Frequency clock. Call this function optionally after lowering the HFClk0 High Frequency clock in order to improve the CPU performance.</p>
<p >Also, call this function before switching the core supply regulator voltage (LDO or SIMO Buck) from 1.1V to 0.9V. Call this function optionally after switching the core supply regulator voltage from 0.9V to 1.1V in order to improve the CPU performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulpMode</td><td>The device power mode. true if the device should be switched to the ULP mode (nominal voltage of the core supply regulator should be switched to 0.9V); false if the device should be switched to the LP mode (nominal voltage of the core supply regulator should be switched to 1.1V).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Refer to the device TRM for the low power modes description.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkHfMHz</td><td>The HFClk0 clock frequency in MHz. Specifying a frequency above the supported maximum will set the wait states as for the maximum frequency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Delay functions have no effect if called from non-secure code. The CPU frequency cannot be changed in non-secure code. </dd></dl>

</div>
</div>
<a id="gae679f15a1702c159c105b596a8801105" name="gae679f15a1702c159c105b596a8801105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae679f15a1702c159c105b596a8801105">&#9670;&nbsp;</a></span>Cy_SysLib_EnterCriticalSection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SysLib_EnterCriticalSection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cy_SysLib_EnterCriticalSection disables interrupts and returns a value indicating whether the interrupts were previously enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current interrupt status. Returns 0 if the interrupts were previously enabled or 1 if the interrupts were previously disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Implementation of Cy_SysLib_EnterCriticalSection manipulates the IRQ enable bit with interrupts still enabled. </dd></dl>

</div>
</div>
<a id="ga8c16343c075610b2888b0693f972b555" name="ga8c16343c075610b2888b0693f972b555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c16343c075610b2888b0693f972b555">&#9670;&nbsp;</a></span>Cy_SysLib_ExitCriticalSection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_ExitCriticalSection </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>savedIntrStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-enables the interrupts if they were enabled before <a class="el" href="group__group__syslib__functions.html#gae679f15a1702c159c105b596a8801105" title="Cy_SysLib_EnterCriticalSection disables interrupts and returns a value indicating whether the interru...">Cy_SysLib_EnterCriticalSection()</a> was called. </p>
<p >The argument should be the value returned from <a class="el" href="group__group__syslib__functions.html#gae679f15a1702c159c105b596a8801105">Cy_SysLib_EnterCriticalSection()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">savedIntrStatus</td><td>Puts the saved interrupts status returned by the <a class="el" href="group__group__syslib__functions.html#gae679f15a1702c159c105b596a8801105">Cy_SysLib_EnterCriticalSection()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaebb3c0de07c70f0a39aa07a4ebb72f64" name="gaebb3c0de07c70f0a39aa07a4ebb72f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebb3c0de07c70f0a39aa07a4ebb72f64">&#9670;&nbsp;</a></span>Cy_SysLib_GetDeviceRevision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Cy_SysLib_GetDeviceRevision </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a device Revision ID. </p>
<dl class="section return"><dt>Returns</dt><dd>A device Revision ID. </dd></dl>

</div>
</div>
<a id="ga31851d85af687fef11473fa11145030d" name="ga31851d85af687fef11473fa11145030d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31851d85af687fef11473fa11145030d">&#9670;&nbsp;</a></span>Cy_SysLib_GetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_SysLib_GetDevice </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a device Family ID. </p>
<dl class="section return"><dt>Returns</dt><dd>A device Family ID. </dd></dl>

</div>
</div>
<a id="ga8e96d4a4aed60c9d7e8c186951147c95" name="ga8e96d4a4aed60c9d7e8c186951147c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e96d4a4aed60c9d7e8c186951147c95">&#9670;&nbsp;</a></span>Cy_SysLib_GetDeviceLCS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syslib__enumerated__types.html#ga3ff462c7740be4b6a2c2d9fbe4282666">cy_en_syslib_lcs_mode_t</a> Cy_SysLib_GetDeviceLCS </td>
          <td>(</td>
          <td class="paramtype">cy_syslib_lcs_data_t *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns LCS of Device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SRSS instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__syslib__enumerated__types.html#ga3ff462c7740be4b6a2c2d9fbe4282666">cy_en_syslib_lcs_mode_t</a> </dd></dl>

</div>
</div>
<a id="gabc2fac2da2d735bedac2a57d45d53fac" name="gabc2fac2da2d735bedac2a57d45d53fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc2fac2da2d735bedac2a57d45d53fac">&#9670;&nbsp;</a></span>Cy_Syslib_SetWarmBootEntryPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Syslib_SetWarmBootEntryPoint </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>entryPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set Warm boot entry point address to a location read by BootROM. </p>
<p >This function is used only before entering DeepSleep-RAM and not effective in any other sleep mode. Before entering CY_SYSPM_MODE_DEEPSLEEP_RAM, user needs to set entry point to a function located in RAM Image using <a class="el" href="group__group__syslib__functions.html#gabc2fac2da2d735bedac2a57d45d53fac" title="This function will set Warm boot entry point address to a location read by BootROM.">Cy_Syslib_SetWarmBootEntryPoint()</a>, refer Cy_SysPm_SetDeepSleepMode().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryPoint</td><td>Address of the function that needs to be entered after WARM boot.</td></tr>
    <tr><td class="paramname">enable</td><td>Enables/Disables debugging control after DS-RAM wakeup i.e. warmboot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3ef05b9419cbb446a501f4a49e233aa" name="gaf3ef05b9419cbb446a501f4a49e233aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3ef05b9419cbb446a501f4a49e233aa">&#9670;&nbsp;</a></span>Cy_SysLib_IsDSRAMWarmBootEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_SysLib_IsDSRAMWarmBootEntry </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will return true if the system woke up(From DS-RAM) through Warm boot, else it will return false. </p>
<dl class="section return"><dt>Returns</dt><dd>Warm Boot Status. </dd></dl>

</div>
</div>
<a id="gafdb346d0131659f401e2b9d83ea6864d" name="gafdb346d0131659f401e2b9d83ea6864d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdb346d0131659f401e2b9d83ea6864d">&#9670;&nbsp;</a></span>Cy_Syslib_IsMemCacheable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_Syslib_IsMemCacheable </td>
          <td>(</td>
          <td class="paramtype">MPU_Type *&#160;</td>
          <td class="paramname"><em>mpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the memory address and the size passed falls in the non-cacheable region or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpu</td><td>Address of the MPU</td></tr>
    <tr><td class="paramname">addr</td><td>Address of the memory to be checked</td></tr>
    <tr><td class="paramname">size</td><td>Size of the memory to be checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CM55 core devices. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSOC E8XXGP Device Support Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
