<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB IPC Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB IPC Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__mtb__ipc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">IPC (Inter-Processor Communication)</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p >High level interface for communicating between processors on a multi-core device. </p>
<p >The IPC driver allows communication between multiple CPUs or between multiple tasks operating in different domains within a single CPU. It supports binary semaphores and message queues, similar to how they are used for task interactions in an RTOS envrionment.</p>
<h1><a class="anchor" id="subsection_ipc_features"></a>
Features</h1>
<ul>
<li>Binary semaphore for resource access control and general signalling</li>
<li>Message queue for passing data between tasks/cores</li>
</ul>
<h1><a class="anchor" id="subsection_ipc_quickstart"></a>
Quick Start</h1>
<p >To initialize the driver, call the mtb_ipc_init on the first task/CPU to boot and mtb_ipc_get_handle on other cores. Please see your device documentation to determine which core to start on. This will setup shared memory and the binary semaphore for protecting internal functionality.</p>
<p >For binary semaphores, only one task/CPU may initialize ( <a class="el" href="group__group__mtb__ipc.html#ga7cbd4b22b37f18652261e53968f58ee2">mtb_ipc_semaphore_init</a>) a semaphore. Other tasks/CPUs then get the handle ( <a class="el" href="group__group__mtb__ipc.html#ga476248a02c68c28cff1e1f415fceeb45">mtb_ipc_semaphore_get_handle</a>) of the created semaphore. Then take/give the semaphore ( <a class="el" href="group__group__mtb__ipc.html#ga273cbe763a2f50e58712ee504f566f77">mtb_ipc_semaphore_take</a>/ <a class="el" href="group__group__mtb__ipc.html#ga1dcfa4819231cb57d9398372f49ea092">mtb_ipc_semaphore_give</a>).</p>
<p >For queues, only one task/CPU may initialize ( <a class="el" href="group__group__mtb__ipc.html#gac65005ec5b28a2b7508b39b8a6faaa4a">mtb_ipc_queue_init</a>) a queue. Other tasks/CPUs then get the handle ( <a class="el" href="group__group__mtb__ipc.html#ga36701ae9978a74403d61c3d737773089">mtb_ipc_queue_get_handle</a>) of the created queue. Use the get/put functions to take out or put in items to the queue ( <a class="el" href="group__group__mtb__ipc.html#ga6269a2c17929ecd877fa6195ffe784d5">mtb_ipc_queue_put</a>, <a class="el" href="group__group__mtb__ipc.html#gaf5ce4240f876b0d08de09afcadb26396">mtb_ipc_queue_get</a>).</p>
<h1><a class="anchor" id="section_impl_ipc_semaphore_idx_valid_range"></a>
Valid range for IPC semaphore number</h1>
<p >mtb_ipc_semaphore_init function semaphore_num parameter valid range is from 0 to (including) CY_IPC_SEMA_COUNT - 2</p>
<h1><a class="anchor" id="section_impl_ipc_shared_data_objects"></a>
section_impl_ipc_shared_data_objects</h1>
<p >For all IPC library constructs, some data must be put in the shared memory regions so that all cores can access. This must satisfy a few requirements:</p><ul>
<li>Memory should be accessible from all cores (e.g. CY_SECTION_SHAREDMEM macro can be used)</li>
<li>If used with a core where Data Cache is enabled, memory should be aligned to __SCB_DCACHE_LINE_SIZE The following sections outline the different data types and their requirements. </li>
</ul>
<h2><a class="anchor" id="section_impl_ipc_shared_data_"></a>
Shared data memory allocation</h2>
<p >Shared data memory allocation can be done with help of MTB_IPC_SHARED_DATA_ALLOC macro, but using it is not mandatory, so user can allocate memory for the shared memory in any convenient for them way. This struct is necessary to store and keep track of all shared objects during operation. </p>
<h2><a class="anchor" id="section_impl_ipc_semaphore_data"></a>
Semaphore data memory allocation</h2>
<p >semaphore data memory allocation can be done with help of MTB_IPC_SEMAPHORE_DATA_ALLOC macro, but using it is not mandatory, so user can allocate memory for the semaphore data in any convenient for them way as long as such allocation satisfies next parameters:</p><ul>
<li>Memory should be able to store <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__data__t" title="IPC Semaphore Data User should allocate but not modify anything in this struct.">mtb_ipc_semaphore_data_t</a> type struct</li>
<li>Each initialized semaphore must have its own semaphore data object. These cannot be shared between semaphores </li>
</ul>
<h2><a class="anchor" id="section_impl_ipc_mbox_data"></a>
Mailbox data memory allocation</h2>
<p >Mailbox data memory allocation can be done with help of MTB_IPC_MBOX_DATA_ALLOC macro, but using it is not mandatory, so user can allocate memory for the mailbox data in any way convenient for them as long as such allocation satisfies next parameters:</p><ul>
<li>Memory should be able to store <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__mbox__data__t" title="IPC mailbox data element User should allocate but not modify anything in this struct.">mtb_ipc_mbox_data_t</a> type struct</li>
<li>Each initialized mailbox must have its own mailbox data object. These cannot be shared between mailboxes </li>
</ul>
<h2><a class="anchor" id="section_impl_ipc_queue_pool_memory"></a>
Queue pool memory allocation</h2>
<p >Queue pool memory allocation can be done with help of MTB_IPC_QUEUE_POOL_ALLOC macro, but using it is not mandatory, so user can allocate memory for the queue pool in any convenient for them way as long as such allocation satisfies next parameters:</p><ul>
<li>Memory should be able to store NUM_ITEMS x ITEM_SIZE bytes, where NUM_ITEMS - number of max. elements the queue can store, and ITEM_SIZE - size of each queue item in bytes</li>
<li>Each queue must have its own queue pool </li>
</ul>
<h2><a class="anchor" id="section_impl_ipc_queue_data"></a>
Queue data memory allocation</h2>
<p >Queue data memory allocation can be done with help of MTB_IPC_QUEUE_DATA_ALLOC macro, but using it is not mandatory, so user can allocate memory for the queue data in any convenient for them way as long as such allocation satisfies next parameters:</p><ul>
<li>Memory should be able to store <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__data__t" title="IPC queue data element User should allocate but not modify anything in this struct.">mtb_ipc_queue_data_t</a> type struct</li>
<li>Each queue must have its own data object. These cannot be shared between queues.</li>
</ul>
<h1><a class="anchor" id="section_impl_ipc_preemtable_sema"></a>
Preemtable Semaphore parameter</h1>
<p >If preemptable is enabled (true), the user must ensure that there are no deadlocks in the system, which can be caused by an interrupt that occurs after the IPC channel is locked. Unless the user is ready to handle IPC channel locks correctly at the application level, set preemptable to false.</p>
<h1><a class="anchor" id="section_impl_ipc_interrupts_priorities"></a>
IPC interrupts implementation</h1>
<p >In current IPC library implementation, each core has two of its "own" IPC INTR structures, which services all possible IPC library channels. One IRQ structure is for semaphores, and the other for queues.</p>
<h1><a class="anchor" id="section_impl_ipc_operation_isr"></a>
IPC operations in ISR context</h1>
<p >Callbacks may execute in an ISR context, so IPC queue put/get operations cannot be performed in callbacks with a timeout != 0 Such operations will result in <a class="el" href="group__group__ipc__results.html#ga5296dbca77985f861981b88acdf12ee2">MTB_IPC_RSLT_ERR_CANT_OPERATE_IN_ISR_W_TIMEOUT</a>. IPC semaphore take/give operations cannot be performed in ISR context with a timeout != 0. Such operations will result in <a class="el" href="group__group__ipc__results.html#ga5296dbca77985f861981b88acdf12ee2">MTB_IPC_RSLT_ERR_CANT_OPERATE_IN_ISR_W_TIMEOUT</a>.</p>
<h1><a class="anchor" id="section_initialization"></a>
IPC initialization</h1>
<p >On some devices (currently, Traveo, XMC72, and PSE84 devices), startup code does not initialize IPC PDL driver semaphores, so it is done by <a class="el" href="group__group__mtb__ipc.html#gab6752bc7a533aa0774ec22bc8f3d2605" title="Initialize IPC library Driver.">mtb_ipc_init()</a>. In general, the init function should be called by the first core to boot. Please see your device datasheet for details. This core will do the initialization and set up a pointer using an IPC channel so that all Cores can read and use the same variables. if it has not already been done on that core. The corresponding mtb_ipc_get_handle will be used on other cores to receive this data.</p>
<h1><a class="anchor" id="section_impl_ipc_get_handle_before_init"></a>
Calling *_get_handle APIs before _init APIs</h1>
<p >Calling <a class="el" href="group__group__mtb__ipc.html#ga476248a02c68c28cff1e1f415fceeb45" title="Finds an already initialized semaphore based on a given number.">mtb_ipc_semaphore_get_handle()</a> before <a class="el" href="group__group__mtb__ipc.html#ga7cbd4b22b37f18652261e53968f58ee2" title="Creates a single semaphore based on a given number.">mtb_ipc_semaphore_init()</a> will result in <a class="el" href="group__group__ipc__results.html#ga48ed9546fb0f11b927e3c6c28db91f1c">MTB_IPC_RSLT_ERR_NO_SEMA_AVAILABLE</a>. The correct way of using <a class="el" href="group__group__mtb__ipc.html#ga476248a02c68c28cff1e1f415fceeb45" title="Finds an already initialized semaphore based on a given number.">mtb_ipc_semaphore_get_handle()</a> is to call <a class="el" href="group__group__mtb__ipc.html#ga7cbd4b22b37f18652261e53968f58ee2" title="Creates a single semaphore based on a given number.">mtb_ipc_semaphore_init()</a> before using <a class="el" href="group__group__mtb__ipc.html#ga476248a02c68c28cff1e1f415fceeb45" title="Finds an already initialized semaphore based on a given number.">mtb_ipc_semaphore_get_handle()</a>, and pass the same semaphore number that was used for the initialization. Semaphores can be initialized on any core and accessed from any core.</p>
<p >Calling <a class="el" href="group__group__mtb__ipc.html#ga36701ae9978a74403d61c3d737773089" title="Gets a handle pointer for a given IPC channel and queue number.">mtb_ipc_queue_get_handle()</a> before <a class="el" href="group__group__mtb__ipc.html#gac65005ec5b28a2b7508b39b8a6faaa4a" title="Creates a new queue for a given IPC channel based on the given queue number and other parameters.">mtb_ipc_queue_init()</a> will result in <a class="el" href="group__group__ipc__results.html#gab0ea96cb479a704e207ca43bc013a7cd">MTB_IPC_RSLT_ERR_QUEUE_NOT_FOUND</a>. The correct way of using <a class="el" href="group__group__mtb__ipc.html#ga36701ae9978a74403d61c3d737773089" title="Gets a handle pointer for a given IPC channel and queue number.">mtb_ipc_queue_get_handle()</a> is to call <a class="el" href="group__group__mtb__ipc.html#gac65005ec5b28a2b7508b39b8a6faaa4a" title="Creates a new queue for a given IPC channel based on the given queue number and other parameters.">mtb_ipc_queue_init()</a> before using <a class="el" href="group__group__mtb__ipc.html#ga36701ae9978a74403d61c3d737773089" title="Gets a handle pointer for a given IPC channel and queue number.">mtb_ipc_queue_get_handle()</a>, and pass the same channel and queue number that was used for the queue initialization. Queues can be initialized on any core and accessed from any core.</p>
<p >Calling <a class="el" href="group__group__mtb__ipc.html#ga52e2b0cf072835e833763c0395b4b48f">mtb_ipc_mbox_sender_get_handle()</a> before <a class="el" href="group__group__mtb__ipc.html#ga77a2cf0e944ad38772fda02f21f78b85">mtb_ipc_mbox_receiver_init()</a> will result in <a class="el" href="group__group__ipc__results.html#ga45804f18afc7a9b5f326e9faab8357e3">MTB_IPC_RSLT_ERR_MBOX_NOT_FOUND</a>. The correct way of using <a class="el" href="group__group__mtb__ipc.html#ga52e2b0cf072835e833763c0395b4b48f">mtb_ipc_mbox_sender_get_handle()</a> is to call it after <a class="el" href="group__group__mtb__ipc.html#ga77a2cf0e944ad38772fda02f21f78b85">mtb_ipc_mbox_receiver_init()</a> , and pass the same mailbox index that was used for the mailbox initialization. Mailboxes can be initialized on any core and accessed from any core, however initialization must be done on the receiving core for that individual mailbox.</p>
<h1><a class="anchor" id="section_queue_data_protection"></a>
To protect queue data and also ensure minimal possibility</h1>
<p >of deadlocks, any modification of the Queue besides its notifications must be done using the queue's semaphore. To ensure less arbitration in ISR context, notifications are instead protected by the lock on the channel the queue is part of.</p>
<h1><a class="anchor" id="section_ipc_snippets"></a>
Code Snippets</h1>
<h2><a class="anchor" id="subsection_ipc_snippet1"></a>
Snippet 1: Binary semaphore example</h2>
<div class="fragment"><div class="line">    <span class="comment">/* General: error handling is not shown. Use CY_ASSERT(CY_RSLT_SUCCESS == result); to check */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #define SEMAPHORE_NUM 0UL</span></div>
<div class="line"><span class="preprocessor">    #define IPC_SEMAPHORE_NUM 1UL</span></div>
<div class="line"><span class="comment">    /*************************************************************/</span></div>
<div class="line">    <span class="comment">/* Task0 (CPU0) */</span></div>
<div class="line"><span class="comment">    /*************************************************************/</span></div>
<div class="line"> </div>
<div class="line">    cy_rslt_t rslt0;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> obj;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__ipc.html#structmtb__ipc__config__t">mtb_ipc_config_t</a> config1;</div>
<div class="line">    config1.<a class="code hl_variable" href="group__group__mtb__ipc.html#a164ea7bb82718cc0f0085b5cc14582c3">internal_channel_index</a> = <a class="code hl_enumvalue" href="group__group__mtb__impl__ipc.html#gga791dec732a2251c395e8a2a913e70993a6c3119c9f51726a13c1dc2c1c95638d6">MTB_IPC_CHAN_0</a>;</div>
<div class="line">    config1.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa7d299d916bcf161d0e22be480471be7">semaphore_irq</a> = <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a>;</div>
<div class="line">    config1.<a class="code hl_variable" href="group__group__mtb__ipc.html#a35e2b28d983e9debccc99b13192236d9">queue_irq</a> = <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a> + 1UL;</div>
<div class="line">    config1.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa6290f0ea4244e2c9893a831a7ea8607">semaphore_num</a> = IPC_SEMAPHORE_NUM;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a> semaphore0;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__shared__t">mtb_ipc_shared_t</a>* shared;</div>
<div class="line">    <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga20855a0037157872e860a8e129ea362d">MTB_IPC_SHARED_DATA_ALLOC</a>(shared);</div>
<div class="line">    rslt0 = <a class="code hl_function" href="group__group__mtb__ipc.html#gab6752bc7a533aa0774ec22bc8f3d2605">mtb_ipc_init</a>(&amp;obj, shared, &amp;config1);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__data__t">mtb_ipc_semaphore_data_t</a>* semaphore_data0;</div>
<div class="line">    <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga49aea375f838eeb23d2f71420410c442">MTB_IPC_SEMAPHORE_DATA_ALLOC</a>(semaphore_data0);</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__ipc.html#structmtb__ipc__semaphore__config__t">mtb_ipc_semaphore_config_t</a> semaphoreconfig1;</div>
<div class="line">    semaphoreconfig1.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa53f2f3062bbca73310b460f4880be9e">semaphore_num</a> = SEMAPHORE_NUM;</div>
<div class="line">    semaphoreconfig1.<a class="code hl_variable" href="group__group__mtb__ipc.html#a6d348566868f397edc490ff7a94c283c">preemptable</a> = <span class="keyword">false</span>;</div>
<div class="line">    rslt0 = <a class="code hl_function" href="group__group__mtb__ipc.html#ga7cbd4b22b37f18652261e53968f58ee2">mtb_ipc_semaphore_init</a>(&amp;obj, &amp;semaphore0, semaphore_data0, &amp;semaphoreconfig1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; IPC_OPERATIONS_LOOPS; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_function" href="group__group__mtb__ipc.html#ga273cbe763a2f50e58712ee504f566f77">mtb_ipc_semaphore_take</a>(&amp;semaphore0, <a class="code hl_define" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a>) == CY_RSLT_SUCCESS)</div>
<div class="line">        {</div>
<div class="line">            rslt0 = <a class="code hl_function" href="group__group__mtb__ipc.html#ga1dcfa4819231cb57d9398372f49ea092">mtb_ipc_semaphore_give</a>(&amp;semaphore0);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="comment">    /*************************************************************/</span></div>
<div class="line">    <span class="comment">/* Task1 (CPU1) */</span></div>
<div class="line"><span class="comment">    /*************************************************************/</span></div>
<div class="line"> </div>
<div class="line">    cy_rslt_t rslt1;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> obj1;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__ipc.html#structmtb__ipc__config__t">mtb_ipc_config_t</a> config2;</div>
<div class="line">    config2.<a class="code hl_variable" href="group__group__mtb__ipc.html#a164ea7bb82718cc0f0085b5cc14582c3">internal_channel_index</a> = <a class="code hl_enumvalue" href="group__group__mtb__impl__ipc.html#gga791dec732a2251c395e8a2a913e70993a6c3119c9f51726a13c1dc2c1c95638d6">MTB_IPC_CHAN_0</a>;</div>
<div class="line">    config2.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa7d299d916bcf161d0e22be480471be7">semaphore_irq</a> = <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a> + 2UL;</div>
<div class="line">    config2.<a class="code hl_variable" href="group__group__mtb__ipc.html#a35e2b28d983e9debccc99b13192236d9">queue_irq</a> = <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a> + 3UL;</div>
<div class="line">    config2.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa6290f0ea4244e2c9893a831a7ea8607">semaphore_num</a> = IPC_SEMAPHORE_NUM;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a> semaphore1;</div>
<div class="line">    <span class="comment">/* Grab the handle for the initialzied IPC instance*/</span></div>
<div class="line">    <a class="code hl_function" href="group__group__mtb__ipc.html#ga29aa4a2f132e543b4705c4590c9b7fc3">mtb_ipc_get_handle</a>(&amp;obj1, &amp;config2, 100);</div>
<div class="line">    <span class="comment">/* Get the handle for the semaphore created on CPU0 */</span></div>
<div class="line">    rslt1 = <a class="code hl_function" href="group__group__mtb__ipc.html#ga476248a02c68c28cff1e1f415fceeb45">mtb_ipc_semaphore_get_handle</a>(&amp;obj1, &amp;semaphore1, SEMAPHORE_NUM, <a class="code hl_define" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; IPC_OPERATIONS_LOOPS; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_function" href="group__group__mtb__ipc.html#ga273cbe763a2f50e58712ee504f566f77">mtb_ipc_semaphore_take</a>(&amp;semaphore1, <a class="code hl_define" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a>) == CY_RSLT_SUCCESS)</div>
<div class="line">        {</div>
<div class="line">            rslt1 = <a class="code hl_function" href="group__group__mtb__ipc.html#ga1dcfa4819231cb57d9398372f49ea092">mtb_ipc_semaphore_give</a>(&amp;semaphore1);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_ga1fadf74647efce059f473fd625787b17"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a></div><div class="ttdeci">#define MTB_IPC_IRQ_USER</div><div class="ttdoc">Define the first avaliable IRQ for use in MTB IPC.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:219</div></div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_ga20855a0037157872e860a8e129ea362d"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#ga20855a0037157872e860a8e129ea362d">MTB_IPC_SHARED_DATA_ALLOC</a></div><div class="ttdeci">#define MTB_IPC_SHARED_DATA_ALLOC(shared)</div><div class="ttdoc">Macro for Shared data region shared memory allocation.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:291</div></div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_ga49aea375f838eeb23d2f71420410c442"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#ga49aea375f838eeb23d2f71420410c442">MTB_IPC_SEMAPHORE_DATA_ALLOC</a></div><div class="ttdeci">#define MTB_IPC_SEMAPHORE_DATA_ALLOC(semaphore_data)</div><div class="ttdoc">Macro for semaphore data shared memory allocation.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:236</div></div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_gga791dec732a2251c395e8a2a913e70993a6c3119c9f51726a13c1dc2c1c95638d6"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#gga791dec732a2251c395e8a2a913e70993a6c3119c9f51726a13c1dc2c1c95638d6">MTB_IPC_CHAN_0</a></div><div class="ttdeci">@ MTB_IPC_CHAN_0</div><div class="ttdoc">User IPC channel 0.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:151</div></div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_structmtb__ipc__semaphore__data__t"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__data__t">mtb_ipc_semaphore_data_t</a></div><div class="ttdoc">IPC Semaphore Data User should allocate but not modify anything in this struct.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:465</div></div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_structmtb__ipc__semaphore__t"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a></div><div class="ttdoc">IPC Semaphore Handle User should allocate but not modify anything in this struct.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:475</div></div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_structmtb__ipc__shared__t"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#structmtb__ipc__shared__t">mtb_ipc_shared_t</a></div><div class="ttdoc">IPC Shared Memory Object.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:614</div></div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_structmtb__ipc__t"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a></div><div class="ttdoc">IPC Instance object This is the per-core obj for tracking shared memory and initialized queues/semaph...</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:657</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_a164ea7bb82718cc0f0085b5cc14582c3"><div class="ttname"><a href="group__group__mtb__ipc.html#a164ea7bb82718cc0f0085b5cc14582c3">mtb_ipc_config_t::internal_channel_index</a></div><div class="ttdeci">mtb_ipc_channel_t internal_channel_index</div><div class="ttdoc">IPC channel number (e.g.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:394</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_a35e2b28d983e9debccc99b13192236d9"><div class="ttname"><a href="group__group__mtb__ipc.html#a35e2b28d983e9debccc99b13192236d9">mtb_ipc_config_t::queue_irq</a></div><div class="ttdeci">uint32_t queue_irq</div><div class="ttdoc">User Defined IRQ for use on this core for all queues.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:400</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_a6d348566868f397edc490ff7a94c283c"><div class="ttname"><a href="group__group__mtb__ipc.html#a6d348566868f397edc490ff7a94c283c">mtb_ipc_semaphore_config_t::preemptable</a></div><div class="ttdeci">bool preemptable</div><div class="ttdoc">Allows whether the semaphore can be preempted by another task.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:330</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_aa53f2f3062bbca73310b460f4880be9e"><div class="ttname"><a href="group__group__mtb__ipc.html#aa53f2f3062bbca73310b460f4880be9e">mtb_ipc_semaphore_config_t::semaphore_num</a></div><div class="ttdeci">uint32_t semaphore_num</div><div class="ttdoc">The semaphore number to initialize.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:333</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_aa6290f0ea4244e2c9893a831a7ea8607"><div class="ttname"><a href="group__group__mtb__ipc.html#aa6290f0ea4244e2c9893a831a7ea8607">mtb_ipc_config_t::semaphore_num</a></div><div class="ttdeci">uint32_t semaphore_num</div><div class="ttdoc">User defined semaphore number to use for access to shared region and all MTB IPC operations.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:403</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_aa7d299d916bcf161d0e22be480471be7"><div class="ttname"><a href="group__group__mtb__ipc.html#aa7d299d916bcf161d0e22be480471be7">mtb_ipc_config_t::semaphore_irq</a></div><div class="ttdeci">uint32_t semaphore_irq</div><div class="ttdoc">User Defined IRQ for use on this core for all semaphores.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:397</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_ga08f62ac94b3c25ac661e03da5e0203ed"><div class="ttname"><a href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a></div><div class="ttdeci">#define MTB_IPC_NEVER_TIMEOUT</div><div class="ttdoc">This define can be used as timeout argument for the IPC HAL driver functions, that take timeout as in...</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:310</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_ga1dcfa4819231cb57d9398372f49ea092"><div class="ttname"><a href="group__group__mtb__ipc.html#ga1dcfa4819231cb57d9398372f49ea092">mtb_ipc_semaphore_give</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_semaphore_give(const mtb_ipc_semaphore_t *semaphore)</div><div class="ttdoc">Gives/releases a semaphore.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.c:2191</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_ga273cbe763a2f50e58712ee504f566f77"><div class="ttname"><a href="group__group__mtb__ipc.html#ga273cbe763a2f50e58712ee504f566f77">mtb_ipc_semaphore_take</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_semaphore_take(const mtb_ipc_semaphore_t *semaphore, uint64_t timeout_us)</div><div class="ttdoc">Takes/acquires a semaphore.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.c:1812</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_ga29aa4a2f132e543b4705c4590c9b7fc3"><div class="ttname"><a href="group__group__mtb__ipc.html#ga29aa4a2f132e543b4705c4590c9b7fc3">mtb_ipc_get_handle</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_get_handle(mtb_ipc_t *obj, const mtb_ipc_config_t *config, uint64_t timeout_ms)</div><div class="ttdoc">Get initialized IPC library Driver Call before any other IPC library functions.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.c:1490</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_ga476248a02c68c28cff1e1f415fceeb45"><div class="ttname"><a href="group__group__mtb__ipc.html#ga476248a02c68c28cff1e1f415fceeb45">mtb_ipc_semaphore_get_handle</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_semaphore_get_handle(mtb_ipc_t *obj, mtb_ipc_semaphore_t *semaphore, uint32_t semaphore_num, uint64_t timeout_us)</div><div class="ttdoc">Finds an already initialized semaphore based on a given number.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.c:1754</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_ga7cbd4b22b37f18652261e53968f58ee2"><div class="ttname"><a href="group__group__mtb__ipc.html#ga7cbd4b22b37f18652261e53968f58ee2">mtb_ipc_semaphore_init</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_semaphore_init(mtb_ipc_t *obj, mtb_ipc_semaphore_t *semaphore, mtb_ipc_semaphore_data_t *sema_obj, const mtb_ipc_semaphore_config_t *config)</div><div class="ttdoc">Creates a single semaphore based on a given number.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.c:1611</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_gab6752bc7a533aa0774ec22bc8f3d2605"><div class="ttname"><a href="group__group__mtb__ipc.html#gab6752bc7a533aa0774ec22bc8f3d2605">mtb_ipc_init</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_init(mtb_ipc_t *obj, mtb_ipc_shared_t *shared_data, const mtb_ipc_config_t *config)</div><div class="ttdoc">Initialize IPC library Driver.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.c:1373</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_structmtb__ipc__config__t"><div class="ttname"><a href="group__group__mtb__ipc.html#structmtb__ipc__config__t">mtb_ipc_config_t</a></div><div class="ttdoc">IPC object config struct.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:389</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_structmtb__ipc__semaphore__config__t"><div class="ttname"><a href="group__group__mtb__ipc.html#structmtb__ipc__semaphore__config__t">mtb_ipc_semaphore_config_t</a></div><div class="ttdoc">User Config Struct to set up a Semaphore Items to be populated by caller before initialization Semaph...</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:322</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsection_ipc_snippet2"></a>
Snippet 2: Message queue example</h2>
<div class="fragment"><div class="line">    <span class="comment">/* General: error handling is not shown. Use CY_ASSERT(CY_RSLT_SUCCESS == result); to check */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Queue(s) channel(s) must differ from overall IPC channel.</span></div>
<div class="line"><span class="preprocessor">    #define Q_CHANNEL_NUM         MTB_IPC_CHAN_1</span></div>
<div class="line"><span class="preprocessor">    #define QUEUE1_NUM          1UL</span></div>
<div class="line"><span class="preprocessor">    #define QUEUE1_ITEMS        8UL</span></div>
<div class="line"><span class="preprocessor">    #define QUEUE2_NUM          2UL</span></div>
<div class="line"><span class="preprocessor">    #define QUEUE2_ITEMS        1UL</span></div>
<div class="line"><span class="preprocessor">    #define QUEUE2_MSG_LEN_MAX  25UL</span></div>
<div class="line"><span class="preprocessor">    #define IPC_SEMAPHORE_NUM   1UL</span></div>
<div class="line"><span class="comment">    /*************************************************************/</span></div>
<div class="line">    <span class="comment">/* Task0 (CPU0) */</span></div>
<div class="line"><span class="comment">    /*************************************************************/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #define INVALID_SENSOR_DATA 0UL</span></div>
<div class="line"><span class="preprocessor">    #define VALID_SENSOR_DATA   1UL</span></div>
<div class="line"> </div>
<div class="line">    cy_rslt_t rslt0;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> task0_queue1;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> task0_queue2;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> obj;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__ipc.html#structmtb__ipc__config__t">mtb_ipc_config_t</a> config1;</div>
<div class="line">    config1.<a class="code hl_variable" href="group__group__mtb__ipc.html#a164ea7bb82718cc0f0085b5cc14582c3">internal_channel_index</a> = <a class="code hl_enumvalue" href="group__group__mtb__impl__ipc.html#gga791dec732a2251c395e8a2a913e70993a6c3119c9f51726a13c1dc2c1c95638d6">MTB_IPC_CHAN_0</a>;</div>
<div class="line">    config1.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa7d299d916bcf161d0e22be480471be7">semaphore_irq</a> = <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a>;</div>
<div class="line">    config1.<a class="code hl_variable" href="group__group__mtb__ipc.html#a35e2b28d983e9debccc99b13192236d9">queue_irq</a> = <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a> + 1UL;</div>
<div class="line">    config1.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa6290f0ea4244e2c9893a831a7ea8607">semaphore_num</a> =IPC_SEMAPHORE_NUM;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__shared__t">mtb_ipc_shared_t</a>* shared;</div>
<div class="line">    <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga20855a0037157872e860a8e129ea362d">MTB_IPC_SHARED_DATA_ALLOC</a>(shared);</div>
<div class="line">    rslt0 = <a class="code hl_function" href="group__group__mtb__ipc.html#gab6752bc7a533aa0774ec22bc8f3d2605">mtb_ipc_init</a>(&amp;obj, shared, &amp;config1);</div>
<div class="line"> </div>
<div class="line">    uint32_t task0_sensor = VALID_SENSOR_DATA;</div>
<div class="line">    <span class="keywordtype">char</span>* task0_message = NULL;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Allocating in shared memory char array, that will store message from task1 */</span></div>
<div class="line">    CY_SECTION_SHAREDMEM <span class="keyword">static</span> <span class="keywordtype">char</span> task1_message[QUEUE2_MSG_LEN_MAX];</div>
<div class="line">    <span class="keywordtype">char</span>* task1_message_ptr = task1_message;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Defining and allocating (shared) memory pools for queue1 and queue2 */</span></div>
<div class="line">    <span class="keywordtype">void</span>* queue1_pool, * queue2_pool;</div>
<div class="line">    <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga82db85425839482443f455a7a7cec48f">MTB_IPC_QUEUE_POOL_ALLOC</a>(queue1_pool, QUEUE1_ITEMS, <span class="keyword">sizeof</span>(task0_sensor));</div>
<div class="line">    <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga82db85425839482443f455a7a7cec48f">MTB_IPC_QUEUE_POOL_ALLOC</a>(queue2_pool, QUEUE2_ITEMS, <span class="keyword">sizeof</span>(task0_message));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Defining and allocating (shared) memory for queue handles */</span></div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__data__t">mtb_ipc_queue_data_t</a>* queue1_obj, * queue2_obj;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__ipc.html#structmtb__ipc__queue__config__t">mtb_ipc_queue_config_t</a> queueconfig1, queueconfig2;</div>
<div class="line">    <a class="code hl_define" href="group__group__mtb__impl__ipc.html#gaac8ccfa76cd59a07320b3788cb95f073">MTB_IPC_QUEUE_DATA_ALLOC</a>(queue1_obj);</div>
<div class="line">    <a class="code hl_define" href="group__group__mtb__impl__ipc.html#gaac8ccfa76cd59a07320b3788cb95f073">MTB_IPC_QUEUE_DATA_ALLOC</a>(queue2_obj);</div>
<div class="line"> </div>
<div class="line">    queueconfig1.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa24e02827376878e29ddec00dc34b34d">channel_num</a> = Q_CHANNEL_NUM;</div>
<div class="line">    queueconfig1.<a class="code hl_variable" href="group__group__mtb__ipc.html#a444bffef27a47784119f0b653c12e076">queue_num</a> = QUEUE1_NUM;</div>
<div class="line">    queueconfig1.<a class="code hl_variable" href="group__group__mtb__ipc.html#adbd56c721841b0104cf6fb302c717627">queue_pool</a> = queue1_pool;</div>
<div class="line">    queueconfig1.<a class="code hl_variable" href="group__group__mtb__ipc.html#aefae081fd929e96a6f339098e6c67de3">max_num_items</a> = QUEUE1_ITEMS;</div>
<div class="line">    queueconfig1.<a class="code hl_variable" href="group__group__mtb__ipc.html#a34005034cb251a9c15adfbf134e1e021">item_size</a> = <span class="keyword">sizeof</span>(task0_sensor);</div>
<div class="line">    queueconfig1.<a class="code hl_variable" href="group__group__mtb__ipc.html#a1cb175b3754a44a41eae83bb47355041">semaphore_num</a> = 2UL;</div>
<div class="line"> </div>
<div class="line">    queueconfig2.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa24e02827376878e29ddec00dc34b34d">channel_num</a> = Q_CHANNEL_NUM;</div>
<div class="line">    queueconfig2.<a class="code hl_variable" href="group__group__mtb__ipc.html#a444bffef27a47784119f0b653c12e076">queue_num</a> = QUEUE2_NUM;</div>
<div class="line">    queueconfig2.<a class="code hl_variable" href="group__group__mtb__ipc.html#adbd56c721841b0104cf6fb302c717627">queue_pool</a> = queue2_pool;</div>
<div class="line">    queueconfig2.<a class="code hl_variable" href="group__group__mtb__ipc.html#aefae081fd929e96a6f339098e6c67de3">max_num_items</a> = QUEUE2_ITEMS;</div>
<div class="line">    queueconfig2.<a class="code hl_variable" href="group__group__mtb__ipc.html#a34005034cb251a9c15adfbf134e1e021">item_size</a> = <span class="keyword">sizeof</span>(task0_message);</div>
<div class="line">    queueconfig2.<a class="code hl_variable" href="group__group__mtb__ipc.html#a1cb175b3754a44a41eae83bb47355041">semaphore_num</a> = 3UL;</div>
<div class="line"> </div>
<div class="line">    rslt0 = <a class="code hl_function" href="group__group__mtb__ipc.html#gac65005ec5b28a2b7508b39b8a6faaa4a">mtb_ipc_queue_init</a>(&amp;obj, &amp;task0_queue1, queue1_obj, &amp;queueconfig1);</div>
<div class="line">    rslt0 = <a class="code hl_function" href="group__group__mtb__ipc.html#gac65005ec5b28a2b7508b39b8a6faaa4a">mtb_ipc_queue_init</a>(&amp;obj, &amp;task0_queue2, queue2_obj, &amp;queueconfig2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; IPC_OPERATIONS_LOOPS; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (task0_sensor != INVALID_SENSOR_DATA)</div>
<div class="line">        {</div>
<div class="line">            rslt0 = <a class="code hl_function" href="group__group__mtb__ipc.html#ga6269a2c17929ecd877fa6195ffe784d5">mtb_ipc_queue_put</a>(&amp;task0_queue1, &amp;task0_sensor, <a class="code hl_define" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">while</span> (!<a class="code hl_function" href="group__group__mtb__ipc.html#gac00c8da1498346e2fbdaf365d7029f80">mtb_ipc_queue_count</a>(&amp;task0_queue2))</div>
<div class="line">        {</div>
<div class="line">            Cy_SysLib_Delay(1);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_function" href="group__group__mtb__ipc.html#gaf5ce4240f876b0d08de09afcadb26396">mtb_ipc_queue_get</a>(&amp;task0_queue2, &amp;task0_message,</div>
<div class="line">                              <a class="code hl_define" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a>) == CY_RSLT_SUCCESS)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (task0_message != NULL)</div>
<div class="line">            {</div>
<div class="line">                task0_message = NULL;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="comment">    /*************************************************************/</span></div>
<div class="line">    <span class="comment">/* Task1 (CPU1) */</span></div>
<div class="line"><span class="comment">    /*************************************************************/</span></div>
<div class="line"> </div>
<div class="line">    cy_rslt_t rslt1;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> task1_queue1;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> task1_queue2;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> obj1;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__ipc.html#structmtb__ipc__config__t">mtb_ipc_config_t</a> config2;</div>
<div class="line">    config2.<a class="code hl_variable" href="group__group__mtb__ipc.html#a164ea7bb82718cc0f0085b5cc14582c3">internal_channel_index</a> = <a class="code hl_enumvalue" href="group__group__mtb__impl__ipc.html#gga791dec732a2251c395e8a2a913e70993a6c3119c9f51726a13c1dc2c1c95638d6">MTB_IPC_CHAN_0</a>;</div>
<div class="line">    config2.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa7d299d916bcf161d0e22be480471be7">semaphore_irq</a> = <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a> + 2UL;</div>
<div class="line">    config2.<a class="code hl_variable" href="group__group__mtb__ipc.html#a35e2b28d983e9debccc99b13192236d9">queue_irq</a> = <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a> + 3UL;</div>
<div class="line">    config2.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa6290f0ea4244e2c9893a831a7ea8607">semaphore_num</a> = IPC_SEMAPHORE_NUM;</div>
<div class="line"> </div>
<div class="line">    rslt0 = <a class="code hl_function" href="group__group__mtb__ipc.html#ga29aa4a2f132e543b4705c4590c9b7fc3">mtb_ipc_get_handle</a>(&amp;obj1, &amp;config2, 100);</div>
<div class="line"> </div>
<div class="line">    uint32_t task1_sensor;</div>
<div class="line"> </div>
<div class="line">    rslt1 = <a class="code hl_function" href="group__group__mtb__ipc.html#ga36701ae9978a74403d61c3d737773089">mtb_ipc_queue_get_handle</a>(&amp;obj1, &amp;task1_queue1, Q_CHANNEL_NUM, QUEUE1_NUM);</div>
<div class="line">    rslt1 = <a class="code hl_function" href="group__group__mtb__ipc.html#ga36701ae9978a74403d61c3d737773089">mtb_ipc_queue_get_handle</a>(&amp;obj1, &amp;task1_queue2, Q_CHANNEL_NUM, QUEUE2_NUM);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; IPC_OPERATIONS_LOOPS; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">while</span> (!<a class="code hl_function" href="group__group__mtb__ipc.html#gac00c8da1498346e2fbdaf365d7029f80">mtb_ipc_queue_count</a>(&amp;task1_queue1))</div>
<div class="line">        {</div>
<div class="line">            Cy_SysLib_Delay(1);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_function" href="group__group__mtb__ipc.html#gaf5ce4240f876b0d08de09afcadb26396">mtb_ipc_queue_get</a>(&amp;task1_queue1, &amp;task1_sensor,</div>
<div class="line">                              <a class="code hl_define" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a>) == CY_RSLT_SUCCESS)</div>
<div class="line">        {</div>
<div class="line">            rslt1 = <a class="code hl_function" href="group__group__mtb__ipc.html#ga6269a2c17929ecd877fa6195ffe784d5">mtb_ipc_queue_put</a>(&amp;task1_queue2, &amp;task1_message_ptr,</div>
<div class="line">                                      <a class="code hl_define" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_ga82db85425839482443f455a7a7cec48f"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#ga82db85425839482443f455a7a7cec48f">MTB_IPC_QUEUE_POOL_ALLOC</a></div><div class="ttdeci">#define MTB_IPC_QUEUE_POOL_ALLOC(queue_pool, NUM_ITEMS, ITEMSIZE)</div><div class="ttdoc">Macro for Queue pool shared memory allocation.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:265</div></div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_gaac8ccfa76cd59a07320b3788cb95f073"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#gaac8ccfa76cd59a07320b3788cb95f073">MTB_IPC_QUEUE_DATA_ALLOC</a></div><div class="ttdeci">#define MTB_IPC_QUEUE_DATA_ALLOC(queue_data)</div><div class="ttdoc">Macro for Queue data shared memory allocation.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:278</div></div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_structmtb__ipc__queue__data__t"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__data__t">mtb_ipc_queue_data_t</a></div><div class="ttdoc">IPC queue data element User should allocate but not modify anything in this struct.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:527</div></div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_structmtb__ipc__queue__t"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a></div><div class="ttdoc">IPC Queue handle object User should allocate but not modify anything in this struct.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:567</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_a1cb175b3754a44a41eae83bb47355041"><div class="ttname"><a href="group__group__mtb__ipc.html#a1cb175b3754a44a41eae83bb47355041">mtb_ipc_queue_config_t::semaphore_num</a></div><div class="ttdeci">uint32_t semaphore_num</div><div class="ttdoc">Semaphore number to use with this queue.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:380</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_a34005034cb251a9c15adfbf134e1e021"><div class="ttname"><a href="group__group__mtb__ipc.html#a34005034cb251a9c15adfbf134e1e021">mtb_ipc_queue_config_t::item_size</a></div><div class="ttdeci">uint32_t item_size</div><div class="ttdoc">Size of each packet (item) in the Queue.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:372</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_a444bffef27a47784119f0b653c12e076"><div class="ttname"><a href="group__group__mtb__ipc.html#a444bffef27a47784119f0b653c12e076">mtb_ipc_queue_config_t::queue_num</a></div><div class="ttdeci">uint32_t queue_num</div><div class="ttdoc">Queue number, which must be unique for each queue in scope of one IPC channel.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:368</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_aa24e02827376878e29ddec00dc34b34d"><div class="ttname"><a href="group__group__mtb__ipc.html#aa24e02827376878e29ddec00dc34b34d">mtb_ipc_queue_config_t::channel_num</a></div><div class="ttdeci">mtb_ipc_channel_t channel_num</div><div class="ttdoc">IPC channel number (e.g.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:366</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_adbd56c721841b0104cf6fb302c717627"><div class="ttname"><a href="group__group__mtb__ipc.html#adbd56c721841b0104cf6fb302c717627">mtb_ipc_queue_config_t::queue_pool</a></div><div class="ttdeci">void * queue_pool</div><div class="ttdoc">Pointer to the queue packets in shared memory.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:378</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_aefae081fd929e96a6f339098e6c67de3"><div class="ttname"><a href="group__group__mtb__ipc.html#aefae081fd929e96a6f339098e6c67de3">mtb_ipc_queue_config_t::max_num_items</a></div><div class="ttdeci">uint32_t max_num_items</div><div class="ttdoc">Maximum number of items (packets) allowed in the queue.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:370</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_ga36701ae9978a74403d61c3d737773089"><div class="ttname"><a href="group__group__mtb__ipc.html#ga36701ae9978a74403d61c3d737773089">mtb_ipc_queue_get_handle</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_queue_get_handle(mtb_ipc_t *obj, mtb_ipc_queue_t *queue, uint32_t channel_num, uint32_t queue_num)</div><div class="ttdoc">Gets a handle pointer for a given IPC channel and queue number.</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_ga6269a2c17929ecd877fa6195ffe784d5"><div class="ttname"><a href="group__group__mtb__ipc.html#ga6269a2c17929ecd877fa6195ffe784d5">mtb_ipc_queue_put</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_queue_put(mtb_ipc_queue_t *queue, void *msg, uint64_t timeout_us)</div><div class="ttdoc">Adds one item to the queue.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.c:2730</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_gac00c8da1498346e2fbdaf365d7029f80"><div class="ttname"><a href="group__group__mtb__ipc.html#gac00c8da1498346e2fbdaf365d7029f80">mtb_ipc_queue_count</a></div><div class="ttdeci">uint32_t mtb_ipc_queue_count(const mtb_ipc_queue_t *queue)</div><div class="ttdoc">Returns how many items are in the queue.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.c:2788</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_gac65005ec5b28a2b7508b39b8a6faaa4a"><div class="ttname"><a href="group__group__mtb__ipc.html#gac65005ec5b28a2b7508b39b8a6faaa4a">mtb_ipc_queue_init</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_queue_init(mtb_ipc_t *obj, mtb_ipc_queue_t *queue, mtb_ipc_queue_data_t *queue_obj, const mtb_ipc_queue_config_t *config)</div><div class="ttdoc">Creates a new queue for a given IPC channel based on the given queue number and other parameters.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.c:2338</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_gaf5ce4240f876b0d08de09afcadb26396"><div class="ttname"><a href="group__group__mtb__ipc.html#gaf5ce4240f876b0d08de09afcadb26396">mtb_ipc_queue_get</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_queue_get(mtb_ipc_queue_t *queue, void *msg, uint64_t timeout_us)</div><div class="ttdoc">Removes one item from the queue.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.c:2759</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_structmtb__ipc__queue__config__t"><div class="ttname"><a href="group__group__mtb__ipc.html#structmtb__ipc__queue__config__t">mtb_ipc_queue_config_t</a></div><div class="ttdoc">User Config Struct to set up a Queue Items to be populated by caller before initialization Combinatio...</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:362</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsection_ipc_snippet3"></a>
Snippet : Message mailbox example</h2>
<div class="fragment"><div class="line">    <span class="comment">/* General: error handling is not shown. Use CY_ASSERT(CY_RSLT_SUCCESS == result); to check */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #define CHANNEL_NUM         MTB_IPC_CHAN_0</span></div>
<div class="line"><span class="preprocessor">    #define MBOX_IDX         1UL</span></div>
<div class="line"><span class="preprocessor">    #define IPC_SEMAPHORE_NUM   1UL</span></div>
<div class="line"><span class="preprocessor">    #define READ_SEMAPHORE_NUM   2UL</span></div>
<div class="line"><span class="preprocessor">    #define WRITE_SEMAPHORE_NUM   3UL</span></div>
<div class="line"><span class="preprocessor">    #define MESSAGES_TO_SEND    5</span></div>
<div class="line"><span class="comment">    /*************************************************************/</span></div>
<div class="line">    <span class="comment">/* Receiver (CPU0) */</span></div>
<div class="line"><span class="comment">    /*************************************************************/</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    cy_rslt_t rslt0;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__mbox__t">mtb_ipc_mbox_receiver_t</a> receiver;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> obj;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__ipc.html#structmtb__ipc__config__t">mtb_ipc_config_t</a> config1;</div>
<div class="line">    config1.<a class="code hl_variable" href="group__group__mtb__ipc.html#a164ea7bb82718cc0f0085b5cc14582c3">internal_channel_index</a> = <a class="code hl_enumvalue" href="group__group__mtb__impl__ipc.html#gga791dec732a2251c395e8a2a913e70993a6c3119c9f51726a13c1dc2c1c95638d6">MTB_IPC_CHAN_0</a>;</div>
<div class="line">    config1.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa7d299d916bcf161d0e22be480471be7">semaphore_irq</a> = <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a>;</div>
<div class="line">    config1.<a class="code hl_variable" href="group__group__mtb__ipc.html#a35e2b28d983e9debccc99b13192236d9">queue_irq</a> = <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a> + 1UL;</div>
<div class="line">    config1.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa6290f0ea4244e2c9893a831a7ea8607">semaphore_num</a> =IPC_SEMAPHORE_NUM;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__shared__t">mtb_ipc_shared_t</a>* shared;</div>
<div class="line">    <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga20855a0037157872e860a8e129ea362d">MTB_IPC_SHARED_DATA_ALLOC</a>(shared);</div>
<div class="line">    rslt0 = <a class="code hl_function" href="group__group__mtb__ipc.html#gab6752bc7a533aa0774ec22bc8f3d2605">mtb_ipc_init</a>(&amp;obj, shared, &amp;config1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Example packet</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> priority;</div>
<div class="line">        <span class="keywordtype">char</span>* op_code;</div>
<div class="line">    } packet;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__mbox__data__t">mtb_ipc_mbox_data_t</a>* mbox_data;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__ipc.html#structmtb__ipc__mbox__config__t">mtb_ipc_mbox_config_t</a> mbox_cfg;</div>
<div class="line">    <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga62857121b80bd6cc53438b013cbfaf78">MTB_IPC_MBOX_DATA_ALLOC</a>(mbox_data);</div>
<div class="line"> </div>
<div class="line">    mbox_cfg.<a class="code hl_variable" href="group__group__mtb__ipc.html#aaf8fdad9891ee0685c8b16e45e33246c">write_semaphore_num</a> = READ_SEMAPHORE_NUM;</div>
<div class="line">    mbox_cfg.<a class="code hl_variable" href="group__group__mtb__ipc.html#afbb9a97b62d7bdc147cb7bff9ef79996">read_semaphore_num</a> = WRITE_SEMAPHORE_NUM;</div>
<div class="line">    mbox_cfg.<a class="code hl_variable" href="group__group__mtb__ipc.html#a2bdca6a92ab3168d392a1b8d7fcce827">mailbox_idx</a> = MBOX_IDX;</div>
<div class="line"> </div>
<div class="line">    rslt0 = <a class="code hl_function" href="group__group__mtb__ipc.html#ga77a2cf0e944ad38772fda02f21f78b85">mtb_ipc_mbox_receiver_init</a>(&amp;obj, &amp;receiver, mbox_data, &amp;mbox_cfg);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; MESSAGES_TO_SEND; ++i)</div>
<div class="line">    {</div>
<div class="line">        packet* received_packet = NULL;</div>
<div class="line">        rslt0 =</div>
<div class="line">            <a class="code hl_function" href="group__group__mtb__ipc.html#ga8b3da334b3d0f08a6b95907fd6e35723">mtb_ipc_mbox_receiver_get</a>(&amp;receiver, (<span class="keywordtype">void</span>**)&amp;received_packet, <a class="code hl_define" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a>);</div>
<div class="line">        <span class="keywordflow">if</span> (received_packet != NULL)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//Do something</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="comment">    /*************************************************************/</span></div>
<div class="line">    <span class="comment">/* Sender (CPU1) */</span></div>
<div class="line"><span class="comment">    /*************************************************************/</span></div>
<div class="line"> </div>
<div class="line">    cy_rslt_t rslt1;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> obj1;</div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__ipc.html#structmtb__ipc__config__t">mtb_ipc_config_t</a> config2;</div>
<div class="line">    config2.<a class="code hl_variable" href="group__group__mtb__ipc.html#a164ea7bb82718cc0f0085b5cc14582c3">internal_channel_index</a> = <a class="code hl_enumvalue" href="group__group__mtb__impl__ipc.html#gga791dec732a2251c395e8a2a913e70993a6c3119c9f51726a13c1dc2c1c95638d6">MTB_IPC_CHAN_0</a>;</div>
<div class="line">    config2.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa7d299d916bcf161d0e22be480471be7">semaphore_irq</a> = <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a> + 2UL;</div>
<div class="line">    config2.<a class="code hl_variable" href="group__group__mtb__ipc.html#a35e2b28d983e9debccc99b13192236d9">queue_irq</a> = <a class="code hl_define" href="group__group__mtb__impl__ipc.html#ga1fadf74647efce059f473fd625787b17">MTB_IPC_IRQ_USER</a> + 3UL;</div>
<div class="line">    config2.<a class="code hl_variable" href="group__group__mtb__ipc.html#aa6290f0ea4244e2c9893a831a7ea8607">semaphore_num</a> = IPC_SEMAPHORE_NUM;</div>
<div class="line"> </div>
<div class="line">    rslt0 = <a class="code hl_function" href="group__group__mtb__ipc.html#ga29aa4a2f132e543b4705c4590c9b7fc3">mtb_ipc_get_handle</a>(&amp;obj1, &amp;config2, 100);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="group__group__mtb__impl__ipc.html#structmtb__ipc__mbox__t">mtb_ipc_mbox_sender_t</a> sender;</div>
<div class="line">    <span class="comment">/* Messages should be in shared memory using CY_SECTION_SHAREDMEM*/</span></div>
<div class="line">    packet task_message_arr[MESSAGES_TO_SEND];</div>
<div class="line"> </div>
<div class="line">    rslt1 = <a class="code hl_function" href="group__group__mtb__ipc.html#ga52e2b0cf072835e833763c0395b4b48f">mtb_ipc_mbox_sender_get_handle</a>(&amp;obj1, &amp;sender, MBOX_IDX);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; MESSAGES_TO_SEND; ++i)</div>
<div class="line">    {</div>
<div class="line">        rslt1 = <a class="code hl_function" href="group__group__mtb__ipc.html#gabc947c4789ad6bd42604ee86ff34cd9e">mtb_ipc_mbox_sender_put</a>(&amp;sender, &amp;task_message_arr[i], <a class="code hl_define" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_ga62857121b80bd6cc53438b013cbfaf78"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#ga62857121b80bd6cc53438b013cbfaf78">MTB_IPC_MBOX_DATA_ALLOC</a></div><div class="ttdeci">#define MTB_IPC_MBOX_DATA_ALLOC(mailbox_data)</div><div class="ttdoc">Macro for mailbox data shared memory allocation.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:251</div></div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_structmtb__ipc__mbox__data__t"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#structmtb__ipc__mbox__data__t">mtb_ipc_mbox_data_t</a></div><div class="ttdoc">IPC mailbox data element User should allocate but not modify anything in this struct.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:486</div></div>
<div class="ttc" id="agroup__group__mtb__impl__ipc_html_structmtb__ipc__mbox__t"><div class="ttname"><a href="group__group__mtb__impl__ipc.html#structmtb__ipc__mbox__t">mtb_ipc_mbox_t</a></div><div class="ttdoc">IPC mailbox handle element User should allocate but not modify anything in this struct.</div><div class="ttdef"><b>Definition:</b> mtb_ipc_impl.h:499</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_a2bdca6a92ab3168d392a1b8d7fcce827"><div class="ttname"><a href="group__group__mtb__ipc.html#a2bdca6a92ab3168d392a1b8d7fcce827">mtb_ipc_mbox_config_t::mailbox_idx</a></div><div class="ttdeci">uint32_t mailbox_idx</div><div class="ttdoc">The index of the mailbox.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:347</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_aaf8fdad9891ee0685c8b16e45e33246c"><div class="ttname"><a href="group__group__mtb__ipc.html#aaf8fdad9891ee0685c8b16e45e33246c">mtb_ipc_mbox_config_t::write_semaphore_num</a></div><div class="ttdeci">uint32_t write_semaphore_num</div><div class="ttdoc">The semaphore number to use for guarding writes.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:353</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_afbb9a97b62d7bdc147cb7bff9ef79996"><div class="ttname"><a href="group__group__mtb__ipc.html#afbb9a97b62d7bdc147cb7bff9ef79996">mtb_ipc_mbox_config_t::read_semaphore_num</a></div><div class="ttdeci">uint32_t read_semaphore_num</div><div class="ttdoc">The semaphore number to use for guarding reads.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:350</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_ga52e2b0cf072835e833763c0395b4b48f"><div class="ttname"><a href="group__group__mtb__ipc.html#ga52e2b0cf072835e833763c0395b4b48f">mtb_ipc_mbox_sender_get_handle</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_mbox_sender_get_handle(mtb_ipc_t *obj, mtb_ipc_mbox_sender_t *sender, uint32_t mbox_idx)</div><div class="ttdoc">Gets a handle pointer for a given mailbox index.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.c:3002</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_ga77a2cf0e944ad38772fda02f21f78b85"><div class="ttname"><a href="group__group__mtb__ipc.html#ga77a2cf0e944ad38772fda02f21f78b85">mtb_ipc_mbox_receiver_init</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_mbox_receiver_init(mtb_ipc_t *obj, mtb_ipc_mbox_receiver_t *receiver, mtb_ipc_mbox_data_t *mbox_obj, const mtb_ipc_mbox_config_t *config)</div><div class="ttdoc">Creates a single mailbox based on a given number.</div><div class="ttdef"><b>Definition:</b> mtb_ipc.c:2892</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_ga8b3da334b3d0f08a6b95907fd6e35723"><div class="ttname"><a href="group__group__mtb__ipc.html#ga8b3da334b3d0f08a6b95907fd6e35723">mtb_ipc_mbox_receiver_get</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_mbox_receiver_get(mtb_ipc_mbox_receiver_t *receiver, void **payload, uint64_t timeout_us)</div><div class="ttdoc">Removes one item from the mailbox.</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_gabc947c4789ad6bd42604ee86ff34cd9e"><div class="ttname"><a href="group__group__mtb__ipc.html#gabc947c4789ad6bd42604ee86ff34cd9e">mtb_ipc_mbox_sender_put</a></div><div class="ttdeci">cy_rslt_t mtb_ipc_mbox_sender_put(mtb_ipc_mbox_sender_t *sender, void *payload, uint64_t timeout_us)</div><div class="ttdoc">Adds item to the mailbox.</div></div>
<div class="ttc" id="agroup__group__mtb__ipc_html_structmtb__ipc__mbox__config__t"><div class="ttname"><a href="group__group__mtb__ipc.html#structmtb__ipc__mbox__config__t">mtb_ipc_mbox_config_t</a></div><div class="ttdoc">User Config Struct to set up a Mailbox Items to be populated by caller before initialization Read/Wri...</div><div class="ttdef"><b>Definition:</b> mtb_ipc.h:344</div></div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__ipc__results"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__results.html">IPC Results</a></td></tr>
<tr class="memdesc:group__group__ipc__results"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPC specific return codes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__mtb__impl__ipc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__impl__ipc.html">IPC</a></td></tr>
<tr class="memdesc:group__group__mtb__impl__ipc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation specific interface for using the IPC library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structmtb__ipc__semaphore__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__semaphore__config__t">mtb_ipc_semaphore_config_t</a></td></tr>
<tr class="memdesc:structmtb__ipc__semaphore__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">User Config Struct to set up a Semaphore Items to be populated by caller before initialization Semaphore number defines a specific semaphore and should be less than _MTB_IPC_SEMA_COUNT.  <a href="group__group__mtb__ipc.html#structmtb__ipc__semaphore__config__t">More...</a><br /></td></tr>
<tr class="separator:structmtb__ipc__semaphore__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structmtb__ipc__mbox__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__mbox__config__t">mtb_ipc_mbox_config_t</a></td></tr>
<tr class="memdesc:structmtb__ipc__mbox__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">User Config Struct to set up a Mailbox Items to be populated by caller before initialization Read/Write Semaphore number defines a specific semaphore and should be less than _MTB_IPC_SEMA_COUNT.  <a href="group__group__mtb__ipc.html#structmtb__ipc__mbox__config__t">More...</a><br /></td></tr>
<tr class="separator:structmtb__ipc__mbox__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structmtb__ipc__queue__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__queue__config__t">mtb_ipc_queue_config_t</a></td></tr>
<tr class="memdesc:structmtb__ipc__queue__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">User Config Struct to set up a Queue Items to be populated by caller before initialization Combination of channel_num and queue_num uniquely defines a specific Queue.  <a href="group__group__mtb__ipc.html#structmtb__ipc__queue__config__t">More...</a><br /></td></tr>
<tr class="separator:structmtb__ipc__queue__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structmtb__ipc__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__config__t">mtb_ipc_config_t</a></td></tr>
<tr class="memdesc:structmtb__ipc__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPC object config struct.  <a href="group__group__mtb__ipc.html#structmtb__ipc__config__t">More...</a><br /></td></tr>
<tr class="separator:structmtb__ipc__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga07b24cd64544a704d42ee9018c328ec4"><td class="memItemLeft" align="right" valign="top"><a id="ga07b24cd64544a704d42ee9018c328ec4" name="ga07b24cd64544a704d42ee9018c328ec4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_IPC_QUEUE_ALL_EVENTS</b>&#160;&#160;&#160;    ( <a class="el" href="group__group__mtb__ipc.html#ggaa3205ac185f28b5b3936ed9f11bd4bb0a2377df6650449c51a53aa3abf9b6da11">MTB_IPC_QUEUE_WRITE</a> | <a class="el" href="group__group__mtb__ipc.html#ggaa3205ac185f28b5b3936ed9f11bd4bb0a3660702f6f01fd218d20249409f67ff9">MTB_IPC_QUEUE_READ</a> | <a class="el" href="group__group__mtb__ipc.html#ggaa3205ac185f28b5b3936ed9f11bd4bb0a156bbb899338a86f5498228a5984be9e">MTB_IPC_QUEUE_FULL</a> | <a class="el" href="group__group__mtb__ipc.html#ggaa3205ac185f28b5b3936ed9f11bd4bb0af1a9f1e2a2a71b43dc695dc6fc963202">MTB_IPC_QUEUE_EMPTY</a> | <a class="el" href="group__group__mtb__ipc.html#ggaa3205ac185f28b5b3936ed9f11bd4bb0aa44b0a57a39d58bd675cb1e9f9267f9f">MTB_IPC_QUEUE_RESET</a> )</td></tr>
<tr class="memdesc:ga07b24cd64544a704d42ee9018c328ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregate of all the Queue events. <br /></td></tr>
<tr class="separator:ga07b24cd64544a704d42ee9018c328ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08f62ac94b3c25ac661e03da5e0203ed"><td class="memItemLeft" align="right" valign="top"><a id="ga08f62ac94b3c25ac661e03da5e0203ed" name="ga08f62ac94b3c25ac661e03da5e0203ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_IPC_NEVER_TIMEOUT</b>&#160;&#160;&#160;(0xFFFFFFFFFFFFFFFFUL)</td></tr>
<tr class="memdesc:ga08f62ac94b3c25ac661e03da5e0203ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This define can be used as timeout argument for the IPC HAL driver functions, that take timeout as input parameter, in order to make function never time out (wait forever) <br /></td></tr>
<tr class="separator:ga08f62ac94b3c25ac661e03da5e0203ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1f6aa8fd9de548360a7d529c9ec203d"><td class="memItemLeft" align="right" valign="top"><a id="gac1f6aa8fd9de548360a7d529c9ec203d" name="gac1f6aa8fd9de548360a7d529c9ec203d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_IPC_NEVER_TIMEOUT_MS</b>&#160;&#160;&#160;(0xFFFFFFFFUL)</td></tr>
<tr class="memdesc:gac1f6aa8fd9de548360a7d529c9ec203d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This define can be used as timeout argument for the IPC driver functions, that take timeout as input parameter, in order to make function never time out (wait forever) in functions that take ms an an argument. <br /></td></tr>
<tr class="separator:gac1f6aa8fd9de548360a7d529c9ec203d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab4ff4e18815fa70e9faa6415eb70d2f4"><td class="memItemLeft" align="right" valign="top"><a id="gab4ff4e18815fa70e9faa6415eb70d2f4" name="gab4ff4e18815fa70e9faa6415eb70d2f4"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mtb_ipc_queue_event_callback_t</b>) (void *callback_arg, <a class="el" href="group__group__mtb__ipc.html#gaa3205ac185f28b5b3936ed9f11bd4bb0">mtb_ipc_queue_event_t</a> event)</td></tr>
<tr class="memdesc:gab4ff4e18815fa70e9faa6415eb70d2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue Event handler for IPC interrupts. <br /></td></tr>
<tr class="separator:gab4ff4e18815fa70e9faa6415eb70d2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ba9704f1475ca16a479816f96be37c6"><td class="memItemLeft" align="right" valign="top"><a id="ga8ba9704f1475ca16a479816f96be37c6" name="ga8ba9704f1475ca16a479816f96be37c6"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mtb_ipc_mbox_event_callback_t</b>) (void *callback_arg, <a class="el" href="group__group__mtb__ipc.html#ga2d232d3e42b46cce1d39c0551a01a449">mtb_ipc_mbox_event_t</a> event)</td></tr>
<tr class="memdesc:ga8ba9704f1475ca16a479816f96be37c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback handler for IPC mailbox interrupts. <br /></td></tr>
<tr class="separator:ga8ba9704f1475ca16a479816f96be37c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2d232d3e42b46cce1d39c0551a01a449"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga2d232d3e42b46cce1d39c0551a01a449">mtb_ipc_mbox_event_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__mtb__ipc.html#gga2d232d3e42b46cce1d39c0551a01a449a884930d86ccab4a6ec74a120667fffac">MTB_IPC_MBOX_FULL</a> = 1 &lt;&lt; 0UL
, <br />
&#160;&#160;<a class="el" href="group__group__mtb__ipc.html#gga2d232d3e42b46cce1d39c0551a01a449a6c07728414bbfbc25c8177ee416bae64">MTB_IPC_MBOX_EMPTY</a> = 1 &lt;&lt; 1UL
<br />
 }</td></tr>
<tr class="memdesc:ga2d232d3e42b46cce1d39c0551a01a449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags enum of IPC Mailbox events.  <a href="group__group__mtb__ipc.html#ga2d232d3e42b46cce1d39c0551a01a449">More...</a><br /></td></tr>
<tr class="separator:ga2d232d3e42b46cce1d39c0551a01a449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3205ac185f28b5b3936ed9f11bd4bb0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#gaa3205ac185f28b5b3936ed9f11bd4bb0">mtb_ipc_queue_event_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__mtb__ipc.html#ggaa3205ac185f28b5b3936ed9f11bd4bb0af6afc578f9b0b2e6fa52d1967a709c1a">MTB_IPC_NO_INTR</a> = 0UL
, <br />
&#160;&#160;<a class="el" href="group__group__mtb__ipc.html#ggaa3205ac185f28b5b3936ed9f11bd4bb0a2377df6650449c51a53aa3abf9b6da11">MTB_IPC_QUEUE_WRITE</a> = 1 &lt;&lt; 0UL
, <br />
&#160;&#160;<a class="el" href="group__group__mtb__ipc.html#ggaa3205ac185f28b5b3936ed9f11bd4bb0a3660702f6f01fd218d20249409f67ff9">MTB_IPC_QUEUE_READ</a> = 1 &lt;&lt; 1UL
, <br />
&#160;&#160;<a class="el" href="group__group__mtb__ipc.html#ggaa3205ac185f28b5b3936ed9f11bd4bb0a156bbb899338a86f5498228a5984be9e">MTB_IPC_QUEUE_FULL</a> = 1 &lt;&lt; 2UL
, <br />
&#160;&#160;<a class="el" href="group__group__mtb__ipc.html#ggaa3205ac185f28b5b3936ed9f11bd4bb0af1a9f1e2a2a71b43dc695dc6fc963202">MTB_IPC_QUEUE_EMPTY</a> = 1 &lt;&lt; 3UL
, <br />
&#160;&#160;<a class="el" href="group__group__mtb__ipc.html#ggaa3205ac185f28b5b3936ed9f11bd4bb0aa44b0a57a39d58bd675cb1e9f9267f9f">MTB_IPC_QUEUE_RESET</a> = 1 &lt;&lt; 4UL
<br />
 }</td></tr>
<tr class="memdesc:gaa3205ac185f28b5b3936ed9f11bd4bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags enum of IPC events.  <a href="group__group__mtb__ipc.html#gaa3205ac185f28b5b3936ed9f11bd4bb0">More...</a><br /></td></tr>
<tr class="separator:gaa3205ac185f28b5b3936ed9f11bd4bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab6752bc7a533aa0774ec22bc8f3d2605"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#gab6752bc7a533aa0774ec22bc8f3d2605">mtb_ipc_init</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *obj, <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__shared__t">mtb_ipc_shared_t</a> *shared_data, const <a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__config__t">mtb_ipc_config_t</a> *config)</td></tr>
<tr class="memdesc:gab6752bc7a533aa0774ec22bc8f3d2605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize IPC library Driver.  <a href="group__group__mtb__ipc.html#gab6752bc7a533aa0774ec22bc8f3d2605">More...</a><br /></td></tr>
<tr class="separator:gab6752bc7a533aa0774ec22bc8f3d2605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55fca3612efde484f80f783b88ae3ccb"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga55fca3612efde484f80f783b88ae3ccb">mtb_ipc_reinit_hw</a> (const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *obj)</td></tr>
<tr class="memdesc:ga55fca3612efde484f80f783b88ae3ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize IPC Hardware.  <a href="group__group__mtb__ipc.html#ga55fca3612efde484f80f783b88ae3ccb">More...</a><br /></td></tr>
<tr class="separator:ga55fca3612efde484f80f783b88ae3ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29aa4a2f132e543b4705c4590c9b7fc3"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga29aa4a2f132e543b4705c4590c9b7fc3">mtb_ipc_get_handle</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *obj, const <a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__config__t">mtb_ipc_config_t</a> *config, uint64_t timeout_ms)</td></tr>
<tr class="memdesc:ga29aa4a2f132e543b4705c4590c9b7fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get initialized IPC library Driver Call before any other IPC library functions.  <a href="group__group__mtb__ipc.html#ga29aa4a2f132e543b4705c4590c9b7fc3">More...</a><br /></td></tr>
<tr class="separator:ga29aa4a2f132e543b4705c4590c9b7fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadca43ec5007c8d780174fb09b466712"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#gaadca43ec5007c8d780174fb09b466712">mtb_ipc_semaphore_process_interrupt</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *obj)</td></tr>
<tr class="memdesc:gaadca43ec5007c8d780174fb09b466712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process IPC library interrupt for Semaphores Place inside an ISR registered for the semaphore interrupt specified for this core during init.  <a href="group__group__mtb__ipc.html#gaadca43ec5007c8d780174fb09b466712">More...</a><br /></td></tr>
<tr class="separator:gaadca43ec5007c8d780174fb09b466712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc108dfd3703887e160d2b136f1e164f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#gabc108dfd3703887e160d2b136f1e164f">mtb_ipc_queue_process_interrupt</a> (const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *obj)</td></tr>
<tr class="memdesc:gabc108dfd3703887e160d2b136f1e164f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process IPC library interrupt for Queues Place inside an ISR registered for the queue interrupt specified for this core during init.  <a href="group__group__mtb__ipc.html#gabc108dfd3703887e160d2b136f1e164f">More...</a><br /></td></tr>
<tr class="separator:gabc108dfd3703887e160d2b136f1e164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cbd4b22b37f18652261e53968f58ee2"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga7cbd4b22b37f18652261e53968f58ee2">mtb_ipc_semaphore_init</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *obj, <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a> *semaphore, <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__data__t">mtb_ipc_semaphore_data_t</a> *sema_obj, const <a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__semaphore__config__t">mtb_ipc_semaphore_config_t</a> *config)</td></tr>
<tr class="memdesc:ga7cbd4b22b37f18652261e53968f58ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single semaphore based on a given number.  <a href="group__group__mtb__ipc.html#ga7cbd4b22b37f18652261e53968f58ee2">More...</a><br /></td></tr>
<tr class="separator:ga7cbd4b22b37f18652261e53968f58ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476248a02c68c28cff1e1f415fceeb45"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga476248a02c68c28cff1e1f415fceeb45">mtb_ipc_semaphore_get_handle</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *obj, <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a> *semaphore, uint32_t semaphore_num, uint64_t timeout_us)</td></tr>
<tr class="memdesc:ga476248a02c68c28cff1e1f415fceeb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an already initialized semaphore based on a given number.  <a href="group__group__mtb__ipc.html#ga476248a02c68c28cff1e1f415fceeb45">More...</a><br /></td></tr>
<tr class="separator:ga476248a02c68c28cff1e1f415fceeb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bdd0893b4680ac367735862a6bdba35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga0bdd0893b4680ac367735862a6bdba35">mtb_ipc_semaphore_free</a> (const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a> *semaphore)</td></tr>
<tr class="memdesc:ga0bdd0893b4680ac367735862a6bdba35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the IPC semaphore.  <a href="group__group__mtb__ipc.html#ga0bdd0893b4680ac367735862a6bdba35">More...</a><br /></td></tr>
<tr class="separator:ga0bdd0893b4680ac367735862a6bdba35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga273cbe763a2f50e58712ee504f566f77"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga273cbe763a2f50e58712ee504f566f77">mtb_ipc_semaphore_take</a> (const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a> *semaphore, uint64_t timeout_us)</td></tr>
<tr class="memdesc:ga273cbe763a2f50e58712ee504f566f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes/acquires a semaphore.  <a href="group__group__mtb__ipc.html#ga273cbe763a2f50e58712ee504f566f77">More...</a><br /></td></tr>
<tr class="separator:ga273cbe763a2f50e58712ee504f566f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dcfa4819231cb57d9398372f49ea092"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga1dcfa4819231cb57d9398372f49ea092">mtb_ipc_semaphore_give</a> (const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a> *semaphore)</td></tr>
<tr class="memdesc:ga1dcfa4819231cb57d9398372f49ea092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives/releases a semaphore.  <a href="group__group__mtb__ipc.html#ga1dcfa4819231cb57d9398372f49ea092">More...</a><br /></td></tr>
<tr class="separator:ga1dcfa4819231cb57d9398372f49ea092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac65005ec5b28a2b7508b39b8a6faaa4a"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#gac65005ec5b28a2b7508b39b8a6faaa4a">mtb_ipc_queue_init</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *obj, <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *queue, <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__data__t">mtb_ipc_queue_data_t</a> *queue_obj, const <a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__queue__config__t">mtb_ipc_queue_config_t</a> *config)</td></tr>
<tr class="memdesc:gac65005ec5b28a2b7508b39b8a6faaa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new queue for a given IPC channel based on the given queue number and other parameters.  <a href="group__group__mtb__ipc.html#gac65005ec5b28a2b7508b39b8a6faaa4a">More...</a><br /></td></tr>
<tr class="separator:gac65005ec5b28a2b7508b39b8a6faaa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac307847b7d4386e30e03e12d6a6690ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#gac307847b7d4386e30e03e12d6a6690ca">mtb_ipc_queue_free</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gac307847b7d4386e30e03e12d6a6690ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the queue.  <a href="group__group__mtb__ipc.html#gac307847b7d4386e30e03e12d6a6690ca">More...</a><br /></td></tr>
<tr class="separator:gac307847b7d4386e30e03e12d6a6690ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36701ae9978a74403d61c3d737773089"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga36701ae9978a74403d61c3d737773089">mtb_ipc_queue_get_handle</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *obj, <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *queue, uint32_t channel_num, uint32_t queue_num)</td></tr>
<tr class="memdesc:ga36701ae9978a74403d61c3d737773089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a handle pointer for a given IPC channel and queue number.  <a href="group__group__mtb__ipc.html#ga36701ae9978a74403d61c3d737773089">More...</a><br /></td></tr>
<tr class="separator:ga36701ae9978a74403d61c3d737773089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a5c867af568ef33088b9de2ab003f06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga7a5c867af568ef33088b9de2ab003f06">mtb_ipc_queue_register_callback</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *queue, <a class="el" href="group__group__mtb__ipc.html#gab4ff4e18815fa70e9faa6415eb70d2f4">mtb_ipc_queue_event_callback_t</a> callback, void *callback_arg)</td></tr>
<tr class="memdesc:ga7a5c867af568ef33088b9de2ab003f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback to be executed when certain events occur.  <a href="group__group__mtb__ipc.html#ga7a5c867af568ef33088b9de2ab003f06">More...</a><br /></td></tr>
<tr class="separator:ga7a5c867af568ef33088b9de2ab003f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f82616eaccd59586ffaff76c0978b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga07f82616eaccd59586ffaff76c0978b9">mtb_ipc_queue_enable_event</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *queue, <a class="el" href="group__group__mtb__ipc.html#gaa3205ac185f28b5b3936ed9f11bd4bb0">mtb_ipc_queue_event_t</a> event, bool enable)</td></tr>
<tr class="memdesc:ga07f82616eaccd59586ffaff76c0978b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables which events trigger the callback execution.  <a href="group__group__mtb__ipc.html#ga07f82616eaccd59586ffaff76c0978b9">More...</a><br /></td></tr>
<tr class="separator:ga07f82616eaccd59586ffaff76c0978b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6269a2c17929ecd877fa6195ffe784d5"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga6269a2c17929ecd877fa6195ffe784d5">mtb_ipc_queue_put</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *queue, void *msg, uint64_t timeout_us)</td></tr>
<tr class="memdesc:ga6269a2c17929ecd877fa6195ffe784d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one item to the queue.  <a href="group__group__mtb__ipc.html#ga6269a2c17929ecd877fa6195ffe784d5">More...</a><br /></td></tr>
<tr class="separator:ga6269a2c17929ecd877fa6195ffe784d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ce4240f876b0d08de09afcadb26396"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#gaf5ce4240f876b0d08de09afcadb26396">mtb_ipc_queue_get</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *queue, void *msg, uint64_t timeout_us)</td></tr>
<tr class="memdesc:gaf5ce4240f876b0d08de09afcadb26396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes one item from the queue.  <a href="group__group__mtb__ipc.html#gaf5ce4240f876b0d08de09afcadb26396">More...</a><br /></td></tr>
<tr class="separator:gaf5ce4240f876b0d08de09afcadb26396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac00c8da1498346e2fbdaf365d7029f80"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#gac00c8da1498346e2fbdaf365d7029f80">mtb_ipc_queue_count</a> (const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gac00c8da1498346e2fbdaf365d7029f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many items are in the queue.  <a href="group__group__mtb__ipc.html#gac00c8da1498346e2fbdaf365d7029f80">More...</a><br /></td></tr>
<tr class="separator:gac00c8da1498346e2fbdaf365d7029f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa9549ae6797dcd7114c506960d95bf6"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#gaaa9549ae6797dcd7114c506960d95bf6">mtb_ipc_queue_reset</a> (const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gaaa9549ae6797dcd7114c506960d95bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all the items in the queue.  <a href="group__group__mtb__ipc.html#gaaa9549ae6797dcd7114c506960d95bf6">More...</a><br /></td></tr>
<tr class="separator:gaaa9549ae6797dcd7114c506960d95bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77a2cf0e944ad38772fda02f21f78b85"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga77a2cf0e944ad38772fda02f21f78b85">mtb_ipc_mbox_receiver_init</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *obj, <a class="el" href="group__group__mtb__impl__ipc.html#gab98223c22d617c699c85728236f84617">mtb_ipc_mbox_receiver_t</a> *receiver, <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__mbox__data__t">mtb_ipc_mbox_data_t</a> *mbox_obj, const <a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__mbox__config__t">mtb_ipc_mbox_config_t</a> *config)</td></tr>
<tr class="memdesc:ga77a2cf0e944ad38772fda02f21f78b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single mailbox based on a given number.  <a href="group__group__mtb__ipc.html#ga77a2cf0e944ad38772fda02f21f78b85">More...</a><br /></td></tr>
<tr class="separator:ga77a2cf0e944ad38772fda02f21f78b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52e2b0cf072835e833763c0395b4b48f"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga52e2b0cf072835e833763c0395b4b48f">mtb_ipc_mbox_sender_get_handle</a> (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *obj, <a class="el" href="group__group__mtb__impl__ipc.html#ga40774ba7e9a5960245f9d269d78fcffc">mtb_ipc_mbox_sender_t</a> *sender, uint32_t mbox_idx)</td></tr>
<tr class="memdesc:ga52e2b0cf072835e833763c0395b4b48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a handle pointer for a given mailbox index.  <a href="group__group__mtb__ipc.html#ga52e2b0cf072835e833763c0395b4b48f">More...</a><br /></td></tr>
<tr class="separator:ga52e2b0cf072835e833763c0395b4b48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fa1d0adab6edada3dec74e1ba20719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga30fa1d0adab6edada3dec74e1ba20719">mtb_ipc_mbox_receiver_free</a> (<a class="el" href="group__group__mtb__impl__ipc.html#gab98223c22d617c699c85728236f84617">mtb_ipc_mbox_receiver_t</a> *receiver)</td></tr>
<tr class="memdesc:ga30fa1d0adab6edada3dec74e1ba20719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the mailbox and disconnects the receiver handle.  <a href="group__group__mtb__ipc.html#ga30fa1d0adab6edada3dec74e1ba20719">More...</a><br /></td></tr>
<tr class="separator:ga30fa1d0adab6edada3dec74e1ba20719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ebbf319a4e2eb7fcfe011cc9f7d261c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga6ebbf319a4e2eb7fcfe011cc9f7d261c">mtb_ipc_mbox_sender_free</a> (<a class="el" href="group__group__mtb__impl__ipc.html#ga40774ba7e9a5960245f9d269d78fcffc">mtb_ipc_mbox_sender_t</a> *sender)</td></tr>
<tr class="memdesc:ga6ebbf319a4e2eb7fcfe011cc9f7d261c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects the sender handle from the shared mailbox object.  <a href="group__group__mtb__ipc.html#ga6ebbf319a4e2eb7fcfe011cc9f7d261c">More...</a><br /></td></tr>
<tr class="separator:ga6ebbf319a4e2eb7fcfe011cc9f7d261c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33b413fc3eef39e29635122787064324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga33b413fc3eef39e29635122787064324">mtb_ipc_mbox_receiver_register_callback</a> (<a class="el" href="group__group__mtb__impl__ipc.html#gab98223c22d617c699c85728236f84617">mtb_ipc_mbox_receiver_t</a> *receiver, <a class="el" href="group__group__mtb__ipc.html#ga8ba9704f1475ca16a479816f96be37c6">mtb_ipc_mbox_event_callback_t</a> callback, void *callback_arg)</td></tr>
<tr class="memdesc:ga33b413fc3eef39e29635122787064324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback to be executed on the receiver core when certain events occur.  <a href="group__group__mtb__ipc.html#ga33b413fc3eef39e29635122787064324">More...</a><br /></td></tr>
<tr class="separator:ga33b413fc3eef39e29635122787064324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d2e30f7952410700a53203a57645f8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga9d2e30f7952410700a53203a57645f8e">mtb_ipc_mbox_sender_register_callback</a> (<a class="el" href="group__group__mtb__impl__ipc.html#ga40774ba7e9a5960245f9d269d78fcffc">mtb_ipc_mbox_sender_t</a> *sender, <a class="el" href="group__group__mtb__ipc.html#ga8ba9704f1475ca16a479816f96be37c6">mtb_ipc_mbox_event_callback_t</a> callback, void *callback_arg)</td></tr>
<tr class="memdesc:ga9d2e30f7952410700a53203a57645f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback to be executed on the sender core when certain events occur.  <a href="group__group__mtb__ipc.html#ga9d2e30f7952410700a53203a57645f8e">More...</a><br /></td></tr>
<tr class="separator:ga9d2e30f7952410700a53203a57645f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc947c4789ad6bd42604ee86ff34cd9e"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#gabc947c4789ad6bd42604ee86ff34cd9e">mtb_ipc_mbox_sender_put</a> (<a class="el" href="group__group__mtb__impl__ipc.html#ga40774ba7e9a5960245f9d269d78fcffc">mtb_ipc_mbox_sender_t</a> *sender, void *payload, uint64_t timeout_us)</td></tr>
<tr class="memdesc:gabc947c4789ad6bd42604ee86ff34cd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds item to the mailbox.  <a href="group__group__mtb__ipc.html#gabc947c4789ad6bd42604ee86ff34cd9e">More...</a><br /></td></tr>
<tr class="separator:gabc947c4789ad6bd42604ee86ff34cd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b3da334b3d0f08a6b95907fd6e35723"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga8b3da334b3d0f08a6b95907fd6e35723">mtb_ipc_mbox_receiver_get</a> (<a class="el" href="group__group__mtb__impl__ipc.html#gab98223c22d617c699c85728236f84617">mtb_ipc_mbox_receiver_t</a> *receiver, void **payload, uint64_t timeout_us)</td></tr>
<tr class="memdesc:ga8b3da334b3d0f08a6b95907fd6e35723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes one item from the mailbox.  <a href="group__group__mtb__ipc.html#ga8b3da334b3d0f08a6b95907fd6e35723">More...</a><br /></td></tr>
<tr class="separator:ga8b3da334b3d0f08a6b95907fd6e35723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbc934fbf4c2e854cd665afffa0e9357"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#gabbc934fbf4c2e854cd665afffa0e9357">mtb_ipc_mbox_receiver_enable_event</a> (<a class="el" href="group__group__mtb__impl__ipc.html#gab98223c22d617c699c85728236f84617">mtb_ipc_mbox_receiver_t</a> *receiver, <a class="el" href="group__group__mtb__ipc.html#ga2d232d3e42b46cce1d39c0551a01a449">mtb_ipc_mbox_event_t</a> event, bool enable)</td></tr>
<tr class="memdesc:gabbc934fbf4c2e854cd665afffa0e9357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables which events trigger the callback execution for the receiver.  <a href="group__group__mtb__ipc.html#gabbc934fbf4c2e854cd665afffa0e9357">More...</a><br /></td></tr>
<tr class="separator:gabbc934fbf4c2e854cd665afffa0e9357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d808261b77880d943b092807b3fcbaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mtb__ipc.html#ga2d808261b77880d943b092807b3fcbaa">mtb_ipc_mbox_sender_enable_event</a> (<a class="el" href="group__group__mtb__impl__ipc.html#ga40774ba7e9a5960245f9d269d78fcffc">mtb_ipc_mbox_sender_t</a> *sender, <a class="el" href="group__group__mtb__ipc.html#ga2d232d3e42b46cce1d39c0551a01a449">mtb_ipc_mbox_event_t</a> event, bool enable)</td></tr>
<tr class="memdesc:ga2d808261b77880d943b092807b3fcbaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables which events trigger the callback execution for the sender.  <a href="group__group__mtb__ipc.html#ga2d808261b77880d943b092807b3fcbaa">More...</a><br /></td></tr>
<tr class="separator:ga2d808261b77880d943b092807b3fcbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structmtb__ipc__semaphore__config__t" id="structmtb__ipc__semaphore__config__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structmtb__ipc__semaphore__config__t">&#9670;&nbsp;</a></span>mtb_ipc_semaphore_config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct mtb_ipc_semaphore_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6d348566868f397edc490ff7a94c283c" name="a6d348566868f397edc490ff7a94c283c"></a>bool</td>
<td class="fieldname">
preemptable</td>
<td class="fielddoc">
Allows whether the semaphore can be preempted by another task. <p >If preemptable is enabled (true), the user must ensure that there are no deadlocks in the system, which can be caused by an interrupt that occurs after the IPC channel is locked. Unless the user is ready to handle IPC channel locks correctly at the application level, set preemptable to false. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa53f2f3062bbca73310b460f4880be9e" name="aa53f2f3062bbca73310b460f4880be9e"></a>uint32_t</td>
<td class="fieldname">
semaphore_num</td>
<td class="fielddoc">
The semaphore number to initialize. <p >Please refer to implementation specific documentation for valid range for this parameter. </p>
</td></tr>
</table>

</div>
</div>
<a name="structmtb__ipc__mbox__config__t" id="structmtb__ipc__mbox__config__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structmtb__ipc__mbox__config__t">&#9670;&nbsp;</a></span>mtb_ipc_mbox_config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct mtb_ipc_mbox_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a2bdca6a92ab3168d392a1b8d7fcce827" name="a2bdca6a92ab3168d392a1b8d7fcce827"></a>uint32_t</td>
<td class="fieldname">
mailbox_idx</td>
<td class="fielddoc">
The index of the mailbox. <p >This must be unique as to not clash with other mailboxes. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afbb9a97b62d7bdc147cb7bff9ef79996" name="afbb9a97b62d7bdc147cb7bff9ef79996"></a>uint32_t</td>
<td class="fieldname">
read_semaphore_num</td>
<td class="fielddoc">
The semaphore number to use for guarding reads. <p >The semaphore with this number will be automatically initialized by the mailbox </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aaf8fdad9891ee0685c8b16e45e33246c" name="aaf8fdad9891ee0685c8b16e45e33246c"></a>uint32_t</td>
<td class="fieldname">
write_semaphore_num</td>
<td class="fielddoc">
The semaphore number to use for guarding writes. <p >The semaphore with this number will be automatically initialized by the mailbox. </p>
</td></tr>
</table>

</div>
</div>
<a name="structmtb__ipc__queue__config__t" id="structmtb__ipc__queue__config__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structmtb__ipc__queue__config__t">&#9670;&nbsp;</a></span>mtb_ipc_queue_config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct mtb_ipc_queue_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa24e02827376878e29ddec00dc34b34d" name="aa24e02827376878e29ddec00dc34b34d"></a><a class="el" href="group__group__mtb__impl__ipc.html#ga791dec732a2251c395e8a2a913e70993">mtb_ipc_channel_t</a></td>
<td class="fieldname">
channel_num</td>
<td class="fielddoc">
IPC channel number (e.g. <p >MTB_IPC_CHAN_0) Please refer to implementation specific documentation for number of available IPC channels for particular device. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a444bffef27a47784119f0b653c12e076" name="a444bffef27a47784119f0b653c12e076"></a>uint32_t</td>
<td class="fieldname">
queue_num</td>
<td class="fielddoc">
Queue number, which must be unique for each queue in scope of one IPC channel. </td></tr>
<tr><td class="fieldtype">
<a id="aefae081fd929e96a6f339098e6c67de3" name="aefae081fd929e96a6f339098e6c67de3"></a>uint32_t</td>
<td class="fieldname">
max_num_items</td>
<td class="fielddoc">
Maximum number of items (packets) allowed in the queue. </td></tr>
<tr><td class="fieldtype">
<a id="a34005034cb251a9c15adfbf134e1e021" name="a34005034cb251a9c15adfbf134e1e021"></a>uint32_t</td>
<td class="fieldname">
item_size</td>
<td class="fielddoc">
Size of each packet (item) in the Queue. </td></tr>
<tr><td class="fieldtype">
<a id="adbd56c721841b0104cf6fb302c717627" name="adbd56c721841b0104cf6fb302c717627"></a>void *</td>
<td class="fieldname">
queue_pool</td>
<td class="fielddoc">
Pointer to the queue packets in shared memory. <p >This memory will be cleared by IPC library Queue Initialization. Packet list is an array of packets of max_num_items. It is used as a circular array, first_item is an index to first item stored. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1cb175b3754a44a41eae83bb47355041" name="a1cb175b3754a44a41eae83bb47355041"></a>uint32_t</td>
<td class="fieldname">
semaphore_num</td>
<td class="fielddoc">
Semaphore number to use with this queue. </td></tr>
</table>

</div>
</div>
<a name="structmtb__ipc__config__t" id="structmtb__ipc__config__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structmtb__ipc__config__t">&#9670;&nbsp;</a></span>mtb_ipc_config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct mtb_ipc_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a164ea7bb82718cc0f0085b5cc14582c3" name="a164ea7bb82718cc0f0085b5cc14582c3"></a><a class="el" href="group__group__mtb__impl__ipc.html#ga791dec732a2251c395e8a2a913e70993">mtb_ipc_channel_t</a></td>
<td class="fieldname">
internal_channel_index</td>
<td class="fielddoc">
IPC channel number (e.g. <p >MTB_IPC_CHAN_0) Please refer to implementation specific documentation for number of available IPC channels for particular device. This must match the IPC object initialized on the other core for this core to access the shared memory. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa7d299d916bcf161d0e22be480471be7" name="aa7d299d916bcf161d0e22be480471be7"></a>uint32_t</td>
<td class="fieldname">
semaphore_irq</td>
<td class="fielddoc">
User Defined IRQ for use on this core for all semaphores. <p >A unique IRQ must be used for each core </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a35e2b28d983e9debccc99b13192236d9" name="a35e2b28d983e9debccc99b13192236d9"></a>uint32_t</td>
<td class="fieldname">
queue_irq</td>
<td class="fielddoc">
User Defined IRQ for use on this core for all queues. <p >A unique IRQ must be used for each core </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa6290f0ea4244e2c9893a831a7ea8607" name="aa6290f0ea4244e2c9893a831a7ea8607"></a>uint32_t</td>
<td class="fieldname">
semaphore_num</td>
<td class="fielddoc">
User defined semaphore number to use for access to shared region and all MTB IPC operations. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2d232d3e42b46cce1d39c0551a01a449" name="ga2d232d3e42b46cce1d39c0551a01a449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d232d3e42b46cce1d39c0551a01a449">&#9670;&nbsp;</a></span>mtb_ipc_mbox_event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__mtb__ipc.html#ga2d232d3e42b46cce1d39c0551a01a449">mtb_ipc_mbox_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags enum of IPC Mailbox events. </p>
<p >Multiple events can be enabled via <a class="el" href="group__group__mtb__ipc.html#gabbc934fbf4c2e854cd665afffa0e9357">mtb_ipc_mbox_receiver_enable_event</a> <a class="el" href="group__group__mtb__ipc.html#ga2d808261b77880d943b092807b3fcbaa">mtb_ipc_mbox_sender_enable_event</a> and the callback from <a class="el" href="group__group__mtb__ipc.html#ga33b413fc3eef39e29635122787064324">mtb_ipc_mbox_receiver_register_callback</a> or <a class="el" href="group__group__mtb__ipc.html#ga9d2e30f7952410700a53203a57645f8e">mtb_ipc_mbox_sender_register_callback</a> will be run to notify. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2d232d3e42b46cce1d39c0551a01a449a884930d86ccab4a6ec74a120667fffac" name="gga2d232d3e42b46cce1d39c0551a01a449a884930d86ccab4a6ec74a120667fffac"></a>MTB_IPC_MBOX_FULL&#160;</td><td class="fielddoc"><p >Mailbox is full. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2d232d3e42b46cce1d39c0551a01a449a6c07728414bbfbc25c8177ee416bae64" name="gga2d232d3e42b46cce1d39c0551a01a449a6c07728414bbfbc25c8177ee416bae64"></a>MTB_IPC_MBOX_EMPTY&#160;</td><td class="fielddoc"><p >Mailbox is empty. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa3205ac185f28b5b3936ed9f11bd4bb0" name="gaa3205ac185f28b5b3936ed9f11bd4bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3205ac185f28b5b3936ed9f11bd4bb0">&#9670;&nbsp;</a></span>mtb_ipc_queue_event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__mtb__ipc.html#gaa3205ac185f28b5b3936ed9f11bd4bb0">mtb_ipc_queue_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags enum of IPC events. </p>
<p >Multiple events can be enabled via <a class="el" href="group__group__mtb__ipc.html#ga07f82616eaccd59586ffaff76c0978b9">mtb_ipc_queue_enable_event</a> and the callback from <a class="el" href="group__group__mtb__ipc.html#ga7a5c867af568ef33088b9de2ab003f06">mtb_ipc_queue_register_callback</a> will be run to notify. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa3205ac185f28b5b3936ed9f11bd4bb0af6afc578f9b0b2e6fa52d1967a709c1a" name="ggaa3205ac185f28b5b3936ed9f11bd4bb0af6afc578f9b0b2e6fa52d1967a709c1a"></a>MTB_IPC_NO_INTR&#160;</td><td class="fielddoc"><p >No interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa3205ac185f28b5b3936ed9f11bd4bb0a2377df6650449c51a53aa3abf9b6da11" name="ggaa3205ac185f28b5b3936ed9f11bd4bb0a2377df6650449c51a53aa3abf9b6da11"></a>MTB_IPC_QUEUE_WRITE&#160;</td><td class="fielddoc"><p >New item was written to the queue. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa3205ac185f28b5b3936ed9f11bd4bb0a3660702f6f01fd218d20249409f67ff9" name="ggaa3205ac185f28b5b3936ed9f11bd4bb0a3660702f6f01fd218d20249409f67ff9"></a>MTB_IPC_QUEUE_READ&#160;</td><td class="fielddoc"><p >New item was read from the queue. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa3205ac185f28b5b3936ed9f11bd4bb0a156bbb899338a86f5498228a5984be9e" name="ggaa3205ac185f28b5b3936ed9f11bd4bb0a156bbb899338a86f5498228a5984be9e"></a>MTB_IPC_QUEUE_FULL&#160;</td><td class="fielddoc"><p >Queue is full. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa3205ac185f28b5b3936ed9f11bd4bb0af1a9f1e2a2a71b43dc695dc6fc963202" name="ggaa3205ac185f28b5b3936ed9f11bd4bb0af1a9f1e2a2a71b43dc695dc6fc963202"></a>MTB_IPC_QUEUE_EMPTY&#160;</td><td class="fielddoc"><p >Queue is empty. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa3205ac185f28b5b3936ed9f11bd4bb0aa44b0a57a39d58bd675cb1e9f9267f9f" name="ggaa3205ac185f28b5b3936ed9f11bd4bb0aa44b0a57a39d58bd675cb1e9f9267f9f"></a>MTB_IPC_QUEUE_RESET&#160;</td><td class="fielddoc"><p >Queue was reset. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab6752bc7a533aa0774ec22bc8f3d2605" name="gab6752bc7a533aa0774ec22bc8f3d2605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6752bc7a533aa0774ec22bc8f3d2605">&#9670;&nbsp;</a></span>mtb_ipc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__shared__t">mtb_ipc_shared_t</a> *&#160;</td>
          <td class="paramname"><em>shared_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__config__t">mtb_ipc_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize IPC library Driver. </p>
<p >Call before any other IPC library functions. Must be called before any other core calls mtb_ipc_get_handle. The initialization of the semaphore must be done by the init core on startup or during cybsp_init() as the IPC driver assumes it has already been done. The MTB IPC has no way of ensuring it hasn't been already initialized on the channel, so it is up to user to ensure that init is called once on one core and mtb_ipc_get_handle is called on remaining core(s).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>- Object for the IPC library instance </td></tr>
    <tr><td class="paramname">shared_data</td><td>- pointer to the allocated shared memory object. <a class="el" href="group__group__mtb__impl__ipc.html#ga20855a0037157872e860a8e129ea362d">MTB_IPC_SHARED_DATA_ALLOC</a> macro can (and not mandatory) be used in order to allocate memory for shared data (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__shared__t" title="IPC Shared Memory Object.">mtb_ipc_shared_t</a>) in shared section. </td></tr>
    <tr><td class="paramname">config</td><td>- The user-provided configuration. Fields internal_channel_index, semaphore_irq, queue_irq, semaphore_num are expected to be filled by user before initialization. Please refer to <a class="el" href="group__group__mtb__ipc.html#subsection_ipc_snippet1">Snippet 1: Binary semaphore example</a> for initialization guidance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_TIMEOUT </dd></dl>

</div>
</div>
<a id="ga55fca3612efde484f80f783b88ae3ccb" name="ga55fca3612efde484f80f783b88ae3ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55fca3612efde484f80f783b88ae3ccb">&#9670;&nbsp;</a></span>mtb_ipc_reinit_hw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_reinit_hw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitialize IPC Hardware. </p>
<p >If the underlying IPC hardware is reset (for example, because its containing power domain was powered off and then subsequently powered back on), this function must be called immediately after the IPC hardware is powered back on, before any other IPC operations are performed by any core.</p>
<dl class="section note"><dt>Note</dt><dd>It is only valid to call this function if <code>mtb_ipc_init</code> was previously called. This function may only be called from the core which originally called <code>mtb_ipc_init</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>- Object for the IPC library instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_NOT_INITIALIZED </dd></dl>

</div>
</div>
<a id="ga29aa4a2f132e543b4705c4590c9b7fc3" name="ga29aa4a2f132e543b4705c4590c9b7fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29aa4a2f132e543b4705c4590c9b7fc3">&#9670;&nbsp;</a></span>mtb_ipc_get_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_get_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__config__t">mtb_ipc_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get initialized IPC library Driver Call before any other IPC library functions. </p>
<p >Call from Cores other than that which called mtb_ipc_init to initialize the system, timeout_ms is the timeout for waiting the initializing core to finish initialization. This function initializes the Shared Memory Data structures for IPC library Semaphore and IPC library Queue usage.</p>
<p >IRQ channels provided must be different than those used in <a class="el" href="group__group__mtb__ipc.html#gab6752bc7a533aa0774ec22bc8f3d2605">mtb_ipc_init</a> on the initialization core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>- Object for the IPC library instance </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>- time in milliseconds for non-initializing core to wait for initializing core to complete inititalization </td></tr>
    <tr><td class="paramname">config</td><td>- User provided configuration of the IPC library instance, whose fields internal_ipc_channel, semaphore_num must match config on the core that initialized to ensure compatibility. Please refer to <a class="el" href="group__group__mtb__ipc.html#subsection_ipc_snippet1">Snippet 1: Binary semaphore example</a> for initialization guidance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_TIMEOUT MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_INVALID_IRQ_CHANNEL </dd></dl>

</div>
</div>
<a id="gaadca43ec5007c8d780174fb09b466712" name="gaadca43ec5007c8d780174fb09b466712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadca43ec5007c8d780174fb09b466712">&#9670;&nbsp;</a></span>mtb_ipc_semaphore_process_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtb_ipc_semaphore_process_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process IPC library interrupt for Semaphores Place inside an ISR registered for the semaphore interrupt specified for this core during init. </p>
<p >This function is used to perform interrupt functionality for instantiated semaphore objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>- Object for the IPC library instance</td></tr>
  </table>
  </dd>
</dl>
<p>Process IPC library interrupt for Semaphores Place inside an ISR registered for the semaphore interrupt specified for this core during init.</p>
<p >It iterates through associated RTOS semaphores so it only is looking for relevant semaphores instead of whole linked list. </p>
<p >Set index to unused as the interrupt has signaled it was given</p>

</div>
</div>
<a id="gabc108dfd3703887e160d2b136f1e164f" name="gabc108dfd3703887e160d2b136f1e164f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc108dfd3703887e160d2b136f1e164f">&#9670;&nbsp;</a></span>mtb_ipc_queue_process_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtb_ipc_queue_process_interrupt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process IPC library interrupt for Queues Place inside an ISR registered for the queue interrupt specified for this core during init. </p>
<p >This function is used to perform interrupt functionality for instantiated queue objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>- Object for the IPC library instance</td></tr>
  </table>
  </dd>
</dl>
<p>Process IPC library interrupt for Queues Place inside an ISR registered for the queue interrupt specified for this core during init. </p>
<p >Any modification of a queue's notifs must be done inside a lock on its channel</p>

</div>
</div>
<a id="ga7cbd4b22b37f18652261e53968f58ee2" name="ga7cbd4b22b37f18652261e53968f58ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cbd4b22b37f18652261e53968f58ee2">&#9670;&nbsp;</a></span>mtb_ipc_semaphore_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_semaphore_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__data__t">mtb_ipc_semaphore_data_t</a> *&#160;</td>
          <td class="paramname"><em>sema_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__semaphore__config__t">mtb_ipc_semaphore_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single semaphore based on a given number. </p>
<p >The semaphore number range starts at 0. the max number depends on a few factors max = _MTB_IPC_SEMA_COUNT - 1 (IPC driver semaphore) - num_queues - (num_queues * num_processes_per_queue) </p><dl class="section note"><dt>Note</dt><dd>MTB_IPC_SEMAPHORE_DATA_ALLOC macro can (and not mandatory) be used in order to allocate memory for semaphore data (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__data__t" title="IPC Semaphore Data User should allocate but not modify anything in this struct.">mtb_ipc_semaphore_data_t</a>) in shared section. This function must be called before accessing the semaphore. Only one core must call this function. Other cores call mtb_ipc_semaphore_get_handle to retreive this information after initialization. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">obj</td><td>Pointer to an IPC object. Must be initialized by <a class="el" href="group__group__mtb__ipc.html#gab6752bc7a533aa0774ec22bc8f3d2605">mtb_ipc_init</a> before initializing a semaphore. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">semaphore</td><td>Handle to an IPC semaphore. This handle exists per core and is for api access to the shared sema_obj. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sema_obj</td><td>Semaphore data stored in shared memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The user-provided configuration. Please refer to <a class="el" href="group__group__mtb__ipc.html#subsection_ipc_snippet1">Snippet 1: Binary semaphore example</a> for initialization guidance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_SEMA_NUM_IN_USE MTB_IPC_RSLT_ERR_SEMA_FAIL MTB_IPC_RSLT_ERR_CANT_OPERATE_IN_ISR_W_TIMEOUT MTB_IPC_RSLT_ERR_SEMA_TAKEN </dd></dl>

</div>
</div>
<a id="ga476248a02c68c28cff1e1f415fceeb45" name="ga476248a02c68c28cff1e1f415fceeb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga476248a02c68c28cff1e1f415fceeb45">&#9670;&nbsp;</a></span>mtb_ipc_semaphore_get_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_semaphore_get_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>semaphore_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an already initialized semaphore based on a given number. </p>
<p >This function must be called before accessing the semaphore from a different Core than it was initialized on. mtb_ipc_semaphore_init must be called on the initializing core before this function is called, else it will timeout. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">obj</td><td>Handle to an IPC object pointer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">semaphore</td><td>Handle to an IPC semaphore. This handle exists per core and is for api access to the shared semaphore data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore_num</td><td>The semaphore number to get a pointer for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_us</td><td>Timeout (in uSec) to wait while trying to get the handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_NO_SEMA_AVAILABLE MTB_IPC_RSLT_ERR_CANT_OPERATE_IN_ISR_W_TIMEOUT MTB_IPC_RSLT_ERR_SEMA_TAKEN</dd></dl>
<p>Finds an already initialized semaphore based on a given number. </p>

</div>
</div>
<a id="ga0bdd0893b4680ac367735862a6bdba35" name="ga0bdd0893b4680ac367735862a6bdba35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bdd0893b4680ac367735862a6bdba35">&#9670;&nbsp;</a></span>mtb_ipc_semaphore_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtb_ipc_semaphore_free </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the IPC semaphore. </p>
<p >This function frees the resources associated with the semaphore. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>The semaphore object.</td></tr>
  </table>
  </dd>
</dl>
<p>Frees the IPC semaphore. </p>

</div>
</div>
<a id="ga273cbe763a2f50e58712ee504f566f77" name="ga273cbe763a2f50e58712ee504f566f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga273cbe763a2f50e58712ee504f566f77">&#9670;&nbsp;</a></span>mtb_ipc_semaphore_take()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_semaphore_take </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes/acquires a semaphore. </p>
<p >If the semaphore is available, it is acquired and this function returns. This function has a timeout argument (in microseconds). If the semaphore is not available, it blocks until it times out or succeeds in acquiring it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>The semaphore object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_us</td><td>Timeout in microseconds. Value 0 can be used if no timeout needed while <a class="el" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a> can be used to make function block until semaphore is successfully taken. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_SEMA_TAKEN MTB_IPC_RSLT_ERR_SEMA_FAIL MTB_IPC_RSLT_ERR_CANT_OPERATE_IN_ISR_W_TIMEOUT </dd></dl>

</div>
</div>
<a id="ga1dcfa4819231cb57d9398372f49ea092" name="ga1dcfa4819231cb57d9398372f49ea092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dcfa4819231cb57d9398372f49ea092">&#9670;&nbsp;</a></span>mtb_ipc_semaphore_give()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_semaphore_give </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__semaphore__t">mtb_ipc_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives/releases a semaphore. </p>
<p >The semaphore is released allowing other tasks waiting on the semaphore to take it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>The semaphore object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_SEMA_FAIL MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_CANT_OPERATE_IN_ISR_W_TIMEOUT </dd></dl>

</div>
</div>
<a id="gac65005ec5b28a2b7508b39b8a6faaa4a" name="gac65005ec5b28a2b7508b39b8a6faaa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac65005ec5b28a2b7508b39b8a6faaa4a">&#9670;&nbsp;</a></span>mtb_ipc_queue_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_queue_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__data__t">mtb_ipc_queue_data_t</a> *&#160;</td>
          <td class="paramname"><em>queue_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__queue__config__t">mtb_ipc_queue_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new queue for a given IPC channel based on the given queue number and other parameters. </p>
<p >This function requires <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__data__t">mtb_ipc_queue_data_t</a> (queue_obj) pointer to shared memory. <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__data__t" title="IPC queue data element User should allocate but not modify anything in this struct.">mtb_ipc_queue_data_t</a> is used by other tasks/CPUs to refer to the queue. Note that this function must be called only by one of the tasks/CPUs for the same IPC channel. This CPU can call the function multiple times for the same IPC channel, but with a different queue number. The IPC channel index must be different from the channel index used for <a class="el" href="group__group__mtb__ipc.html#gab6752bc7a533aa0774ec22bc8f3d2605">mtb_ipc_init</a> because that channel is used internally by the semaphores. </p><dl class="section note"><dt>Note</dt><dd>MTB_IPC_QUEUE_DATA_ALLOC and MTB_IPC_QUEUE_POOL_ALLOC macro can (and not mandatory) be used in order to allocate memory for (respectively) queue data (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__data__t" title="IPC queue data element User should allocate but not modify anything in this struct.">mtb_ipc_queue_data_t</a>) and queue pool in shared section. Please refer to implementation specific documentation for the requirements for memory allocation if macro is not used. Please refer to <a class="el" href="group__group__mtb__ipc.html#subsection_ipc_snippet2">Snippet 2: Message queue example</a> for initialization guidance. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">obj</td><td>Pointer to an IPC object. Must be initialized by <a class="el" href="group__group__mtb__ipc.html#gab6752bc7a533aa0774ec22bc8f3d2605">mtb_ipc_init</a> before initializing a queue. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>Queue handle used to reference queue_obj store in shared memory. The queue acts as the per-core handle for the shared data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue_obj</td><td>Queue data object stored in shared memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The user-provided configuration. Please refer to <a class="el" href="group__group__mtb__ipc.html#subsection_ipc_snippet2">Snippet 2: Message queue example</a> for initialization guidance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_SEMA_TAKEN MTB_IPC_RSLT_ERR_SEMA_FAIL MTB_IPC_RSLT_ERR_CANT_OPERATE_IN_ISR_W_TIMEOUT MTB_IPC_RSLT_ERR_QUEUE_NOT_FOUND </dd></dl>

</div>
</div>
<a id="gac307847b7d4386e30e03e12d6a6690ca" name="gac307847b7d4386e30e03e12d6a6690ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac307847b7d4386e30e03e12d6a6690ca">&#9670;&nbsp;</a></span>mtb_ipc_queue_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtb_ipc_queue_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the queue. </p>
<p >This operation only removes the queue handle from the list of available queues. The queue pool and the queue handle allocated in the shared memory need to be freed (if dynamically allocated) by the application. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>Queue handle used to reference queue_obj store in shared memory. The queue acts as the per-core handle for the shared data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36701ae9978a74403d61c3d737773089" name="ga36701ae9978a74403d61c3d737773089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36701ae9978a74403d61c3d737773089">&#9670;&nbsp;</a></span>mtb_ipc_queue_get_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_queue_get_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queue_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a handle pointer for a given IPC channel and queue number. </p>
<p >This function should be called by other tasks/CPUs that have not called the initialization function. Unpredicted behavior can happen if this function is called before <a class="el" href="group__group__mtb__ipc.html#gac65005ec5b28a2b7508b39b8a6faaa4a">mtb_ipc_queue_init</a>. Please refer to implementation specific documentation for additional details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">obj</td><td>The IPC object handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle used to reference queue_obj store in shared memory. The queue acts as the per-core handle for the shared data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_num</td><td>IPC channel to use for the queue messaging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue_num</td><td>Queue number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_SEMA_TAKEN MTB_IPC_RSLT_ERR_SEMA_FAIL MTB_IPC_RSLT_ERR_CANT_OPERATE_IN_ISR_W_TIMEOUT MTB_IPC_RSLT_ERR_QUEUE_NOT_FOUND </dd></dl>

</div>
</div>
<a id="ga7a5c867af568ef33088b9de2ab003f06" name="ga7a5c867af568ef33088b9de2ab003f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a5c867af568ef33088b9de2ab003f06">&#9670;&nbsp;</a></span>mtb_ipc_queue_register_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtb_ipc_queue_register_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__ipc.html#gab4ff4e18815fa70e9faa6415eb70d2f4">mtb_ipc_queue_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback to be executed when certain events occur. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle used to reference queue_obj store in shared memory. The queue acts as the per-core handle for the shared data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback handler which will be invoked when an event triggers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_arg</td><td>Generic argument that will be provided to the callback when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga07f82616eaccd59586ffaff76c0978b9" name="ga07f82616eaccd59586ffaff76c0978b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07f82616eaccd59586ffaff76c0978b9">&#9670;&nbsp;</a></span>mtb_ipc_queue_enable_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtb_ipc_queue_enable_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__ipc.html#gaa3205ac185f28b5b3936ed9f11bd4bb0">mtb_ipc_queue_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables which events trigger the callback execution. </p>
<p >It can trigger when a new item is written to the queue, read from the queue, when the queue becomes full, when the queue becomes empty or when there is a reset. Note that these events might execute callbacks associated to all queues that belong to an IPC channel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle used to reference queue_obj store in shared memory. The queue acts as the per-core handle for the shared data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>The IPC event type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>True to turn on specified events, False to turn off</td></tr>
  </table>
  </dd>
</dl>
<p>Enables which events trigger the callback execution. </p>

</div>
</div>
<a id="ga6269a2c17929ecd877fa6195ffe784d5" name="ga6269a2c17929ecd877fa6195ffe784d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6269a2c17929ecd877fa6195ffe784d5">&#9670;&nbsp;</a></span>mtb_ipc_queue_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_queue_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one item to the queue. </p>
<p >This function can be called by any task/CPU. This function has a timeout argument (in microseconds). If the queue is full, it stays there until it times out or the queue is no longer full. This function can be blocking or non-blocking (timeout set to ZERO). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle used to reference queue_obj store in shared memory. The queue acts as the per-core handle for the shared data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Location of message queue item </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_us</td><td>Timeout in microseconds. Value 0 can be used if no timeout needed while <a class="el" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a> can be used to make function block until element is successfully put into the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_SEMA_TAKEN MTB_IPC_RSLT_ERR_SEMA_FAIL MTB_IPC_RSLT_ERR_CANT_OPERATE_IN_ISR_W_TIMEOUT MTB_IPC_RSLT_ERR_QUEUE_NOT_FOUND MTB_IPC_RSLT_ERR_QUEUE_FULL </dd></dl>

</div>
</div>
<a id="gaf5ce4240f876b0d08de09afcadb26396" name="gaf5ce4240f876b0d08de09afcadb26396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5ce4240f876b0d08de09afcadb26396">&#9670;&nbsp;</a></span>mtb_ipc_queue_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_queue_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes one item from the queue. </p>
<p >This function can be called by any task/CPU. This function has a timeout argument (in microseconds). If the queue is empty, it stays there until it times out or the queue receives a new item. This function can be blocking or non-blocking (timeout set to ZERO). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle used to reference queue_obj store in shared memory. The queue acts as the per-core handle for the shared data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>Location to copy message queue item to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_us</td><td>Timeout in microseconds. Value 0 can be used if no timeout needed while <a class="el" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a> can be used to make function block until element is successfully taken from the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_SEMA_TAKEN MTB_IPC_RSLT_ERR_SEMA_FAIL MTB_IPC_RSLT_ERR_CANT_OPERATE_IN_ISR_W_TIMEOUT MTB_IPC_RSLT_ERR_QUEUE_NOT_FOUND MTB_IPC_RSLT_ERR_QUEUE_EMPTY</dd></dl>
<p>Removes one item from the queue. </p>

</div>
</div>
<a id="gac00c8da1498346e2fbdaf365d7029f80" name="gac00c8da1498346e2fbdaf365d7029f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac00c8da1498346e2fbdaf365d7029f80">&#9670;&nbsp;</a></span>mtb_ipc_queue_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mtb_ipc_queue_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns how many items are in the queue. </p>
<p >This function can be called by any task/CPU. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle used to reference queue_obj store in shared memory. The queue acts as the per-core handle for the shared data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of items in the queue</dd></dl>
<p>Returns how many items are in the queue. </p>

</div>
</div>
<a id="gaaa9549ae6797dcd7114c506960d95bf6" name="gaaa9549ae6797dcd7114c506960d95bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa9549ae6797dcd7114c506960d95bf6">&#9670;&nbsp;</a></span>mtb_ipc_queue_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_queue_reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__queue__t">mtb_ipc_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all the items in the queue. </p>
<p >This function can be called by the any task/CPU. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle used to reference queue_obj store in shared memory. The queue acts as the per-core handle for the shared data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER</dd></dl>
<p>Clears all the items in the queue. </p>

</div>
</div>
<a id="ga77a2cf0e944ad38772fda02f21f78b85" name="ga77a2cf0e944ad38772fda02f21f78b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77a2cf0e944ad38772fda02f21f78b85">&#9670;&nbsp;</a></span>mtb_ipc_mbox_receiver_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_mbox_receiver_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#gab98223c22d617c699c85728236f84617">mtb_ipc_mbox_receiver_t</a> *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__mbox__data__t">mtb_ipc_mbox_data_t</a> *&#160;</td>
          <td class="paramname"><em>mbox_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__mtb__ipc.html#structmtb__ipc__mbox__config__t">mtb_ipc_mbox_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single mailbox based on a given number. </p>
<p >The mailbox number range is 0- <a class="el" href="group__group__mtb__impl__ipc.html#gac0c225a813616672c6ff0587de187d43">MTB_IPC_MAX_MBOXES</a>. </p><dl class="section note"><dt>Note</dt><dd>MTB_IPC_MBOX_DATA_ALLOC macro can (and not mandatory) be used in order to allocate memory for mailbox data (<a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__mbox__data__t" title="IPC mailbox data element User should allocate but not modify anything in this struct.">mtb_ipc_mbox_data_t</a>) in the shared section. This function must be called before accessing the mailbox. Only one core must call this function. Other cores have to call <a class="el" href="group__group__mtb__ipc.html#ga52e2b0cf072835e833763c0395b4b48f">mtb_ipc_mbox_sender_get_handle</a> to retrieve this information after initialization. Do not call this in an interrupt service routine. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>Pointer to an IPC object. Must be initialized by <a class="el" href="group__group__mtb__ipc.html#gab6752bc7a533aa0774ec22bc8f3d2605">mtb_ipc_init</a> before initializing a mailbox. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">receiver</td><td>Handle to the mailbox on the core intended to be the receiver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mbox_obj</td><td>Mailbox data stored in shared memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The user-provided configuration. Please refer to <a class="el" href="group__group__mtb__ipc.html#subsection_ipc_snippet1">Snippet 1: Binary semaphore example</a> for initialization guidance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_SEMA_NUM_IN_USE MTB_IPC_RSLT_ERR_MBOX_IDX_IN_USE MTB_IPC_RSLT_ERR_SEMA_FAIL MTB_IPC_RSLT_ERR_SEMA_TAKEN </dd></dl>

</div>
</div>
<a id="ga52e2b0cf072835e833763c0395b4b48f" name="ga52e2b0cf072835e833763c0395b4b48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52e2b0cf072835e833763c0395b4b48f">&#9670;&nbsp;</a></span>mtb_ipc_mbox_sender_get_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_mbox_sender_get_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#structmtb__ipc__t">mtb_ipc_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#ga40774ba7e9a5960245f9d269d78fcffc">mtb_ipc_mbox_sender_t</a> *&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mbox_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a handle pointer for a given mailbox index. </p>
<p >This function should be called by the core intended to be the mailbox sender. Unpredicted behavior can happen if this function is called before <a class="el" href="group__group__mtb__ipc.html#ga77a2cf0e944ad38772fda02f21f78b85">mtb_ipc_mbox_receiver_init</a>. Do not call this in an interrupt service routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The IPC object handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sender</td><td>Handle to the mailbox on the core intended to be the sender </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mbox_idx</td><td>Mailbox number in range 0 - <a class="el" href="group__group__mtb__impl__ipc.html#gac0c225a813616672c6ff0587de187d43">MTB_IPC_MAX_MBOXES</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_SEMA_TAKEN MTB_IPC_RSLT_ERR_MBOX_NOT_FOUND </dd></dl>
<p >THis function cannot be called in an ISR</p>

</div>
</div>
<a id="ga30fa1d0adab6edada3dec74e1ba20719" name="ga30fa1d0adab6edada3dec74e1ba20719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30fa1d0adab6edada3dec74e1ba20719">&#9670;&nbsp;</a></span>mtb_ipc_mbox_receiver_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtb_ipc_mbox_receiver_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#gab98223c22d617c699c85728236f84617">mtb_ipc_mbox_receiver_t</a> *&#160;</td>
          <td class="paramname"><em>receiver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the mailbox and disconnects the receiver handle. </p>
<p >This should be called after freeing the sender on the other core.</p>
<p >This operation only removes the mailbox handle from the list of available mailboxes. The mailbox object allocated in the shared memory needs to be freed (if dynamically allocated) by the application. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">receiver</td><td>Mailbox handle used to reference mbox_object stored in shared memory. The receiver acts as the per-core handle for the shared data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ebbf319a4e2eb7fcfe011cc9f7d261c" name="ga6ebbf319a4e2eb7fcfe011cc9f7d261c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ebbf319a4e2eb7fcfe011cc9f7d261c">&#9670;&nbsp;</a></span>mtb_ipc_mbox_sender_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtb_ipc_mbox_sender_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#ga40774ba7e9a5960245f9d269d78fcffc">mtb_ipc_mbox_sender_t</a> *&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnects the sender handle from the shared mailbox object. </p>
<p >This must be done before <a class="el" href="group__group__mtb__ipc.html#ga30fa1d0adab6edada3dec74e1ba20719">mtb_ipc_mbox_receiver_free</a>.</p>
<p >This operation only removes the mailbox handle from the list of available mailboxes. The mailbox object allocated in the shared memory needs to be freed (if dynamically allocated) by the application. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sender</td><td>Mailbox handle used to reference mbox_object stored in shared memory. The sender acts as the per-core handle for the shared data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga33b413fc3eef39e29635122787064324" name="ga33b413fc3eef39e29635122787064324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33b413fc3eef39e29635122787064324">&#9670;&nbsp;</a></span>mtb_ipc_mbox_receiver_register_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtb_ipc_mbox_receiver_register_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#gab98223c22d617c699c85728236f84617">mtb_ipc_mbox_receiver_t</a> *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__ipc.html#ga8ba9704f1475ca16a479816f96be37c6">mtb_ipc_mbox_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback to be executed on the receiver core when certain events occur. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">receiver</td><td>Mailbox handle used to reference mbox_obj store in shared memory. The receiver acts as the per-core handle for the shared data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback handler which will be invoked when an event triggers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_arg</td><td>Generic argument that will be provided to the callback when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d2e30f7952410700a53203a57645f8e" name="ga9d2e30f7952410700a53203a57645f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d2e30f7952410700a53203a57645f8e">&#9670;&nbsp;</a></span>mtb_ipc_mbox_sender_register_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtb_ipc_mbox_sender_register_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#ga40774ba7e9a5960245f9d269d78fcffc">mtb_ipc_mbox_sender_t</a> *&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__ipc.html#ga8ba9704f1475ca16a479816f96be37c6">mtb_ipc_mbox_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback to be executed on the sender core when certain events occur. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sender</td><td>Mailbox handle used to reference mbox_obj store in shared memory. The sender acts as the per-core handle for the shared data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback handler which will be invoked when an event triggers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_arg</td><td>Generic argument that will be provided to the callback when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc947c4789ad6bd42604ee86ff34cd9e" name="gabc947c4789ad6bd42604ee86ff34cd9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc947c4789ad6bd42604ee86ff34cd9e">&#9670;&nbsp;</a></span>mtb_ipc_mbox_sender_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_mbox_sender_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#ga40774ba7e9a5960245f9d269d78fcffc">mtb_ipc_mbox_sender_t</a> *&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds item to the mailbox. </p>
<p >This function can only be called by the sender for this mailbox. If the mailbox is full, it stays there until it times out or the mailbox is no longer full. This function can be blocking or non-blocking (timeout set to ZERO). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sender</td><td>Mailbox handle used to reference mailbox object store in shared memory. The sender acts as the per-core handle for the shared data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payload</td><td>Location of payload item </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_us</td><td>Timeout in microseconds. Value 0 can be used if no timeout needed while <a class="el" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a> can be used to make function block until element is successfully put into the mailbox. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_TIMEOUT MTB_IPC_RSLT_ERR_CANT_OPERATE_IN_ISR_W_TIMEOUT MTB_IPC_RSLT_ERR_MBOX_FULL </dd></dl>

</div>
</div>
<a id="ga8b3da334b3d0f08a6b95907fd6e35723" name="ga8b3da334b3d0f08a6b95907fd6e35723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b3da334b3d0f08a6b95907fd6e35723">&#9670;&nbsp;</a></span>mtb_ipc_mbox_receiver_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t mtb_ipc_mbox_receiver_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#gab98223c22d617c699c85728236f84617">mtb_ipc_mbox_receiver_t</a> *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes one item from the mailbox. </p>
<p >This function can be only called by a receiver handle. This function has a timeout argument (in microseconds). If the mailbox is empty, it stays there until it times out or the mailbox receives a new item. This function can be blocking or non-blocking (timeout set to ZERO). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">receiver</td><td>Mailbox handle used to reference mbox_obj store in shared memory. The receiver acts as the per-core handle for the shared data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">payload</td><td>Location to copy message mailbox item to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_us</td><td>Timeout in microseconds. Value 0 can be used if no timeout needed while <a class="el" href="group__group__mtb__ipc.html#ga08f62ac94b3c25ac661e03da5e0203ed">MTB_IPC_NEVER_TIMEOUT</a> can be used to make function block until element is successfully taken from the mailbox. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS MTB_IPC_RSLT_ERR_INVALID_PARAMETER MTB_IPC_RSLT_ERR_TIMEOUT MTB_IPC_RSLT_ERR_CANT_OPERATE_IN_ISR_W_TIMEOUT MTB_IPC_RSLT_ERR_MBOX_EMPTY </dd></dl>

</div>
</div>
<a id="gabbc934fbf4c2e854cd665afffa0e9357" name="gabbc934fbf4c2e854cd665afffa0e9357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbc934fbf4c2e854cd665afffa0e9357">&#9670;&nbsp;</a></span>mtb_ipc_mbox_receiver_enable_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtb_ipc_mbox_receiver_enable_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#gab98223c22d617c699c85728236f84617">mtb_ipc_mbox_receiver_t</a> *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__ipc.html#ga2d232d3e42b46cce1d39c0551a01a449">mtb_ipc_mbox_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables which events trigger the callback execution for the receiver. </p>
<p >It can trigger for these events <a class="el" href="group__group__mtb__ipc.html#ga2d232d3e42b46cce1d39c0551a01a449">mtb_ipc_mbox_event_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">receiver</td><td>Mailbox handle used to reference mbox_obj stored in shared memory. The receiver acts as the per-core handle for the shared data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>The IPC mailbox event type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>True to turn on specified events, False to turn off </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2d808261b77880d943b092807b3fcbaa" name="ga2d808261b77880d943b092807b3fcbaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d808261b77880d943b092807b3fcbaa">&#9670;&nbsp;</a></span>mtb_ipc_mbox_sender_enable_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtb_ipc_mbox_sender_enable_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__mtb__impl__ipc.html#ga40774ba7e9a5960245f9d269d78fcffc">mtb_ipc_mbox_sender_t</a> *&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mtb__ipc.html#ga2d232d3e42b46cce1d39c0551a01a449">mtb_ipc_mbox_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables which events trigger the callback execution for the sender. </p>
<p >It can trigger for these events <a class="el" href="group__group__mtb__ipc.html#ga2d232d3e42b46cce1d39c0551a01a449">mtb_ipc_mbox_event_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sender</td><td>Mailbox handle used to reference mbox_obj stored in shared memory. The sender acts as the per-core handle for the shared data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>The IPC mailbox event type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>True to turn on specified events, False to turn off </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB IPC Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
